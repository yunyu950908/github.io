<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序算法 - 插入排序]]></title>
    <url>%2F2017%2F10%2F03%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%20-%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序：把当前项 [ 插入 ] 到小于等于它的那一项的后面，而后面的数都大于当前项 从第一个开始，每次选中一个作为当前项 将当前项与上一项进行比较 如果上一项比当前项大，交换位置 直到上一项小于当前项，把当前项插入上一项后面 123456789101112function insertionSort(arr)&#123; for(var i = 1; i &lt; arr.length; i++)&#123; preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current)&#123; arr[preIndex + 1] = arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] = current; &#125; return arr;&#125; （未完待续）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 选择排序]]></title>
    <url>%2F2017%2F10%2F03%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%20-%20%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序：每次 [ 选中 ] 一个最小的放到整个数列的最前面 从第一项开始，以其索引作为标记存起来 将标记的这一项与后面每一项进行比较，遇到比它小的就转移标记，比较结束后就获得了最小数的索引 将最小的那一项交换到第一项 1234567891011121314151617function selectSort(arr)&#123; var minIndex,temp; for(var i = 0; i &lt; arr.length-1; i++)&#123; minIndex = i; for(var j = i + 1; j &lt; arr.length; j++)&#123; if(arr[minIndex] &gt; arr[j])&#123; minIndex = j; &#125; &#125; if(arr[i] !== arr[minIndex])&#123; temp = arr[i] arr[i] = arr[minIndex]; arr[minIndex] = temp &#125; &#125; return arr;&#125; （未完待续）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 冒泡排序]]></title>
    <url>%2F2017%2F10%2F03%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%20-%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[数据结构 + 算法 = 程序 野路子出生的我要开始啃算法啦，从最简单的排序算法开始~ 冒泡排序是最简单的排序算法，let’s go √ 冒泡排序：每次 [ 比较 ] 交换，最大的会被交换到最后 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 12345678910111213function babbleSort(arr)&#123; var temp; for(var i = 0; i &lt; arr.length-1; i++)&#123; for(var j = 0; j &lt; arr.length-1-i; j++)&#123; if(arr[j] &gt; arr[j+1]) &#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; return arr;&#125; 算法分析直接贴百度词条： 推荐跟我一样的新人一个可视化的演示网站，会有一个直观的印象： https://visualgo.net/en/sorting （完）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写一个 new 操作符]]></title>
    <url>%2F2017%2F10%2F03%2F%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-new-%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[原型链必备知识，记录一下。 先来看看 new 操作符干了什么事情 12345678910111213141516171819202122// 先定义一个构造函数 Ffunction F(name,age)&#123; this.name = name; this.age = age;&#125;// 在 F 的原型上定义一个 getInfo 的方法F.prototype = &#123; getInfo: function()&#123; console.log("name: " + this.name) console.log("age: " + this.age) &#125;&#125;// 创建一个 F 的实例var f = new F("Albert",23)// 调用原型上的方法f.getInfo()// 打印出实例 fconsole.log(f) 下面是 控制台 log 出的内容： 现在我们大概可以知道 new 的时候大概做了这么几件事 生成了一个新对象 设置了新对象的原形指向构造函数的原形 设置构造函数实例对象的属性（绑定 this） 知道了 new 操作符暗地里做的苟且之事之后就很容易把这货写出来 12345function myNew(F,...args)&#123; var obj = Object.create(F.prototype); // 使用指定的原型对象及其属性去创建一个新的对象 F.apply(obj,args); // 绑定 this 到obj, 设置 obj 的属性 return obj; // 返回实例&#125; 现在来试一下 1234567891011121314function FF(a,b)&#123; this.a = a; this.b = b;&#125;FF.prototype.test = function()&#123; console.log(this.a+" success "+this.b)&#125;var ff = myNew(FF,"Am I","?")ff.test()console.log(ff) 看一眼控制台，貌似没什么问题。。 emmmmmmm, 一个简易的 new 操作符就实现了，当然不是太严谨，没有控制它传进来的 F ，其他有问题的请一定告诉我。 （完）]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写一个 bind]]></title>
    <url>%2F2017%2F09%2F28%2F%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%20bind%2F</url>
    <content type="text"><![CDATA[一、了解 bindFunction.prototype.bind() - MDN 语法：1fun.bind(thisArg[, arg1[, arg2[, ...]]]) 描述：bind() 方法创建一个新的函数, 当被调用时，将其 this 关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 MDN 把 bind 描述的很清楚，总结一下大概有以下三个特性： 返回值：bind() 方法返回一个新函数。 this：新函数的 this 是调用 bind 的第一个参数，并且该参数不能被重写。 偏函数：bind() 方法的第 2~N 个参数。当 bind 返回的函数被调用时，这些参数将置于实参之前传递。 用代码解释上面三句话： 首先是第一句话跟第二句话，很明显 bind 之后 this 不能被改写。1234567891011var obj1 = &#123;name: "Albert"&#125;var obj2 = &#123;name: "Overwatch"&#125;function sayName()&#123;console.log(this.name)&#125;var b1 = sayName.bind(obj1)var b2 = sayName.bind(obj1).bind(obj2)var b3 = sayName.bind(obj1).call(obj2) // =&gt; Albertb1() // Albertb2() // Albert 然后是第三句话，同样能明显看出其传参规则。12345function getInfo()&#123; console.log(arguments) &#125;var b4 = getInfo.bind(null,"Albert","male")b4(23) 查看控制台打印出的 arguments 参数，结果一目了然。 二、实现 bind 我用了 that 暂存了调用对象 存起 _bind 方法从第二项开始的 arguments 把返回函数的 arguments 与 2. 中存的 arguments 拼接（2. 在前） 执行返回函数的时候绑定调用对象的上下文与参数并执行 123456789Function.prototype._bind = function(ctx)&#123; var that = this; var args = Array.prototype.slice.call(arguments,1); return function()&#123; var args2 = Array.prototype.slice.call(arguments); var all = args.concat(args2); return that.apply(ctx,all) &#125;&#125; 验证一下自定义的 _bind1234567891011121314151617var obj1 = &#123;name: "Albert"&#125;var obj2 = &#123;name: "Overwatch"&#125;function sayName()&#123;console.log(this.name)&#125;var b1 = sayName._bind(obj1)var b2 = sayName._bind(obj1)._bind(obj2)var b3 = sayName._bind(obj1).call(obj2) // =&gt; Albertb1() // Albertb2() // function getInfo()&#123; console.log(arguments) &#125;var b4 = getInfo.bind(null,"Albert","male")b4(23) // "Albert", "male", 23 结果与原生的一样，貌似看起来没什么问题，但肯定不如原生的实现严谨，如果这个实现有问题的话还请告知博主~谢谢大佬~ 有兴趣的小伙伴可以移步 Function.prototype.bind() - MDN 查看其 Polyfill 写法 （完）]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 入门笔记（三）]]></title>
    <url>%2F2017%2F09%2F27%2FReact-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[React 入门笔记（三）元素渲染==&gt; 不可变元素==&gt; 新建渲染替换 按需加载 props 对 &lt;Welcome name=&quot;Sara&quot; /&gt;元素调用了 ReactDOM.render() 方法。 React 将 {name: &#39;Sara&#39;} 作为 props 传入并调用 Welcome 组件。 Welcome 组件将 &lt;h1&gt;Hello, Sara&lt;/h1&gt; 元素作为结果返回。 React DOM 将 DOM 更新为 &lt;h1&gt;Hello, Sara&lt;/h1&gt; 组件的返回值组件的返回值只能有一个根元素。这也是我们要用一个 &lt;div&gt; 来包裹所有 &lt;Welcome /&gt; 元素的原因。 抽离出更细小的，可复用的组件 Props的只读性React是非常灵活的，但它也有一个严格的规则： 所有的React组件必须像纯函数那样使用它们的props。 创建一个有状态的类通过5个步骤将函数组件转换为类 创建一个名称扩展为 React.Component 的ES6 类 创建一个叫做 render() 的空方法 将函数体移动到 render() 方法中 在 render() 方法中，使用 this.props 替换 props 删除剩余的空函数声明 让我们快速回顾一下发生了什么以及调用方法的顺序： 1) 当 &lt;Clock /&gt; 被传递给 ReactDOM.render() 时，React 调用 Clock 组件的构造函数。 由于 Clock 需要显示当前时间，所以使用包含当前时间的对象来初始化 this.state。 我们稍后会更新此状态。 2) React 然后调用 Clock 组件的 render() 方法。这是 React 了解屏幕上应该显示什么内容，然后 React 更新 DOM 以匹配 Clock 的渲染输出。 3) 当 Clock 的输出插入到 DOM 中时，React 调用 componentDidMount() 生命周期钩子。 在其中，Clock 组件要求浏览器设置一个定时器，每秒钟调用一次 tick()。 4) 浏览器每秒钟调用 tick() 方法。 在其中，Clock 组件通过使用包含当前时间的对象调用 setState() 来调度UI更新。 通过调用 setState() ，React 知道状态已经改变，并再次调用 render() 方法来确定屏幕上应当显示什么。 这一次，render() 方法中的 this.state.date 将不同，所以渲染输出将包含更新的时间，并相应地更新DOM。 5) 一旦Clock组件被从DOM中移除，React会调用componentWillUnmount()这个钩子函数，定时器也就会被清除。 构造函数是唯一能够初始化 this.state 的地方。状态更新可能是异步的React 可以将多个setState() 调用合并成一个调用来提高性能。 程墨：setState：这个API设计到底怎么样 生命周期钩子可以控制状态更新 Mount constructor - 初始化props 和 state componentWillMount render componentDidMount update conponentWillReceiveProps(nextProps) shouldComponentUpdate(nextProps, nextState) componentWillUpdate() render() componentDidUpdate() unmount componentWillUnmout 数据自顶向下流动父组件或子组件都不能知道某个组件是有状态还是无状态，并且它们不应该关心某组件是被定义为一个函数还是一个类。 这就是为什么状态通常被称为局部或封装。 除了拥有并设置它的组件外，其它组件不可访问。 组件可以选择将其状态作为属性传递给其子组件 类的方法默认是不会绑定 this如果忘记绑定 this.handleClick 并把它传入 onClick, 当调用这个函数的时候 this 的值会是 undefined。 通常情况下，如果你没有在方法后面添加 () ，例如 onClick={this.handleClick}，你应该为这个方法绑定 this. 属性初始化器语法 回调函数中使用 箭头函数：然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染 传入匿名回调的参数是当前的 state123this.setState(prevState =&gt; (&#123; showWarning: !prevState.showWarning&#125;)); 在极少数情况下，你可能希望隐藏组件，即使它被其他组件渲染。让 render 方法返回 null 而不是它的渲染结果即可实现。 元素变量使用变量来储存元素。它可以帮助你有条件的渲染组件的一部分，而输出的其他部分不会更改。12345678910111213let button = null; if (isLoggedIn) &#123; button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;; &#125; else &#123; button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;; &#125; return ( &lt;div&gt; &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt; &#123;button&#125; &lt;/div&gt; ); 与运算符 &amp;&amp;12345678910return ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &#123;unreadMessages.length &gt; 0 &amp;&amp; &lt;h2&gt; You have &#123;unreadMessages.length&#125; unread messages. &lt;/h2&gt; &#125; &lt;/div&gt; ); 三目运算符12345678render() &#123; const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; The user is &lt;b&gt;&#123;isLoggedIn ? 'currently' : 'not'&#125;&lt;/b&gt; logged in. &lt;/div&gt; );&#125; 渲染多样的组件 ( 数组集合 )元素的key只有在它和它的兄弟节点对比时才有意义。 数组元素中使用的key在其兄弟之间应该是独一无二的。然而，它们不需要是全局唯一的。 key会作为给React的提示，但不会传递给你的组件。如果您的组件中需要使用和key相同的值，请将其作为属性传递： 表单123handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;);&#125; 受控组件由于 value 属性是在我们的表单元素上设置的，因此显示的值将始终为 React数据源上this.state.value 的值。由于每次按键都会触发 handleChange 来更新当前React的state，所展示的值也会随着不同用户的输入而更新。 使用”受控组件”,每个状态的改变都有一个与之相关的处理函数。这样就可以直接修改或验证用户输入。 请注意，Coconut选项最初由于selected属性是被选中的。在React中，会在根select标签上而不是在当前的selected属性上使用value属性。 总之，&lt;input type=&quot;text&quot;&gt;, &lt;textarea&gt;, 和 &lt;select&gt; 都十分类似 - 他们都通过传入一个value属性来实现对组件的控制。 多个输入的解决方法当你有处理多个受控的input元素时，你可以通过给每个元素添加一个name属性，来让处理函数根据 event.target.name的值来选择做什么。 状态提升单项数据流自上而下流动，类似二叉树 子组件可以同伙状态提升把自身状态绑定到公共的父组件 refs何时使用 Refs下面是几个适合使用 refs 的情况： 处理焦点、文本选择或媒体控制。 触发强制动画。 集成第三方 DOM 库 如果可以通过声明式实现，则尽量避免使用 refs。 例如，不要在 Dialog 组件上直接暴露 open() 和 close() 方法，最好传递 isOpen 属性。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 入门笔记（二）]]></title>
    <url>%2F2017%2F09%2F24%2FReact-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[React 入门笔记（二） 笔记概要： CND 引用跑起一个 hello world react 实例； webpack 搭建一个撸React 的开发环境； 基础模块： babel-cli babel-preset-react react react-dom babel-preset-es2015 babel-loader 开发模块： html-webpack-plugin webpack-dev-server HMR 热替换 + react-hot-loader 其他模块：根据自己需求添加 如 devtool : “source-map” 等 零、初探新建一个入口文件 新建一个js ==&gt; hello world 引入 CDN 12&lt;script src=&quot;https://unpkg.com/react@15/dist/react.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/react-dom@15/dist/react-dom.min.js&quot;&gt;&lt;/script&gt; npm 安装 babel ==&gt; babel-cli babel-preset-react npm script ==&gt; ./node_modules/.bin/babel –presets react src –out-dir build –watch 一、webpack 构建开发环境1. 安装基础模块已有模块：babel-clibabel-preset-react 1"build": "./node_modules/.bin/babel --presets react src --out-dir build --watch" 继续安装：reactreact-dombabel-preset-es2015babel-loader .babelrc 配置，管理 babel123456&#123; "presets":[ ["es2015",&#123;"modules":false&#125;], "react" ]&#125; npm script ==&gt; “dev”:”webpack –config webpack.dev.js” webpack.dev.js12345678910111213141516171819202122const path = require("path");const root = __dirname;module.exports = &#123; // 入口文件 entry: path.resolve(root, "src/main.js"), // 出口文件 output: &#123; filename: "bundle.js", path: path.resolve(root, "dist") &#125;, // loaders module: &#123; rules: [ &#123; test: /\.js[x]?$/, use: ["babel-loader"], exclude: /node_modules/ &#125;, ] &#125;&#125; 这个时候已经能跑起来了，但是不够自动化，下面再给 webpack 新增一些配置 2. html-webpack-plugin说明书：https://doc.webpack-china.org/plugins/html-webpack-plugin1234567891011121314// 引入html-webpack-pluginconst HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; // ... // 其他配置保持不变 // ... plugins: [ new HtmlWebpackPlugin(&#123; title: 'React Demo', template: path.resolve(root, 'template.html') &#125;) ]&#125; 3. webpack-dev-server说明书：https://doc.webpack-china.org/guides/development/#-webpack-dev-server123456789101112131415161718module.exports = &#123; // 入口文件 entry: [ "webpack-dev-server/client", path.resolve(root, "src/main.js") ], // 出口文件 output: &#123; filename: "bundle.js", path: path.resolve(root, "dist"), publicPath: "/" &#125;, devServer: &#123; contentBase: path.resolve(root, "dist"), publicPath: "/", port: "3030", historyApiFallback: true &#125;, package.json1"dev": "webpack-dev-server --config webpack.dev.js" HMR 热替换说明书：https://doc.webpack-china.org/guides/hot-module-replacement .babelrc123456789&#123; "presets":[ ["es2015",&#123;"modules":false&#125;], "react" ], "plugins":[ "react-hot-loader/babel" ]&#125; react-hot-loader安装模块 ==&gt; npm i -D react-hot-loader 说明书：https://github.com/gaearon/react-hot-loader 修改 webpack.dev.js123456789101112131415161718192021222324252627entry: [ "react-hot-loader/patch", "webpack-dev-server/client", "webpack/hot/only-dev-server", path.resolve(root, "src/main.js")],//// 其他没变//devServer: &#123; hot: true, contentBase: path.resolve(root, "dist"), publicPath: "/", port: "3030", historyApiFallback: true&#125;,//// 其他没变//plugins: [ new HtmlWebpackPlugin(&#123; title: "React Demo", template: path.resolve(root, "template.html") &#125;), new webpack.HotModuleReplacementPlugin(), new webpack.NamedModulesPlugin()] main.js12345678910111213141516171819import React from 'react'import ReactDOM from 'react-dom'import &#123;AppContainer&#125; from 'react-hot-loader'import App from './App'const render = (App) =&gt; &#123; ReactDOM.render( &lt;AppContainer&gt; &lt;App/&gt; &lt;/AppContainer&gt;, document.getElementById('app') )&#125;;render(App);if (module.hot) &#123; module.hot.accept('./App', () =&gt; render(App))&#125; 然后修改 App.js 里的内容自己调试 （完）]]></content>
      <categories>
        <category>javascript</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个模拟 XSS 攻击的小游戏]]></title>
    <url>%2F2017%2F09%2F24%2F%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%8B%9F-XSS-%E6%94%BB%E5%87%BB%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[一个模拟 XSS 攻击的小游戏 游戏地址 xss-game : https://xss-game.appspot.com/ 由简到难一共六关，覆盖了绝大多数的 XSS 攻击方法，挺有意思的，玩游戏的同时帮助你学习了解 XSS 攻击原理 1. 直接写 script 标签1&lt;script&gt;alert(&quot;xss&quot;)&lt;script&gt; 2. 图片加载失败触发 onerror 方法12// XSS 注入&lt;img src = &quot;asd&quot; onerror=&quot;alert(1)&quot; &gt; 3. 强行闭合标签123456// 在地址栏会显示图片锚点（用拼接 html 方式组合图片）&lt;img src=&apos;123.jpg&apos;&gt;// http://xxx.xxx.xxx#123// XSS 强行闭合标签&apos;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 4. 找到页面中 submit 方法触发 onload 方法的地方12345// submit 3onload="startTimer('3');"// xss 强行闭合3');alert('1 5. 寻找 a 标签跳转 观察地址栏 串改 href 触发 javascript12345678// normal// https://xss-game.appspot.com/level5/frame/signup?next=confirm&lt;a href = &quot;confirm&quot; &gt;// xss// 修改 ==&gt; https://xss-game.appspot.com/level5/frame/signup?next=javascript:alert(1) ==&gt; 转到// 然后 a 标签自动串改&lt;a href = &quot;javascript:alert(1)&quot; &gt; 6. 修改 query 参数 查看 query string 参数 分析 html 中的 javascript 代码 自己做一个 js xss 攻击文件，放在自己服务器 替换 query 参数指向自己的攻击文件 123456789101112// https://xss-game.appspot.com/level6/frame#/static/gadget.js// 下面是当前页面中的某条源码if (url.match(/^https?:\/\//)) &#123;// xss// 查看提示 google 提供一个 api // google.com/jsapi?callback=foo// 拉到最后发现执行了一个 foo() // 替换成 xss 攻击函数// google.com/jsapi?callback=alert("xss")// 替换原始 url // https://xss-game.appspot.com/level6/frame#//google.com/jsapi?callback=alert("xss") 最后是通关奖励]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 入门笔记（一）]]></title>
    <url>%2F2017%2F09%2F24%2FReact-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[React 入门笔记（一） 入门笔记，没有排版格式。 jsx 数组 插入 1234567let jsx3 = ['i','love','react'].map((name) =&gt; &#123; return &lt;div&gt;&#123;name&#125;&lt;/div&gt;&#125;);render( &lt;div&gt;&#123;jsx3&#125;&lt;/div&gt;, RootDom); component pure functional component 从不修改它的 props 12345// * pure functional components const A = (props)=&gt;&#123; return &lt;div&gt;&#123;props.gender &#125; + &#123;props.name&#125;&lt;/div&gt;&#125;;render(&lt;A gender='male' name='slashhuang'/&gt;,RootDom); class component 必须有 render 方法 123456789101112131415161718// CALSS COMPONENTclass FirstComponent extends Component&#123; constructor()&#123; super(); this.state = &#123; b: 1 &#125; &#125; render()&#123; return ( &lt;div&gt; I am a component &#123;this.state.b&#125; &lt;/div&gt;); &#125; &#125;;render(&lt;FirstComponent /&gt;,RootDom); 组件的生命周期： componentWillMount render componentDidMount shouldComponentUpdate componentWillUpdate render componentDidUpdate 常用的生命周期： componentDidMount componentWillReceiveProps shouldComponentUpdate props children {/*&lt;A a=&#39;1&#39;&gt; ==&gt; props = {a:&#39;1&#39;}*/} 12345678910111213141516class Welcome extends Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.gender &#125; + &#123;this.props.name&#125;&lt;/div&gt; &#125;&#125;class ChildComponent extends Component&#123; render()&#123; return ( &lt;div&gt; &#123;this.props.children&#125; &lt;Welcome gender='male' name='slashhuang' /&gt; &lt;/div&gt;); &#125; &#125;;render(&lt;ChildComponent&gt;我是个孩子&lt;/ChildComponent&gt;,RootDom); state + props setState 异步操作，setState后会自动做一些优化操作 然后进入队列 更新状态 123456789101112131415161718192021222324class PropState extends Component&#123; constructor()&#123; super(); this.state=&#123;a:'I am state'&#125; &#125; click()&#123; /** * setState ==&gt; 本组件重新render */ this.setState(&#123; a:'我更新啦 哈哈哈' &#125;) &#125; render()&#123; return &lt;div onClick=&#123;()=&gt;this.click()&#125;&gt; &#123;this.state.a&#125; &lt;A name= &#123;this.state.a&#125; /&gt; &lt;/div&gt; &#125; &#125;;const A = (props) =&gt; &#123; return &lt;div&gt;&#123;props.name&#125;&lt;/div&gt;&#125;render(&lt;PropState/&gt;,RootDom); 总结：1234JSX： xml in javascript1. tagName2. attributes(props)3. children 123组件化：1. 函数式组建: props ==&gt; JSX ; 2. 类组件：class A extendx Component 121. 数据源： state + props2. 更新数据：setState ( 完 )]]></content>
      <categories>
        <category>javascript</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF 跨站请求伪造]]></title>
    <url>%2F2017%2F09%2F23%2FCSRF-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%2F</url>
    <content type="text"><![CDATA[CSRF 跨站请求伪造一、什么是 CSRF引自维基百科：跨站请求伪造 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 二、发起 CSRF 攻击一个防御薄弱的站点，发起 CSRF 攻击特别容易，多数情况下利用浏览器自动加载某些资源的机制发起一个 CSRF 攻击。我们直接举个例子形象地说明 CSRF 攻击原理。 举个栗子 比如你访问了一个银行网站 A，此时浏览器就有了你在此银行网站上登录的 cookie 记录。 然后你因为某些不可描述的原因访问了某危险网站 B，这个网站有个 &lt;img&gt; 标签：( 浏览器加载资源的时候 img 标签中 src 记录的资源会自动加载 )&lt;img src=&quot;http://www.examplebank.com/account=youraccount&amp;amount=1000&amp;payfor=Badman&quot; &gt; 但是，这个 &lt;img&gt; 标签的 src 属性不是一个图片资源的请求，而是向银行网站A 发起一个转账请求（上面 &lt;img&gt; 标签中 src 的意思是在银行 A 网站上从你的账户中转账 1000 给账户 Badman），恰好你的浏览器里保留了你登录银行网站 A 的 cookie，这样 src 内发起的请求就会得到响应，然后你的钱就没了 QAQ 更可怕的是请求响应后可能继续触发某个 delete 转账记录的请求，这样你自己都不知道钱跑哪儿去了。 三、防御 CSRF1、验证码机制限制用户的某些敏感操作，通过添加验证码来识别是不是用户主动去发起这个请求，由于一定强度的验证码机器无法识别，因此危险网站不能伪造一个完整的请求。 优点：简单粗暴，低成本，可靠，能防范99.99%的攻击者。 缺点：对用户不友好。 2、检查 Referer 字段HTTP 头中有一个 Referer 字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer 字段应和请求的地址位于 [ 同一域名 ] 下。而如果是 CSRF 攻击传来的请求，Referer 字段会是包含恶意网址的地址，而不是 [ 同一域名 ] 之下，这时候服务器就能识别出恶意的访问。 这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 http 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer 字段的可能。 举个栗子 比如当你使用支付宝转账的时候，用户必须先登录支付宝网站，然后通过点击页面的的按钮来触发转账事件。 1http://zhifubao.com/withdraw?account=lyq&amp;amount=10000&amp;for=xxx 此时，转账请求的 Referer 值就是转账页面所在的 URL，通常是以 zhifubao.com 域名开头的地址，如果不是，服务器则拒绝请求。 此方法看似挺完美，实际上是这样的： 兼容性不好：每个浏览器对于 Referer 的具体实现可能有差别。 并不一定可靠：在一些古老的垃圾浏览器中， Referer 可以被篡改。 对用户不友好：Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权。因此有些用户可能会开启浏览器防止跟踪功能，不提供 Referer ，从而导致正常用户请求被拒绝。 所以，更多情况下我们都使用下面介绍的第三种方法：添加校验 _csrf_token 3、 添加校验 token由于 CSRF 的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在 cookie 中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行 CSRF 攻击。 这种数据通常是表单中的一个数据项。服务器将其生成并附加在表单中，其内容是一个伪乱数。 当客户端通过表单提交请求时，这个伪乱数也一并提交上去以供校验。 正常的访问时，客户端浏览器能够正确得到并传回这个伪乱数，而通过CSRF 传来的欺骗性攻击中，攻击者无从事先得知这个伪乱数的值，服务器端就会因为校验 token 的值为空或者错误，拒绝这个可疑请求。 再举栗子 有一个 anti-csrf-token 方案， 具体过程如下： 服务端在收到路由请求时，生成一个随机数，在渲染请求页面时把随机数埋入页面 12// 一般埋入 form 表单内&lt;input type="hidden" name="_csrf_token" value="xxxx"&gt; 服务端设置 setCookie ，把该随机数作为 cookie 或者 session 种入用户浏览器当用户发送 GET 或者 POST 请求时带上 _csrf_token 参数（对于 Form 表单直接提交即可，因为会自动把当前表单内所有的 input 提交给后台，包括 _csrf_token） 后台在接受到请求后解析请求的 cookie 获取_csrf_token 的值，然后和用户请求提交的_csrf_token 做个比较，如果相等表示请求是合法的。 PS：注意这里页面上设置的 token 和 session 里设置的 token 不直接相等，实际上是用了 MD5 包了一层，发送到后台后还是很容易计算的。 1md5('1474357164624') === '4bd4e512b0fbd9357150649adadedd4e' 注意事项：使用 [ 校验 token ] 需要注意以下两点： 先写结论：Token 保存在 Session 中 做个假设：token 保存在 cookie 中 假如Token 保存在 Cookie 中，用户浏览器开了很多页面。在一些页面 Token 被使用消耗掉后新的 Token 会被重新种入，但那些老的 Tab 页面对应的 HTML 里还是老 Token。这会让用户觉得为啥几分钟前打开的页面不能正常提交？ 先写结论：尽量少用 GET 做个假设： GET 请求中携带 token 假如攻击者在我们的网站上传了一张图片，用户在加载图片的时候实际上是向攻击者的服务器发送了请求，这个请求会带有 referer 表示当前图片所在的页面的 url。 而如果使用 GET 方式接口的话这个 URL 就形如： 1https://xxxx.com/gift?giftId=aabbcc&amp;_csrf_token=xxxxx 观察上面的 GET 请求，攻击者很容易就获取到用户的 _csrf_token，至少可以在短时间内使用这个 token 来操作其他 GET 接口。 参考资料慕课网：对于跨站伪造请求（CSRF）的理解和总结维基百科：跨站请求伪造知乎：COOKIE和SESSION有什么区别？知乎：CSRF 是什么？]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS 跨站脚本攻击]]></title>
    <url>%2F2017%2F09%2F23%2FXSS-%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[XSS 漏洞1、什么是 XSSXSS（ Cross-Site Scripting）跨站脚本攻击 简单来说 正常用户 A 提交正常内容，显示在另一个用户 B 的网页上，没有问题。 恶意用户 H 提交恶意内容，显示在另一个用户 B 的网页上，对 B 的网页随意篡改。 造成 XSS 有几个要点： 恶意用户可以提交内容 提交的内容可以显示在另一个用户的页面上 这些内容未经过滤，直接运行在另一个用户的页面上 举个栗子假设我们有一个评论系统，恶意用户 H 提交评论&lt;script&gt;console.log(document.cookie)&lt;/script&gt;，而服务器没有对这段代码进行过滤，直接放行。然后用户 B 来访问网站，这段脚本在 B 的浏览器直接执行，恶意用户 H 的脚本就可以任意操作 B 的 cookie，而 B 对此毫无察觉。有了 cookie，恶意用户 H 就可以伪造 B 的登录信息，随意访问 B 的隐私了。而 B 始终被蒙在鼓里。 2、XSS 成因形成 XSS 漏洞的主要成因有以下两个： 后台模板问题后台输出代码的时候没有将可疑的符号（如 &lt;,&gt;,&amp;等）转换成 HTML 编码，没有任何过滤而直接输出，形成 XSS 漏洞。 前端代码问题前端使用 innerHtml 等方式插入字符，如果插入的是 HTML 标签，客户端会直接执行。当然 eval 也可能导致同样的问题，也是我们需要避免使用的。 3、XSS 防御通过以上介绍我们了解了 XSS 攻击的基本原理，下面介绍如何做 XSS 防御： 后台模板过滤所有可疑字符，将其转换成 HTML 编码再输出。 可疑字符 HTML 编码 &lt; &amp;lt; &gt; &amp;gt; &amp; &amp;amp; “ &amp;quot; （此处空格） &amp;nbsp; 其他可疑字符 &amp;#ASCII码 前端代码尽量避免使用 innerHtml 或 eval 这种危险的方式运行代码，没准你的用户就会利用这些 JS 方法的特殊性，在你的网站上嵌入一些恶意的脚本，从而对你的网站及你的客户造成不利影响。 当然还有很多其他方法的 XSS 攻击，有兴趣的小伙伴可以移步我的另一篇文章 《一个模拟-XSS-攻击的小游戏》了解更多的攻击方法，以制定合理的防御策略。 安利：React DOM 在渲染之前默认会过滤 所有传入的值。它可以确保你的应用不会被注入攻击，所有的内容在渲染之前都被转换成了字符串，这样可以有效地防止 XSS(跨站脚本) 攻击。 （完）]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 基础]]></title>
    <url>%2F2017%2F09%2F22%2FHTTP%20%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、HTTP 工作原理1、HTTP 简介借用维基百科的定义：维基百科：超文本传输协议超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网数据通信的基础。 HTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准。HTTP 可以在任何互联网协议上，或其他网络上实现。HTTP 假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在 TCP/IP 协议族使用 TCP 作为其传输层。 2、HTTP 协议所在的协议层在 OSI 七层模型 或 TCP/IP 四层模型中，HTTP 居于应用层，用于规定会话协议。 （如果不清楚两种模型，可以查看我的另一篇介绍这两个网络模型的文章） 3、HTTP 通讯过程（请求 / 响应） 客户端连接到服务器HTTP 客户端创建一个请求，打开一个端口（默认 80）， HTTP 服务器监听端口，双方建立一个TCP 连接。 发送 HTTP 请求通过 TCP 连接，客户端向服务器发送一个文本的请求报文。一个请求报文由 请求行、请求头部、空行 和 请求数据 4部分组成。 服务器接受请求并返回 HTTP 响应服务器解析请求，定位请求资源。服务器将资源复本写到 TCP ，由客户端读取。一个响应由 状态行、响应头部、空行 和 响应数据 4部分组成。 释放 TCP 连接服务器主动关闭释放 TCP 连接；客户端被动关闭释放 TCP 连接。 客户端解析响应内容客户端首先解析状态行，查看表明请求是否成功的状态码。然后解析每一个响应头响应头告知以下响应体为若干字节的文档和文档的字符集。客户端读取响应数据，根据响应告知的规定语法对其进行格式化，并在客户端显示。 4、HTTP协议的无状态性HTTP 协议是无状态的（stateless）。 也就是说，同一个客户端第二次访问同一个服务器上的页面时，服务器无法知道这个客户端曾经访问过，服务器也无法分辨不同的客户端。 HTTP 的无状态特性简化了服务器的设计，使服务器更容易支持大量并发的 HTTP 请求。 5、持久连接 HTTP1.0 使用的是非持久连接，客户端必须为每一个待请求的对象建立并维护一个新的连接。因为同一个页面可能存在多个对象，所以非持久连接可能使一个页面的下载变得十分缓慢，而且这种短连接增加了网络传输的负担。 HTTP1.1 引入了持久连接，允许在同一个连接中存在多次数据请求和响应，即在持久连接情况下，服务器在发送完响应后并不关闭 TCP 连接，而客户端可以通过这个连接继续请求其他对象。 二、HTTP 协议和服务器交互的几种方法HTTP最大的作用就是客户端发送请求，服务器给出响应，客户端想服务器发送请求的方式有很多 1. GETGET 是最常用的方法，通常用于请求服务器发送某个资源 我们平时在浏览器输入网页地址，就是给服务器发送了一个 GET 请求，希望得到这个网页 2. HEADHEAD 方法和 GET 类似，但是在服务器的响应中没有资源的内容，只有资源的一些基本信息，主要用于： 在不获取资源的情况下获取资源信息（类型、大小等） 通过状态码产看资源是否存在 通过查看首部，测试资源是否被修改了 3. PUT和 GET 从服务器获取资源相反，PUT 用于想服务器写入资源。PUT的语义就是让服务器用请求的主体部分创建一个请求URL命名的文档，如果存在就替换 当然处于安全原因，并不是所有的服务器都实现，RESTful API 使它有了用武之地 4. POSTPOST 用于想服务器发送数据，通常用来支持 HTML 的表单（input、select、textarea），表单中的数据会被发送到服务器 5. TRACE客户端发送一个请求的时候，这个请求可能会穿过防火墙、代理、网关和一些其它应用程序，没个中间节点都可能修改HTTP请求，TRACE 方法允许客户端在最终请求发往服务器的时候，看看它变成了什么样子 TRACE 请求会在目的服务器端发送一个“闭环”诊断，行程最后一站服务器会弹回一条TRACE 响应，并在响应主题中携带它收到的原始请求报文 6. DELETEDELETE 方法用于要求服务器删除请求的URL，和PUT一样，服务器可能会不支持 7. OPTIONSOPTIONS 方法用于请求 web服务器告知其支持的各种功能 三、状态码完整的 HTTP 1.1 规范说明书来自于 RFC 2616，HTTP 1.1 的状态码被标记为新特性，用来表示请求的结果，状态码被分为五大类： 100-199 用于指定客户端应相应的某些动作。 200-299 用于表示请求成功。 300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 400-499 用于指出客户端的错误。 500-599 用于支持服务器错误。 PS：你闲着无聊也可以手动指定返回的状态码 =。= 常见的状态码有以下几种： 200 OK 一切正常，对GET和POST请求的应答文档跟在后面。 301 Moved Permanently 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。 304 Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告 诉客户，原来缓冲的文档还可以继续使用。 403 Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。 404 Not Found 无法找到指定位置的资源。这也是一个常用的应答。 500 Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求。 503 Service Unavailable 服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个 Retry-After头。 状态码详解常用对照表 四、报文HTTP 报文是在 HTTP 应用程序之间发送的数据块。这些数据块以一些文本形式的元信息开头，描述报文的内容及含义，后面跟着可选的数据部分 1、报文组成HTTP 报文是简单的格式化数据块，没个报文都包含一条来自客户端的请求或者一条来自服务器的响应，由3个部分组成 对报文进行描述的起始行 —— start line 包含属性的首部块 —— header 可选的包含数据的主体部分 —— body12345HTTP/1.0 200 OKcontent-type: text/plaincontent-length: 19Hi, I&apos;m a message 起始行和首部就是由行分隔的 ASCII 文本，主题是一个可选的数据块，可能是文本、二进制或者空 2、 语法HTTP 报文分为两类 请求报文： 向web服务器请求一个动作 1234&lt;method&gt;&lt;request-URL&gt;&lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; 响应报文： 讲请求结果返回给客户端 1234&lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt;&lt;headers&gt;&lt;entity-body&gt; 首部和方法配合，共同决定了服务器和客户端能做什么，下面是一些常见的报文字段： 3、报文示例 请求头的格式和作用 12345# 请求起始行 start line# POST 表示请求方法# URL 指明了请求访问的资源对象# HTTP/1.1 即请求协议与版本号POST https://jscode.me/message-bus/917f95b18b8841138ea51ea1af878f72/poll?dlp=t HTTP/1.1 首部的格式和作用 12345678910111213141516171819202122232425# 接下来是可选的请求首部字段 header# HOST 接收请求的服务器的主机名和端口号Host: jscode.me# Connection 客户端和服务器是否保持连接Connection: keep-alive# Content-Length 主体的长度Content-Length: 371# Origin 指示了请求来自于哪个站点,该首部用于 CORS 请求或者 POST 请求Origin: https://jscode.me# X-CSRF-Token 防止 CSRF 跨站脚本攻击X-CSRF-Token: 42oPwTGaqQN3SRcAnjz3D1MeFBnADDw6j3hS95WprB00lx93vLop6DIqTTtRRPZ8PXeNlv4yWtmgiGALNbY/qQ==# User-Agent 识别发起请求的用户代理软件的应用类型、操作系统、软件开发商以及版本号User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.79 Safari/537.36# Content-Type 主体的MIMEContent-Type: application/x-www-form-urlencoded; charset=UTF-8# Accept 告诉服务器能够发送那些媒体类型Accept: application/json, text/javascript, */*; q=0.01# Referer 提供了包含当前请求URI的文档的URL，告诉服务器自己来源Referer: https://jscode.me/t/http/288# Accept-Encoding 告诉服务器能够发送那些编码Accept-Encoding: gzip, deflate, br# Accept-Language 告诉服务器能够发送那些语言Accept-Language: zh-CN,zh;q=0.8# Cookie 客户端字符串Cookie: _t=23a29867bd9011b80730c50692ee0db3; 主体的格式和作用 12345# 体 body 与请求首部 header 之间要空一行( 必须 )# ( 可选 )请求主体 body# 任何自定义的内容videoId=2257 4、常用首部字段 通用首部 客户端和服务器都可以实用的就是通用首部 首部 描述 Connection 客户端和服务器是否保持连接 Date 日期，报文创建时间 Update 给出了发送端可能想要升级使用新版本或协议 Via 显示了报文经过的中间节点（代理、网关） Trailer 如果报文采用分块传输编码方式，可以利用这个首部列出位于报文trailer部分的首部集合 Trailer-Encoding 告诉接收端对报文采用什么编码格式 Cache-Control 随报文传送缓存指示 Pragma 早期的随报文传送指示方式 请求首部 首部 描述 Client-IP 客户端IP From 客户端邮件地址 Host 接收请求的服务器的主机名和端口号 Referer 提供了包含当前请求URI的文档的URL，告诉服务器自己来源 User—Agent 发起请求的客户端应用程序 Accept 告诉服务器能够发送那些媒体类型 Accept-Charset 告诉服务器能够发送那些字符集 Accept-Encoding 告诉服务器能够发送那些编码 Accept-Language 告诉服务器能够发送那些语言 Expect 允许客户端列出请求所要求的服务器行为 If-Match 如果ETag和文档当前ETag匹配，就获取文档 If-Modified-Since 除非在某个指定日期之后修改过，否则限制这个请求 If-None-Match 如果ETag和当前文档ETag不符合，获取资源 If-Range 允许对文档否个范围内的条件请求 If-Unmodified-Since 在某个指定日期之后没有修改过，否则现在请求 Cookie 客户端字符串 响应首部 首部 描述 Age 响应持续时间 Server 服务器应用软件名称和版本 Allow 列出了可用的请求方法 Location 告诉客户端实在在哪里，用于定向 Content-Base 解析主体中相对URL的基础URL Content-Encoding 主体编码格式 Content-Language 解析主体时适用的语言 Content-Length 主体的长度或尺寸 Content-Location 资源实际位置 Content-MD5 主体的MD5校验和 Content-Range 在整个资源中此实体部分的字节范围 Content-Type 主体的MIME ETag 主体的实体标记 Expires 过期时间 Last-Modified 实体最后一次修改时间 五、URI 与 URL URI：统一资源标识符（Uniform Resource Identifier)，表示某一具体的互联网资源。 URL：统一资源定位符( Uniform Resource Locator )，URI 的子集，表示资源的地点（通过位置描述资源）。 举个例子：这是一个完整的 URI 地址：1https://user:pass@www.example.cn:443/dir1/dir2/index.html?uid=1#ch1 现在我们拆分一下： 拆解 释义 https:// 协议方案名 user:pass@ （可选）登录信息 www.example.cn 服务器地址 :443 （可选）端口号 /dir1/dir2/index.html 带层次的文件路径 ?uid=1 （可选）查询字符串 #ch1 （可选）片段标识符 现在我们知道了通用的 URI 大概由9部分组成：1&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;/&lt;params&gt;?&lt;query&gt;#&lt;hash&gt; 去除可选部分的 URI 可以长这样（度娘首页）1https://www.baidu.com/index.html 理解 URI 和 URL 的区别，我们引入 URN 这个概念：123URI = Universal Resource Identifier 统一资源标志符URL = Universal Resource Locator 统一资源定位符URN = Universal Resource Name 统一资源名称 不清楚 URL 与 URI 的区别？知乎：HTTP 协议中 URI 和 URL 有什么区别？Stack Overflow：What is the difference between a URI, a URL and a URN?维基百科：统一资源标志符 其他更多 HTTP 相关的内容可以参考：HTTP - MDN （完）]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>报文</tag>
        <tag>URL&amp;URI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI 七层模型 与 TCP/IP 四层模型]]></title>
    <url>%2F2017%2F09%2F22%2FOSI-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B-%E4%B8%8E-TCP-IP-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[OSI 七层模型 与 TCP/IP 四层模型1、OSI 七层模型 OSI 模型 ( Open System Interconnection model ) 是一个开放性的通信系统互连参考模型，他是一个定义得非常好的协议规范。OSI模型有7层结构，每层都可以有几个子层。 OSI 的7层从上到下分别是 ： 7 应用层 6 表示层 5 会话层 4 传输层 3 网络层 2 数据链路层 1 物理层 其中 高层（即7、6、5、4层）定义了应用程序的功能，下面3层（即3、2、1层）主要面向通过网络的端到端的数据流。 各层功能 应用层规定数据的传输协议与其它计算机进行通讯的一个应用，它是对应应用程序的通信服务的。示例：TELNET，HTTP，FTP，NFS，SMTP等。 表示层解决不同系统之间的通信这一层的主要功能是定义数据格式及加密。示例：加密，ASCII等。 会话层建立一个连接它定义了如何开始、控制和结束一个会话。包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的，在某些情况下，如果表示层收到了所有的数据，则用数据代表表示层。示例：RPC，SQL等。 传输层确定端口与端口间的通信协议这层的功能包括是否选择差错恢复协议还是无差错恢复协议，及在同一主机上对不同应用的数据流的输入进行复用，还包括对收到的顺序不对的数据包的重新排序功能。示例：TCP，UDP，SPX。 网络层确定客户端与服务端的位置这层对端到端的包传输进行定义，它定义了能够标识所有结点的逻辑地址，还定义了路由实现的方式和学习的方式。为了适应最大传输单元长度小于包长度的传输介质，网络层还定义了如何将一个包分解成更小的包的分段方法。示例：IP，IPX等。 数据链路层确定了网络数据包的形式它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI等。 物理层所有硬件设施OSI 的物理层规范是有关传输介质的，这些规范通常也参考了其他组织制定的标准。连接头、帧、帧的使用、电流、编码及光调制等都属于各种物理层规范中的内容。物理层常用多个规范完成对所有细节的定义。示例：Rj45，802.3等。 2、TCP/IP 四层模型 OSI 七层模型与《图解HTTP》一书中第一章介绍的 TCP/IP 四层模型可以相互对照了解 TCP/IP 四层模型 从上到下依次是 应用层 传输层 网络层（又称网间层，网络互连层） 网络接口层（又称链路层） 各层功能 应用层确定了向用户提供应用服务时的通信活动应用层对应于 OSI 七层参考模型的应用层和表达层；TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等 传输层确定计算机间数据传输的协议类型传输层对应于 OSI 七层参考模型的传输层,它提供两种端到端的通信服务。其中 TCP 协议(Transmission Control Protocol)提供可靠的数据流运输服务,UDP 协议(Use Datagram Protocol)提供不可靠的用户数据报服务。TCP: 三次握手、四次挥手;UDP: 只负责发包 网络层确定传输双方的位置，处理流动的数据包网络层包含 IP 协议、RIP 协议(Routing Information Protocol,路由信息协议),负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息； 网络接口层处理网络连接的硬件部分网络接口层包括用于协作IP数据在已有网络介质上传输的协议。它定义像地址解析协议(Address Resolution Protocol,ARP)这样的协议,提供 TCP/IP 协议族的数据结构和实际物理硬件之间的接口。 3、OSI 七层模型 与 TCP/IP 四层模型的对应关系OSI 七层网络模型TCP/IP 四层模型对应网络协议应用层（Application）应用层TFTP, FTP, NFS, WAIS表示层（Presentation）Telnet, Rlogin, SNMP, Gopher会话层（Session）SMTP, DNS传输层（Transport）传输层TCP, UDP网络层（Network）网络层IP, ICMP, ARP, RARP, AKP, UUCP数据链路层（Data Link）网络接口FDDI, Ethernet, Arpanet, PDN, SLIP, PPP物理层（Physical）IEEE 802.1A, IEEE 802.2到IEEE 802.11 最后， OSI 是一种理论下的模型，而 TCP/IP 已被广泛使用，成为网络互联事实上的标准。 参考资料 《图解HTTP》第一章 开放系统互连参考模型 简书：深入浅出－网络七层模型&amp;&amp;网络数据包 知乎：如何生动形象、切中要点地讲解 OSI 七层模型和两主机传输过程? （完）]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>OSI 七层模型</tag>
        <tag>TCP/IP 四层模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记：图解HTTP（一）]]></title>
    <url>%2F2017%2F09%2F20%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%9B%BE%E8%A7%A3HTTP%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SVG 地址：https://github.com/yunyu950908/readingNotes]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>图解 HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端页面优化]]></title>
    <url>%2F2017%2F09%2F20%2F%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[原文地址：前端可以做哪些优化 前端可以做哪些优化网页打开的延时, 页面操作的流畅度, 就是一个网站的生命. 我们站在前端的角度, 都可以做哪些优化呢? 来自谷歌的 Web 优化实践 避免资源 404 请求 避免CSS @importimport 依赖关系, 加载完一个再加载另一个 避免使用document.write都用 HTML 来调用, 使用 document.write 浏览器还需要运行 JS 解析器分析下面要做什么 合并、压缩 CSS, JS文件 精灵图整合图像, 字体图标代替部分图片 延迟 JavaScript 加载 启用Keep-Alive 将小的CSS和JavaScript代码内嵌到HTML中 利用浏览器缓存不长变更的资源 尽量减少DNS查询次数 尽量减少重定向 优化样式表和脚本的顺序 避免JavaScripts阻塞渲染 缩小原始图像 指定图像尺寸 来自雅虎的 Web 优化实践 内容优化 避免资源 404 请求 减少 HTTP 请求 减少 DNS 查找 减少重定向 预加载组件 延迟加载脚本和内容 Ajax 缓存文件资源 减少 DOM 元素数量 根据域名划分页面内容 最小化 iframe 数量 服务器优化 使用 CDN 内容分发网络 添加Expires或Cache-Control信息头 Gzip 压缩 设置 Etag , 判断服务器与浏览器缓存中内容的一致性 提前刷新缓冲区 对Ajax请求使用GET方法 避免空的 src cookie 的优化 减少 cookie 的大小 针对Web组件使用域名无关的Cookie ( 突破 cookie 大小的限制 ) CSS 优化 将CSS代码放在HTML页面的顶部 避免使用CSS表达式 使用&lt;link&gt;来代替 @import 避免使用Filters JavaScript 优化 将JavaScript脚本放在页面的底部 将JavaScript和CSS作为外部文件来引用 缩小JavaScript和CSS 删除重复的脚本 最小化DOM的访问 开发智能的事件处理程序 图像优化 优化图片大小 指定图片大小 使用精灵图 favicon 尽量小, 可缓存 针对移动优化 保持组件大小在 25KB 以下, iPhone 不能缓存 25KB 以上文件 打包组件]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 0 - 1 的学习书单]]></title>
    <url>%2F2017%2F09%2F19%2F%E4%BB%8E-0-1-%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%A6%E5%8D%95%2F</url>
    <content type="text"><![CDATA[其中部分书籍是开源作品，能在网上免费浏览。如您喜欢，可以购买实体书支持一下出版商。 零、添加收藏夹 (*^▽^*)开源书籍： 《JavaScript 标准参考教程（alpha）》 http://javascript.ruanyifeng.com/ 《ES6 标准入门》 http://es6.ruanyifeng.com/豆瓣读书：ES6 标准入门 《javascript 秘密花园》http://bonsaiden.github.io/JavaScript-Garden/zh/ 《Promise迷你书》 http://liubin.org/promises-book/ 一、阶段一（切静态页面） CSS 那三本书都是经典中的经典，按年代顺序列出，入门阶段只需通读其中一本基本能写出一个 “ 不是太丑 “ 的静态页面。 《 Head First HTML与CSS（第2版）》豆瓣读书：Head First HTML与CSS（第2版） 《CSS权威指南（第三版）》豆瓣读书：CSS权威指南（第三版） 《精通CSS：高级Web标准解决方案（第2版）》豆瓣读书：精通CSS（第2版） 《CSS揭秘》豆瓣读书：CSS揭秘 二、阶段二（简单交互） 《JavaScript DOM编程艺术（第2版）》豆瓣读书：JavaScript DOM编程艺术（第2版） 三、阶段三（能力养成） JavaScript高级程序设计 与 JavaScript权威指南 二选一即可，内容大同小异。但无疑是一本好书，每个阶段翻看都会有不懂的感悟。 《JavaScript高级程序设计（第3版）》豆瓣读书：JavaScript高级程序设计（第3版） 《JavaScript语言精粹》豆瓣读书：JavaScript语言精粹 《JavaScript权威指南(第四版)》豆瓣读书：JAVASCRIPT权威指南(第四版) 《你不知道的JavaScript（上卷）》豆瓣读书：你不知道的JavaScript（上卷） 《你不知道的JavaScript（中卷）》豆瓣读书：你不知道的JavaScript（中卷） 《JavaScript设计模式与开发实践》豆瓣读书：JavaScript设计模式与开发实践 四、最终阶段多逛一些优质社区，向别人学习！ 社区推荐：（不区分顺序，想到什么写什么） 知乎 https://www.zhihu.com/ 掘金 https://juejin.im/ segmentfault https://segmentfault.com/ StackOverflow https://stackoverflow.com/ 简书 http://www.jianshu.com/ freeCodeCamp https://www.freecodecamp.cn/ 各种框架社区 =。= 结语虽然列了很多书，但事实上是，入门阶段看博客与翻文档更多，当你感觉需要提高，补充基础的时候，看书有奇效。 最后，上面列出的那么多东西，我也只看了其中的一小部分，正在慢慢补充中。。。 （完）]]></content>
      <categories>
        <category>书单</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒子模型]]></title>
    <url>%2F2017%2F09%2F18%2F%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[梳理基础知识，从 CSS 盒模型开始！ 一、什么是盒子模型我们先看一张图： @盒子模型 | center 最开始看着这张图的时候，觉得与其说是盒模型，倒不如说是张画布( 不是 canvas svg 的意思 )，直到我遇上了外边距合并 (ｷ｀ﾟДﾟ´)!! 下面，请听我娓娓道来。 首先，这货规定了哪些地方你可以画上哪些东西： 如图所示，由内而外依次是 content , padding , bording , margin content : 真正容纳东西的区域，在 content 中你可以画上 其他元素、文本 等任意内容。 padding : 盒子的内边距，包裹在 content 之外，可以想象成快递中的空气气囊，夹在 border 和 content 之间。 border : 盒子的边框，相当于你在 padding 外镶了一层。border 可以指定 颜色、粗细、样式等。（相当于一个阉割版的 content） margin : 盒子的外边距外边距，这个盒子周围空置的安全区域（在不发生外边距折叠的情况下） 二、使用开发者工具查看盒模型emmmmm，个人觉得先学会使用开发者工具的部分功能后，会对学习盒子模型降低很大的时间成本。 话不多说，直接看图： 不对不对，你打开 Chrome 浏览器先 =。= 这时候你可以单击检查，然后会弹出控制台（开发者工具）。当然你也可以按 F12 Elements : 网页中的各个元素，你可以尝试着移动鼠标到某个元素后，单机选中元素，然后会得到类似如下图一样结果，注意红线选中部分。 （当然一般都是单击左上角的一个小鼠标箭头的图标，然后直接单击网页呈现的内容选择） 右上角的箭头，单击后可以直接单击选择页面呈现的元素，并在控制台中定位 DOM 文档中蓝色背景标签 p，我刚刚选中的那个元素 下面有个类似导航条一样的东西，是当前选中元素所在的层级 右边 styles 是当前元素的 CSS 样式，点击 computed 可以查看最终计算后的样式 styles 一栏滚动到底部有这么一个花里胡哨的框框，就是盒子模型，从内到外依次和上面介绍的那个一样，而且有文字注明 ok,知道了这些基本使用后，我们来了解一下盒子模型的尺寸 三、盒模型的尺寸慢着，在讲盒模型尺寸前，最好先简单了解一个可以帮助你解决很多问题的属性： box-sizing box-sizing 属性可以帮助我们在 标准盒模型 与 IE 盒模型 中自由切换（为什么这么称呼请自行 Google） 需要注意的是：这两个盒子模型的尺寸的计算方法是不一样的！ box-sizing : border-box; （IE 盒模型）观察下图，明显表示了，在 IE 盒模型中 width = content 宽度 + 左右 padding 宽度 + 左右 border 宽度 height = content 高度 + 左右 padding 高度 + 左右 border 高度 @IE盒模型 | center box-sizing : content-box; （标准盒模型）标准盒模型是默认值，现在看一下与 IE 盒模型有什么不同 width = content 宽度 height = content 高度 @标准盒模型 | center box-sizing : inherit;继承父元素的盒模型样式。 以上就是 box-sizing 的简介，很简单，但很实用。 兼容性关于兼容性的问题，请移步 caniuse.com 关于盒子模型的介绍基本就到这里。 （完）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>盒子模型</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nrm ---- npm registry 管理工具]]></title>
    <url>%2F2017%2F09%2F18%2Fnrm-npm-registry-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[一、什么是 nrm一个 npm registry 管理工具。 二、nrm 干嘛用可以快速切换至其他 npm 源下载你需要的包 三、为什么要用 当前源不稳定，安装某些包时经常卡住不动 npm 官方源上不去了（国内互联网不可描述的原因） 你不会手动切换 npm 其他源，或者你不知道还有哪些源 四、如何使用 install 1npm install -g nrm show registry list 123456789nrm ls* npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ change target registry 1234# switch registry to cnpmnrm use cnpm Registry has been set to: http://r.cnpmjs.org/ show help 123nrm help# here to show all of the nrm cmmands 五、注意事项当你使用其他源的时候，你无法使用 npm 的 publish 命令发布你的 npm 包，需要切换回官方源。 参考资料 nrm – NPM registry manager - Github （完）]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>nrm</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX 与 XMLHttpRequest 入门]]></title>
    <url>%2F2017%2F09%2F14%2FAJAX-%E4%B8%8E-XMLHttpRequest%2F</url>
    <content type="text"><![CDATA[一、 AJAX 简介 AJAX 全称 AsynchronousJavascript+XML ==&gt; 异步传输 + js + xml。 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果我们可以再来处理这个事。这个很重要，如果不是这样的话，我们点完按钮，页面就会死在那里，其他的数据请求不会往下走了。这样比等待刷新似乎更加讨厌。 虽然提供异步通讯功能的组件默认情况下都是异步的，但它们也提供了同步选项，如果你好奇把那个默认参数为 true 的选项改为 false ，你的页面就会死在那里，等待请求结果返回之后再执行下一步操作。 xml 只是一种数据格式，在这件事里并不重要，我们在更新一行字的时候理论上说不需要这个格式，但如果我们更新很多内容，那么格式化的数据可以使我们有条理地去实现更新。 目前大部分都是在用 JSON 这种格式来代替 XML 的，因为前者更加简洁，据说目前的解析速度也更快。 总结：只要是 JS 调用异步通讯组件并使用格式化的数据来更新 web 页面上的内容或操作过程，那么我们用的方法就可算是 AJAX 二、使用 AJAXok 看了上面的简介部分，是时候实际运用一波了，来来，把手伸出来 这里是一个简单的例子：12345678910111213141516171819202122232425262728293031// 定义一个存储请求 URL 地址的变量var getWeather = "https://jirenguapi.applinzi.com/weather.php";// 定义一个发送 AJAX 请求的函数function sendAJAX(url)&#123; // 构造一个 XMLHttpRequest 实例 var xhr = new XMLHttpRequest(); // 调用open 方法创建一个新的 HTTP 请求，并指定此请求的方法、URL 等信息 xhr.open("GET", url, true) // 调用 send 方法发送请求 xhr.send() // 追踪 AJAX 请求状态 xhr.onreadystatechange = function()&#123; // 对应 readyState 值为4 表示请求完成 if(xhr.readyState === 4)&#123; // 判断返回的 HTTP 状态码 if(xhr.status === 200 || xhr === 304 )&#123; // 把请求到的 JSON 格式字符串转换为 JSON 格式对象 var yunyu = JSON.parse(xhr.responseText) // 控制台答应请求到的 JSON 对象 console.log(yunyu) &#125;else&#123; console.log("没有拿到数据哦") &#125; &#125; xhr.onerror = function()&#123; console.log("异常！异常！") &#125; &#125;&#125;// 调用 sendAJAX 参数是最初定义的 URLsendAJAX(getWeather) 请求成功后你的控制台可能会出现一个这样子的打印 如果跟以上截图一样的，说明你请求成功了，怎么样 484很简单 (*^▽^*) emmmm，当然也可能出现其他打印，比如请求不成功的时候,或者是一些其他问题，同时会返回其他对应的状态码。 关于状态码的问题，可以移步这里 HTTP 状态码详解 当然，上面的例子还有其他写法，比如这样：123456789101112131415function sendAJAX(url)&#123; var xhr = new XMLHttpRequest() xhr.open("GET", url, true) xhr.send() xhr.onload = function () &#123; if ((xhr.status ===200 ) || xhr.status === 304) &#123; console.log(JSON.parse(xhr.responseText)) &#125; else &#123; console.log("服务器异常") &#125; &#125; xhr.onerror = function () &#123; console.log("服务器异常") &#125;&#125; ok，简单了解了 AJAX 的写法之后我们来看一下它的核心部分 XMLHttpRequest 三、XMLHttpRequest XMLHttpRequest 是 AJAX 的核心部分，上面所说的 AJAX 其实只是一种技术方案，并不是一种新技术。通常所说的 AJAX 请求，实际上是使用 XMLHttpRequest 对象来发送一个 AJAX 请求。 现在我们看另一种发送请求的方法 POST 1234567891011121314151617181920212223242526function sendAJAX() &#123; var xhr = new XMLHttpRequest()// 可选，设置xhr请求的超时时间 xhr.timeout = 3000; xhr.open('POST', '/register', true) xhr.send('username=yunyu&amp;password=123456') xhr.onload = function (e) &#123; if ((xhr.status === 200 ) || xhr.status === 304) &#123; console.log(this.responseText) &#125; &#125;// 可选 xhr.ontimeout = function (e) &#123; console.log('请求超时') &#125;// 可选 xhr.onerror = function (e) &#123; console.log('连接失败') &#125;// 可选 xhr.upload.onprogress = function (e) &#123; //如果是上传文件，可以获取上传进度 &#125;&#125; 当然，以上内容还只是 xhr 对象的冰山一角，有兴趣的同学可以看文末的参考资料，里面有详细的 XMLHttpRequest 描述。 1、获取 response 数据xhr 提供了3个属性来获取请求返回的数据，分别是：xhr.response、xhr.responseText、xhr.responseXML xhr.response 默认值：空字符串”” 当请求完成时，此属性才有正确的值 请求未完成时，此属性的值可能是 &quot;&quot; 或者 null ，具体与 xhr.responseType 有关：当 responseType 为 &quot;&quot; 或 &quot;text&quot; 时，值为 &quot;&quot; ；responseType 为其他值时，值为 null 2、追踪请求当前的状态xhr 对象有个只读属性 readyState , 这个属性可追踪到共 5 种可能值，分别对应 xhr 状态的不同阶段。每次 xhr.readyState 的值发生变化时，都会触发 xhr.onreadystatechange 事件，我们可以在这个事件中进行相关状态判断。 值 状态 描述 0 UNSENT (初始状态，未打开) 此时 xhr 对象被成功构造，open() 方法还未被调用 1 OPENED (已打开，未发送) open() 方法已被成功调用，send() 方法还未被调用。注意：只有 xhr 处于 OPENED 状态，才能调用 xhr.setRequestHeader() 和 xhr.send(),否则会报错 2 HEADERS_RECEIVED (已获取响应头) send() 方法已经被调用, 响应头和响应状态已经返回 3 LOADING (正在下载响应体) 响应体(response entity body)正在下载中，此状态下通过 xhr.response 可能已经有了响应数据 4 DONE (整个数据传输过程结束) 整个数据传输过程结束，不管本次请求是成功还是失败 3、通过控制台调试 通过打断点的方式，在 Source 观察源文件的数据变动。 最右边有个 watch ， readyState 状态变更时候， 会显示 xhr 对象相应的数据和状态的变动。 4、发一个同步请求xhr 默认发的是异步请求，但也支持发同步请求（当然实际开发中应该尽量避免使用）。到底是异步还是同步请求，由 xhr.open() 传入的 async 参数决定。 12// open 语法 参数open(method, url [, async = true [, username = null [, password = null]]]) method: 请求的方式，如GET/POST/HEADER等，这个参数不区分大小写 12xhr.open("GET", url)xhr.open("POST", url) url: 请求的地址，可以是相对地址如example.php，这个相对是相对于当前网页的url路径；也可以是绝对地址如 http://www.example.com/example.php 12xhr.open("GET", "../../example.php")xhr.open("GET", "http://www.example.com/example.php") async: 默认值为 true，即为异步请求，若设置为 false，则为同步请求 12xhr.open("GET", "../../example.php", true)xhr.open("GET", "http://www.example.com/example.php", false) 5、实际使用实际上以上内容已经包含了大部分的使用情况，你可以根据自己的需求进一步封装成一个 AJAX 组件，或者也可以使用现成的 jQuery 封装的 AJAX 组件 （jQuery.ajax()），两者功能是一样的。 当然，如果你对这方面比较感兴趣的话，我想你一定不想错过 fetch API ，它简化了 AJAX 的操作代码，但能够一丝不苟的做着同样的工作。但是，它目前依然只是一个实验中的功能，目前在浏览器的兼容方面还不是特别理想。 Fetch API - MDN 以上，就是 AJAX 和 XMLHttpRequest 的常用玩法，其他更具体更细节的玩法可以在以下的参考资料中学习了解。 参考资料XMLHttpRequest Level 2 使用指南 - 阮一峰 XMLHttpRequest - MDN Using XMLHttpRequest - MDN AJAX tutorial 你真的会使用XMLHttpRequest吗？ - ruoyiqing]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>XMLHttpRequest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS判断数据类型]]></title>
    <url>%2F2017%2F09%2F10%2FJS%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JS判断数据类型 本文摘要：列举了常用的数据类型检查方法、应用场景及使用技巧。 1、JavaScript 数据类型最新的 ECMAScript 标准定义了 7 种数据类型，主要分类两大类： 第一类：Primitive ( 原始类型 ) boolean null undefined number string symbol ( ES6 ) 第二类：Object ( 对象类型 ) Object ( Object , Array , RegExp , Function , etc.) 类型区分 原始类型：直接将值传递给变量 对象类型：将一个堆内存中的引用( 如 0xFFFF ) 传给变量 ( 如果正在看文章的你对类型区分不太了解，请自行查阅补充 ) 2、判断数据类型的方法方法一：typeof 操作符typeof 是一个最简单的判断数据类型的操作符。 语法：typeof() 在 () 中填入你想判断类型的数据。返回值：”boolean” , “string” , “number” , “undefined” , “symbol” , “object” 示例：1234typeof(123) // "number"typeof("string") // "string"typeof(true) // "boolean"typeof(Symbol()) // "symbol" emmmmm…如果你只看这几个示例好像 typeof 并没有什么问题，但实际上typeof 这货比较 呆萌 ，实际使用中往往得不到你想要的结果。示例请看下表：( 如果你对此表抱有疑问，请自行前往控制台输入 ) 注：JavaScript 标准文档中定义: [[Class]] 的值只可能是下面字符串中的一个： Arguments, Array, Boolean, Date, Error, Function, JSON, Math, Number, Object, RegExp, String. Value : typeof 操作符运算的值 Type : typeof 操作符运算的结果 Class : 对象内部属性 [[Class]] 的值 Value Class Type “foo” String string new String(“foo”) String object 1.2 Number number new Number(1.2) Number object true Boolean boolean new Boolean(true) Boolean object new Date() Date object new Error() Error object [1,2,3] Array object new Array(1, 2, 3) Array object new Function(“”) Function function /abc/g RegExp object new RegExp(“meow”) RegExp object {} Object object new Object() Object object 通过以上测试可以发现，用 typeof 操作符判断数据类型的时候，在大多数情况下都返回 “object”，所以呆萌的 typeof 或许不是你想要的那种精明能干的操作符。 方法二：instanceof 操作符instanceof 操作符用来比较两个操作数据的构造函数。 语法：&lt;case&gt; instanceof &lt;Constructor&gt;返回值：true / false instanceof 操作符只有在比较自定义的对象时才有意义。 如果用来比较内置类型，将会和 typeof 操作符 一样用处不大 比较自定义对象12345678910function Foo() &#123;&#125;function Bar() &#123;&#125;Bar.prototype = new Foo();new Bar() instanceof Bar; // truenew Bar() instanceof Foo; // true// 如果仅仅设置 Bar.prototype 为函数 Foo 本身，而不是 Foo 构造函数的一个实例Bar.prototype = Foo;new Bar() instanceof Foo; // false 比较内置类型12345new String('foo') instanceof String; // truenew String('foo') instanceof Object; // true'foo' instanceof String; // false'foo' instanceof Object; // false 注意：instanceof 用来比较属于不同 JavaScript 上下文的对象（比如，浏览器中不同的文档结构）时将会出错， 因为它们的构造函数不会是同一个对象。 方法三：终极必杀技 Object.prototype.toString对象的类定义：JavaScript 标准文档只给出了一种获取 [[Class]] 值的方法，那就是使用 Object.prototype.toString 同样使用上面 typeof 判断类型表中 Value 字段的值，这次我们使用 Object.prototype.toString 12345678910111213141516171819function checkDataType(val)&#123; return Object.prototype.toString.call(val)&#125;checkDataType("foo") // =&gt; "[object String]"checkDataType(new String("foo") ) // =&gt; "[object String]"checkDataType(1.2) // =&gt; "[object Number]"checkDataType(new Number(1.2) ) // =&gt; "[object Number]"checkDataType(true) // =&gt; "[object Boolean]"checkDataType(new Boolean(true) ) // =&gt; "[object Boolean]"checkDataType(new Date()) // =&gt; "[object Date]"checkDataType(new Error() ) // =&gt; "[object Error]"checkDataType([1,2,3] ) // =&gt; "[object Array]"checkDataType(new Array(1, 2, 3)) // =&gt; "[object Array]"checkDataType(new Function("")) // =&gt; "[object Function]"checkDataType(/abc/g) // =&gt; "[object RegExp]"checkDataType(new RegExp("meow")) // =&gt; "[object RegExp]"checkDataType(&#123;&#125;) // =&gt; "[object Object]"checkDataType(new Object()) // =&gt; "[object Object]" 当然，如果你可以通过 slice 让返回值变得简短一点，通过 toLowerCase 变成我们熟悉的小写类型。12345function checkDataType(val)&#123; return Object.prototype.toString.call(val).slice(8,-1).toLowerCase()&#125;checkDataType("foo") // =&gt; "string" 3、结论当检测一个对象类型的时候，建议使用 Object.prototype.toString 方法；通过以上对比可以发现，这是唯一一个靠谱的判断数据类型的方法。正如上面表格所示，typeof 的一些返回值在标准文档中并未定义，所以它可能会给你一个意料之外的答案。而 instanceof 操作符应仅用来比较同一个 JavaScript 上下文 ( 文档 ) 中的自定义对象。 参考资料 JavaScript 数据类型和数据结构 JavaScript-Garden 表达式和运算符 - typeof 表达式和运算符 - instanceof Object.prototype.toString()]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器爸爸之页面渲染]]></title>
    <url>%2F2017%2F09%2F10%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%88%B8%E7%88%B8%E4%B9%8B%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[浏览器爸爸之页面渲染一、CSS 和 JS 在网页中的放置顺序 CSS最好放置在&lt;head&gt;标签中如果将css样式放在底部，会造成浏览器先加载html然后再加载css，重绘页面，造成 闪屏 现象。 JS最好放置在body标签内的最后面 JavaScript的加载： 加载脚本会阻塞后面内容的呈现 加载脚本会阻塞其后组件的下载 原因：对于图片和 CSS，在加载时会并发加载，而 JS 在加载的时候会阻止并发，并禁止其他资源加载，所以如果将JS放入页面顶部会导致白屏现象。（在 CSS 中使用 @import 或将样式表放在页面底部也可能导致白屏） 二、白屏 和 FOUC原理： 主要是由于浏览器在处理 HTML 和 CSS 的方式有些不同： 一类是等 HTML 和 CSS 都加载完了，再展示到页面上，等待时间就是白屏。 另一类先展示 HTML ，等 CSS 加载完之后再展示样式，出现 FOUC （无样式内容闪烁）。 还有一些其他原因也会造成白屏和 FOUC 。 白屏： 如果把样式放在底部,对于IE浏览器,在某些场景下（新窗口打开,刷新等）页面会出现白屏，而不是内容逐步展现； 如果使用 @import 标签，即使是在头部的 &lt;head&gt; 标签内 使用 link 引入 CSS，也可能出现白屏； JS 加载会阻塞后面内容的呈现，如果将 JS 放到 head 标签中并且加载时间很长，页面也有可能出现白屏； FOUC：Flash Of Unstyled Content （文档无样式闪烁） 原因：浏览器先逐步加载无样式的内容，等 CSS加载后页面突然展现样式。 对于 Firefox，渲染机制与 Chrome 略有不同，因此会出现 FOUC; 在底部引入 CSS 样式； 对于IE，在某些场景下（点击链接，输入URL，使用书签进入等），也会出现 FOUC 现象 三、async 和 defer 的作用与区别1. 没有 defer 或 async1&lt;script src="script.js"&gt;&lt;/script&gt; 浏览器会立即加载并执行指定的脚本，” 立即 “的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。 2. 有 async1&lt;script async src="script.js"&gt;&lt;/script&gt; 加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 3. 有 defer1&lt;script defer src="myscript.js"&gt;&lt;/script&gt; 加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 实用角度来说，把所有脚本都丢到 &lt;/body&gt; 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。 四、网页的渲染机制（简版） 解析 HTML 标签，生成 DOM 树 解析 CSS 元素，生成 CSSOM 树 把 DOM 和 CSSOM 组合成渲染树 在渲染树的基础上进行布局，计算每个节点的几何结构 把每个节点绘制到屏幕上 参考资料 Render-tree construction, layout, and paint How browsers work]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件代理（事件委托）]]></title>
    <url>%2F2017%2F09%2F09%2F%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[占坑]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>事件代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试题：数组、API]]></title>
    <url>%2F2017%2F09%2F06%2F%E8%AF%95%E9%A2%98%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81API%2F</url>
    <content type="text"><![CDATA[试题：数组、API 试题来源：https://www.nowcoder.com/注意：答题器不支持ES6语法 前排提示尽量用不同的 API 去实现题目需求，这样才能更快掌握更多的 API参考 API 都在这里：JavaScript 标准库：Array 前排提示x2：一定要注意 API 的返回值！ 1. 查找数组元素位置找出元素 item 在给定数组 arr 中的位置如果数组中存在 item，则返回元素在数组中的位置，否则返回 -1 123function indexOf(arr, item)&#123; /* your code here */&#125; 输入 [ 1, 2, 3, 4 ], 3 输出 2 indexOf + map1234567891011121314function indexOf(arr, item) &#123; if(Array.prototype.indexOf)&#123; return arr.indexOf(item) &#125;else&#123; var index; arr.map(function(e,i)&#123; if(e === item)&#123; index = i; &#125; &#125;) return index; &#125; return -1;&#125; 2. 数组求和计算给定数组 arr 中所有元素的总和数组中的元素均为 Number 类型 123function sum(arr) &#123; /* your code here */&#125; 输入 [ 1, 2, 3, 4 ] 输出 10 递归 + slice 12345678910function sum(arr) &#123; var len = arr.length; if(len === 0)&#123; return 0; &#125;else if(len === 1)&#123; return arr[0]; &#125;else&#123; return arr[0] + sum(arr.slice(1)) &#125;&#125; reduce 12345function sum(arr) &#123; return arr.reduce(function(prev,curr,idx,arr)&#123; return prev + curr; &#125;)&#125; 3. 移除数组中的元素移除数组 arr 中的所有值与 item 相等的元素。不要直接修改数组 arr，结果返回新的数组 123function remove(arr, item) &#123; /* your code here */&#125; 输入 [1, 2, 3, 4, 2], 2 输出 [1, 3, 4] filter 12345function remove(arr,item)&#123; return arr.filter(function(e)&#123; return e !== item; &#125;)&#125; slice + splice 12345678910function remove(arr,item)&#123; var newArr = arr.slice(0); for(var i=0,len=newArr.length; i&lt;len; i++)&#123; if(newArr[i]===item)&#123; newArr.splice(i,1) // PS：这样会改变后面每一项的索引，当然有更好的写法 i--; &#125; &#125; return newArr;&#125; 4. 移除数组中的元素移除数组 arr 中的所有值与 item 相等的元素，直接在给定的 arr 数组上进行操作，并将结果返回 123function removeWithoutCopy(arr, item) &#123; /* your code here */&#125; 输入 [1, 2, 2, 3, 4, 2, 2], 2 输出 [1, 3, 4] while123456function removeWithoutCopy(arr, item) &#123; while(arr.indexOf(item)!==-1)&#123; arr.splice(arr.indexOf(item),1) &#125; return arr;&#125; 5. 添加元素在数组 arr 末尾添加元素 item。不要直接修改数组 arr，结果返回新的数组 123function append(arr, item) &#123; /* your code here */&#125; 输入 [1, 2, 3, 4], 10 输出 [1, 2, 3, 4, 10] concat123function append(arr, item) &#123; return arr.concat(item)&#125; 6. 删除数组最后一个元素删除数组 arr 最后一个元素。不要直接修改数组 arr，结果返回新的数组 123function truncate(arr) &#123; /* your code here */&#125; 输入 [1, 2, 3, 4] 输出 [1, 2, 3] pop + slice12345function truncate(arr) &#123; var newArr = arr.slice(0); newArr.pop(); return newArr;&#125; 7. 在数组开头添加元素在数组 arr 开头添加元素 item。不要直接修改数组 arr，结果返回新的数组 123function prepend(arr, item) &#123; /* your code here */&#125; 输入 [1, 2, 3, 4], 10 输出 [1, 2, 3, 4], 10 slice + unshift12345function prepend(arr, item) &#123; var newArr = arr.slice(0) newArr.unshift(item) return newArr&#125; 8. 删除数组第一个元素删除数组 arr 第一个元素。不要直接修改数组 arr，结果返回新的数组 123function curtail(arr) &#123; /* your code here */&#125; 输入 [1, 2, 3, 4] 输出 [2, 3, 4] concat + shift12345function curtail(arr) &#123; var newArr = arr.concat() newArr.shift() return newArr&#125; 9. 数组合并合并数组 arr1 和数组 arr2。不要直接修改数组 arr，结果返回新的数组 123function concat(arr1, arr2) &#123; /* your code here */&#125; 输入 [1, 2, 3, 4], [‘a’, ‘b’, ‘c’, 1] 输出 [1, 2, 3, 4, ‘a’, ‘b’, ‘c’, 1] slice + push +apply12345function concat(arr1, arr2) &#123; var newArr = arr1.slice(0); Array.prototype.push.apply(newArr,arr2); return newArr;&#125; 10. 在数组中间添加元素在数组 arr 的 index 处添加元素 item。不要直接修改数组 arr，结果返回新的数组 123function insert(arr, item, index) &#123; /* your code here */&#125; 输入 [1, 2, 3, 4], ‘z’, 2 输出 [1, 2, ‘z’, 3, 4] slice + splice12345function insert(arr, item, index) &#123; var newArr = arr.slice(0); newArr.splice(index,0,item); return newArr;&#125; 11. 计数统计数组 arr 中值等于 item 的元素出现的次数 123function count(arr, item) &#123; /* your code here */&#125; 输入 [1, 2, 4, 4, 3, 4, 3], 4 输出 3 filter123456function count(arr, item) &#123; var newArr = arr.filter(function(e)&#123; return e === item; &#125;); return newArr.length;&#125; 12. 查找重复元素123function duplicates(arr) &#123; /* your code here */&#125; 输入 [1, 2, 4, 4, 3, 3, 1, 5, 3] 输出 [1, 3, 4] indexOf + lastIndexOf123456789function duplicates(arr) &#123; var newArr = []; arr.forEach(function(e,i)&#123; if(newArr.indexOf(e)===-1 &amp;&amp; arr.indexOf(e)!==-1 &amp;&amp; arr.indexOf(e)!== arr.lastIndexOf(e))&#123; newArr.push(e); &#125; &#125;) return newArr;&#125; 13. 求二次方为数组 arr 中的每个元素求二次方。不要直接修改数组 arr，结果返回新的数组 123function square(arr) &#123; /* your code here */&#125; 输入 [1, 2, 3, 4] 输出 [1, 4, 9, 16] map12345function square(arr) &#123; return arr.map(function(e)&#123; return e*e &#125;)&#125; 14. 查找元素位置在数组 arr 中，查找值与 item 相等的元素出现的所有位置 123function findAllOccurrences(arr, target) &#123; /* your code here */&#125; 输入 ‘abcdefabc’,’a’ 输出 [0,6] forEach + || + push1234567function findAllOccurrences(arr, target) &#123;var temp = []; arr.forEach(function(e,i)&#123; e !== target || temp.push(i); &#125;); return temp;&#125; 总结以上 14 道数组类型的题目，按照本文的解题思路走下来，通过参考 MDN 文档，你可能学习掌握了以下 API ： 以下所有数组 API 你都可以在这里找到：JavaScript 标准库：Array Array.length Array.prototype.concat() Array.prototype.filter() Array.prototype.forEach() Array.prototype.indexOf() Array.prototype.lastIndexOf() Array.prototype.map() Array.prototype.pop() Array.prototype.push() Array.prototype.reduce() Array.prototype.shift() Array.prototype.slice() Array.prototype.splice() Array.prototype.unshift() Function.prototype.apply() （完）]]></content>
      <categories>
        <category>javascript</category>
        <category>试题</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>数组</tag>
        <tag>试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[map 与 forEach 简单比较]]></title>
    <url>%2F2017%2F09%2F04%2Fmap-%E4%B8%8E-forEach-%E7%AE%80%E5%8D%95%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[map 与 forEach 简单比较 参考资料：MDN文档：Array.prototype.forEach()MDN文档：Array.prototype.map() 结论先写结论： forEach 不会产生新数组，返回值 undefined map 会返回一个新数组，不对原数组产生影响 map 因为返回新数组，所以可以链式操作（可操作性强） 速度 forEach &gt; map &gt; for（网上有说map &gt; forEach 然而测试结果并不是） 一、Array.prototype.forEach()forEach() 方法对数组的每个元素执行一次提供的函数。 语法：12345array.forEach(callback(currentValue, index, array)&#123; //do something&#125;, this)array.forEach(callback[, thisArg]) 参数： callback为数组中每个元素执行的函数，该函数接收三个参数： currentValue(当前值)数组中正在处理的当前元素。 index(索引)数组中正在处理的当前元素的索引。 arrayforEach()方法正在操作的数组。 thisArg可选可选参数。当执行回调 函数时用作this的值(参考对象)。 返回值undefined. 使用： 示例1：注意 callback 和 返回值1234567const arr = [1,2,3,"a","b","c"]let _arr = arr.forEach((e,i,arr)=&gt;&#123; console.log(e) // 1, 2, 3, "a","b","c" console.log(i) // 0, 1, 2, 3, 4, 5 console.log(arr) // 输出6次 [1, 2, 3, "a", "b", "c"]&#125;)console.log(_arr) // undefined 1、对数组的每一项都调用一次 callback 回调函数；2、总是返回值 undefined 示例2：可选参数 thisArg12345678910111213141516171819class Calculate&#123; constructor(x,y)&#123; this.x = 0; this.y = 0; &#125; sum(array)&#123; array.forEach(function(e)&#123; this.x += e; ++this.y; &#125;,this) console.log(this); // 指向该构造函数 &#125;&#125;const obj = new Calculate();obj.sum([1,2,3,4]);console.log(obj.x) // 10console.log(obj.y) // 4 1、thisArg 参数 (this) 传给了forEach()2、每次调用时，它都被传给 callback 函数，作为它的this值 示例3：forEach() 不会在迭代之前创建数组的副本1234567const words = ["one","two","three","four"];words.forEach((word)=&gt;&#123; console.log(word); // "one","two","four" if(word === "two")&#123; words.shift(); // "two"输出完后删除了第一项，索引改变 &#125;&#125;) 遍历 two 后，整个数组的第一个项被移除了，导致所有剩余项索引 -1，而下一次执行回调遍历的那一项索引依旧 +1，所以three被跳过了。 Array.prototype.map()map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 语法：123let array = arr.map(function callback(currentValue, index, array) &#123; // Return element for new_array&#125;[, thisArg]) 参数： callback生成新数组元素的函数，使用三个参数： currentValuecallback 的第一个参数，数组中正在处理的当前元素。 indexcallback 的第二个参数，数组中正在处理的当前元素的索引。 arraycallback 的第三个参数，map 方法被调用的数组。 thisArg可选的。执行 callback 函数时 使用的this 值。 返回值（与 forEach 最大的不同点）一个新数组，每个元素都是回调函数的结果。 使用： 示例1：map 方法返回处理后的数组，不修改原数组123const numbers = [1, 4, 9];let roots = numbers.map(Math.sqrt);// roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9] 示例2：格式化数组中的对象1234567891011const kvArray = [&#123;key: 1, value: 10&#125;, &#123;key: 2, value: 20&#125;, &#123;key: 3, value: 30&#125;];let reformattedArray = kvArray.map(function(obj) &#123; let rObj = &#123;&#125;; rObj[obj.key] = obj.value; return rObj;&#125;);// reformattedArray = [&#123;key: 1, value: 10&#125;, &#123;key: 2, value: 20&#125;, &#123;key: 3, value: 30&#125;]; 示例3：在类数组集合上调用，利用 call 改变 this 指向1234const oLis = document.querySelectorAll("ul li");let arrOlis = Array.prototype.map.call(oLis，function(e)&#123; return e.value;&#125;) 示例4：反转字符串，原理同上（示例3）；链式调用（返回新数组）123456const str = "12345";let _str = Array.prototype.map.call(str,x=&gt;&#123; return x;&#125;).reverse().join("");// _str = "54321";// str = "12345"; 性能对比123456789101112131415161718192021let arr1 = [];for(let i=0; i&lt;50000; i++)&#123; arr1.push(i)&#125;const start = Date.now()// forEach ==&gt; 2ms ~ 3ms// let arr2 = [];// arr1.forEach((e)=&gt;arr2.push(e*2))// map ==&gt; 10ms ~ 13ms// let arr2 = arr1.map(e=&gt;return e*2)// for ==&gt; 20ms ~ 26ms// let arr2 = [];// for(let i = 0;i&lt;arr1.length;i++)&#123;// arr2[i] = arr1[1]// &#125;const end = Date.now()console.log(end-start) 通过以上的代码测试，速度方面 forEach &gt; map &gt; for 但是 由于前端处理数据的局限性，速度并不是我们实际使用考虑的因素，实际情况是： 代码量：map &gt; forEach &gt; for 代码量：map &gt; forEach &gt; for 代码量：map &gt; forEach &gt; for 综上，如果出于 代码量 和 链式调用 的需求，用 map 可能会更好一些。 （完）]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试题：数组、递归]]></title>
    <url>%2F2017%2F08%2F30%2F%E8%AF%95%E9%A2%98%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[试题：数组、递归题干：实现一个 flatten 函数，将一个嵌套多层的数组 array (嵌套可以是任何层数) 转换为只有一层的数组。 1234567// 数组中元素仅基本类型的元素或数组，不存在循环引用的情况。var arr = [1, [2], [3, [[4]]]];/* 在这里定义你的 flatten 函数 */var _arr = flatten(arr);console.log(_arr); // 输出 [1,2,3,4] 审题：先看一眼题目给出的这个 arr ，按照题意的说法，这就是给你一个数组，数组内包含 基本类型元素 和 嵌套了任意层数的数组 ，然后注意这个数组 不存在循环引用的情况 也就是说嵌套数组中也只有基本类型元素或数组，这就简单多啦，我们只需要把所有数组中的基本类型元素提取出来，然后放进一个新数组就可以咯~ 首先，写代码遵循一个 DRY 的基本准则： Don&#39;t Repeat Yourself；然后，这种有规律、层级多、需要重复调用的，第一反应就是 递归 嘛，那接下来就用递归思想写一个 flatten 函数。 这是我们要操作的数组： 1arr = [1, [2], [3, [[4]]]] 然后这是 flatten 函数大概要做的事情： 次数 — — — 第一次 数字 1 数组 [2] 数组 [3,[[4]]] 第二次 数字 2 数字 3 数组 [[4]] 第三次 数组 [4] 第四次 数字 4 做题emmmmm . . . 下面是我能想到的方法，实现方式有很多，大家可以自由发挥。 方法一：Array.prototype.reduce() + Array.isArray() + Array.prototype.concat() 文档链接：Array.prototype.reduce() 文档链接：Array.isArray() 文档链接：Array.prototype.concat() 1234567891011121314function flatten(arr) &#123; return arr.reduce(function (initArr, currentArr) &#123; return initArr.concat(Array.isArray(currentArr) ? flatten1(currentArr) : currentArr); &#125;, [])&#125;var arr = [1, [2], [3, [[4]]]]var arr1 = [-1, [0, 1], ["String", [[[undefined, null]], true, false]]]var _arr = flatten(arr)console.log(_arr) // [ 1, 2, 3, 4 ]var _arr1 = flatten(arr1)console.log(_arr1) // [ -1, 0, 1, 'String', undefined, null, true, false ] 方法二：Array.prototype.forEach() + 闭包 + Array.prototype.push() 文档：Array.prototype.forEach() 文档：Array.prototype.push() 闭包：来自《JavaScript 标准参考教程（alpha）》，by 阮一峰 12345678910111213141516171819202122232425function flatten(arr) &#123; // 定义一个空数组用来存放提取出来的基本类型元素 var _arr = []; // 用一个自执行函数处理多层嵌套数组 (function _flatten(arr) &#123; arr.forEach(function (e, i) &#123; if (e instanceof Array) &#123; // 当然也可以写成其他形式，比如：if(typeof e === 'object') _flatten(e); &#125; else &#123; _arr.push(e); &#125; &#125;); &#125;)(arr); return _arr;&#125;var arr = [1, [2], [3, [[4]]]]var arr1 = [-1, [0, 1], ["String", [[[undefined, null]], true, false]]]var _arr = flatten(arr)console.log(_arr) // [ 1, 2, 3, 4 ]var _arr1 = flatten(arr1)console.log(_arr1) // [ -1, 0, 1, 'String', undefined, null, true, false ] 总结好了，以上就是我大概的想法，希望大家思考更多其他的方法实现。 最后，要注意的是： 不要为了做题而做题！ 那么，做题能干嘛呢？ 做题能检查自己知识点的掌握情况； 做题能够快速学习不熟悉的 API ； 做题能够整理巩固已掌握的知识点； 不信？你看这篇文章，如果你把我列出的代码跟文档读过一遍，你可能学习/复习了以下知识点： 递归思想 Array.prototype.reduce() Array.isArray() Array.prototype.concat() Array.prototype.forEach() Array.prototype.push() instanceof 、typeof 闭包 （完）]]></content>
      <categories>
        <category>javascript</category>
        <category>试题</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>数组</tag>
        <tag>递归</tag>
        <tag>试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数声明、函数表达式、匿名函数]]></title>
    <url>%2F2017%2F08%2F29%2F%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E3%80%81%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数声明、函数表达式、匿名函数 本文内容为函数基础，欢迎全段位玩家划水吐槽(^▽^) 一、函数声明、函数表达式的区别 函数声明：function functionName(){} 函数表达式：var fn = function(){} 匿名函数：function(){} 区别：函数声明与函数表达式的区别主要表现在声明前置与函数标识符两部分。 :—: 声明前置 标识符（函数名） 函数声明 函数声明前置 不可省略 函数表达式 变量声明前置 可以省略 匿名函数 无 无 示例： 函数声明不可省略标识符，否则抛出 error SyntaxError 错误，通过 foo 调用； 函数表达式省略了函数标识符，通过 fn 调用 12345678910111213141516// 判断声明前置console.log(foo) // function foo()&#123;console.log('foo: "函数声明"')&#125;console.log(fn) // undefined// 函数声明function foo()&#123;console.log('foo: "函数声明"')&#125;// 函数表达式 var fn = function()&#123;console.log('fn: "函数表达式"')&#125;// 函数表达式声明后打印console.log(fn) // function ()&#123;console.log('fn: "函数表达式"')&#125;// 调用foo() // foo: "函数声明"fn() // fn: "函数表达式" 二、变量的声明前置、函数的声明前置变量的声明前置： 在一个作用域块中，所有的变量声明都会被JS引擎放在作用域块范围的顶部进行； 函数的声明前置： 和变量声明前置一样，执行代码之前会先读取函数声明，只要函数在代码中进行了声明，无论它在作用域块的哪个位置上进行声明，JS引擎都会将它的声明放在作用域块范围的顶部进行； 优先级： 函数声明的优先级高于变量声明的优先级（函数声明 &gt; 变量声明） 示例：利用同名 函数/变量 判断 声明前置的优先级123456789101112131415// 判断声明优先级console.log(foo) // function foo()&#123;console.log("foo")&#125;console.log(fn) // function fn()&#123;console.log("fn")&#125;// 声明：函数 ==&gt; 变量function foo()&#123;console.log("foo")&#125;var foo = 1;// 声明：变量 ==&gt; 函数var fn =2;function fn()&#123;console.log("fn")&#125;// 赋值后打印console.log(foo) // 1console.log(fn) // 2 以上代码正确的执行顺序是：12345678910111213// 因为函数声明优先提升，所以后提升的变量声明把函数声明挤到了后面var foo;var fn;function foo()&#123;console.log("foo")&#125;function fn()&#123;console.log("fn")&#125;// 然后JS引擎从上到下解释运行，后面的函数声明会覆盖掉前面的变量声明console.log(foo) // function foo()&#123;console.log("foo")&#125;console.log(fn) // function fn()&#123;console.log("fn")&#125;foo = 1;fn = 2;console.log(foo) // 1console.log(fn) // 2 三、匿名函数匿名函数在 javascript 中广泛用于赋值、传参、构建闭包等操作。 函数表达式啊咧咧？函数表达式怎么跑这里来了？？？ 没错，函数表达式就是匿名函数的一种应用。 不信你看函数表达式右边，这就是一个把匿名函数赋值给一个变量的过程。12var foo = function()&#123;console.log(1)&#125;foo() // 1 构建闭包闭包是 javascript 最强大的特性之一。它的最大用处有两个，一个是可以读取其他函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 示例：这里只将闭包作为匿名函数的应用示例，并不展开讨论闭包。1234567891011var a = 1000;function foo()&#123; var a = 1; return function()&#123; //匿名函数 a = a + 1; console.log(a) &#125;&#125;var fn = foo()fn() // 2fn() // 3 立即执行函数表达式（IIFE）这是一个写在任何地方都不会抛出 Uncaught SyntaxError 错误的匿名函数 立即执行函数表达式（Immediately-Invoked Function Expression），简称IIFE。表示定义函数之后，立即调用该函数。 作用：隔离作用域，保护私有变量，防止污染全局变量 最常用的两种写法：1(function()&#123; /* code */ &#125;()); 1(function()&#123; /* code */ &#125;)(); 示例：定义之后立即调用1(function(a)&#123;console.log(a)&#125;)(10) // 10 参考：（译）详解javascript立即执行函数表达式（IIFE） ##抛出错误 如果匿名函数直接写成以下形式会抛出 Uncaught SyntaxError 错误，不过相信你也不会这样写，毕竟这样写的话你就没有办法调用它了QAQ1function（）&#123;/*code*/&#125; // Uncaught SyntaxError: （完）]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>闭包</tag>
        <tag>声明前置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试题：作用域链+闭包]]></title>
    <url>%2F2017%2F08%2F29%2F%E8%AF%95%E9%A2%98%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[试题：作用域链 + 闭包在开始阅读本文之前，你可能需要了解包括且不限于以下知识点，否则极有可能会浪费您宝贵的时间。 闭包 作用域 执行上下文 this 自执行函数 伪代码声明本文没有用中文汉字解释每一行代码执行做了哪些事情，但是有很详细的伪代码作为参考，虽然略为繁琐，但如果你将它整理成自己的思路，以后遇到类似的问题就能迅速思考得出答案。 约定： Context 执行上下文 AO 活动对象 Scope 作用域链 先来一道开胃菜，至少可以让我们大概知道每一行伪代码说明了什么。 开胃菜：1234567891011var x = 10bar()function foo() &#123; console.log(x)&#125;function bar()&#123; var x = 30 foo() // 输出什么&#125; 注意： 调用函数的时候，先从该函数体内查找所需的变量，如果没有，再从函数定义的那个作用域查找所需变量。以此类推，直到顶层作用域，如果依旧没有，输出 undefined 以下是我的伪代码规则：伪代码：1234567891011121314151617181920212223242526272829303132333435363738394041/* * 执行上下文 * globalContext = &#123; * 活动对象 * AO: &#123; * x: 10 * foo: function * bar: function * &#125;, * 作用域链 * Scope: null * &#125; * * 声明 foo 时 得到下面 * foo.[[scope]] = globalContext.AO * * 声明 bar 时 得到下面 * bar.[[scope]] = globalContext.AO * * 注意： 在当前的执行上下文内声明的函数，这个函数的[[scope]]就指向当前执行上下文的 AO * * 当调用 bar() 时， 进入 bar 的执行上下文 * * barContext = &#123; * AO: &#123; * x: 30 * &#125;, * Scope: bar.[[scope]] //globalContext.AO * &#125; * * 当调用 foo() 时，先从 bar 执行上下文中的 AO里找foo函数，找不到再从 bar 的 [[scope]]里找找到后即调用 * * 当调用 foo() 时，进入 foo 的执行上下文 * * fooContext = &#123; * AO: &#123;&#125;, * Scope: foo.[[scope]] // globalContext.AO * &#125; * * 所以最后在console中输出 10 * */ ok，开胃菜没有任何难度，接下来上正餐咯 (*^▽^*) 主菜一：123456789101112131415161718var num = 7;var obj = &#123; num: 8, fn: (function () &#123; this.num *= 2; num += 3; num = 6; return function () &#123; this.num *= 5; num += 6; console.log(num); &#125; &#125;)(num)&#125;var fn = obj.fn;fn();obj.fn();console.log(window.num, obj.num); 如需文字说明，请留言注明。以下是每一步操作的伪代码，希望诸君在思考过后再参考：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* * 1. 栈底 ==&gt; 全局上下文 * 执行上下文 * globalContext=&#123; * 活动对象 * AO: &#123; * num: 7, * obj: &#123;&#125;, * (function()&#123;&#125;)(): function, * fn: obj.fn, * fn(): function, * obj.fn(): function * &#125; * 作用域链 * scope: none * &#125; * 通过以上伪代码可以得出以下的作用域链 * (function()&#123;&#125;)().[[scope]] = globalContext.AO * fn().[[scope]] = globalContext.AO * obj.fn().[[scope]] = globalContext.AO * * 2. 自执行函数 * (function()&#123;&#125;)()Context=&#123; * AO: &#123; * (globalContext.AO.num: 14 ==&gt; 17 ==&gt; 6) * (return function(): function) * &#125; * scope: globalContext.AO * &#125; * * 3. fn() * fnContext = &#123; * AO: &#123; * num: 30 ==&gt; 36 * &#125; * scope: globalContext.AO * &#125; * * 4. obj.fn() * step1: * objContext = &#123; * AO: &#123; * num: 8, * fn: function * &#125; * scope: globalContext.AO * &#125; * fn.[[scope]] = objContext.AO * * step2: * obj.fn Context=&#123; * AO: &#123; * (objContext.AO.num: 40) * (globalContext.AO.num: 42) * &#125; * scope: objContext.AO * &#125; * * */ 主菜二：123456789101112131415161718var num = 20;var obj = &#123; num: 30, fn: (function (num) &#123; num += 15; var num = 45; return function () &#123; this.num *= 4; num += 20; console.log(num); &#125; &#125;)(num)&#125;var fn = obj.fn;fn();obj.fn();console.log(window.num, obj.num); 如需文字说明，请留言注明。以下是每一步操作的伪代码，希望诸君在思考过后再参考：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * 1. 栈底 ==&gt; globalContext * globalContext=&#123; * AO: &#123; * num: 20, * obj: &#123;&#125;, * (function()&#123;&#125;)(), * fn: obj.fn, * fn(): function, * obj.fn(): function * &#125; * scope: none * &#125; * (function()&#123;&#125;)().[[scope]] = globalContext.AO * fn().[[scope]] = globalContext.AO * obj.fn().[[scope]] = globalContext.AO * * 2. (function()&#123;&#125;()) * (function()&#123;&#125;())Context = &#123; * AO: &#123; * num: 45 * (return function(): function) * &#125; * scope: globalContext.AO * &#125; * * 3. fn() * fnContext = &#123; * AO: &#123; * (globalContext.AO.num: 80) * ((function()&#123;&#125;()).AO.num: 45 ==&gt; 65) * num: 65 * &#125; * scope: globalContext.AO * &#125; * * 4. obj.fn() * step1: * objContext = &#123; * AO: &#123; * num: 30, * fn: function * &#125; * scope: globalContext.AO * &#125; * fn.[[scope]] = objContext * * step2: * obj.fn()Context = &#123; * AO: &#123; * (objContext.AO.num: 120) * ((function()&#123;&#125;()).AO.num: 65 ==&gt; 85) * num: 85 * &#125; * scope: objContext.AO * &#125; * * */ 本文示例中的伪代码全为个人喜好，没有标准规范，诸君可为自身喜好量身定制，直到自己用的 [ 爽 ] 为止。 另外，诚如本文一开始所说的那样，虽然书写出伪代码能够得出一个精确的答案，但过程比较繁琐，所以应尽量把伪代码变成自己的思路，这样才在实际操作中迅速找到问题所在，解决问题。 （完）]]></content>
      <categories>
        <category>javascript</category>
        <category>试题</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>闭包</tag>
        <tag>试题</tag>
        <tag>作用域</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leanCloud存储数据]]></title>
    <url>%2F2017%2F08%2F29%2FleanCloud%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据存储</category>
      </categories>
      <tags>
        <tag>leanCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 生命周期（Lifecycle）]]></title>
    <url>%2F2017%2F08%2F27%2FReact-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[React 生命周期（Lifecycle）参考：The Component Lifecycle React 的生命周期包括三个阶段：1231. mount（挂载）2. update（更新）3. unmount（移除） mountmount 就是第一次让组件出现在页面中的过程。这个过程的关键就是 render 方法。React 会将 render 的返回值（一般是虚拟 DOM，也可以是 DOM 或者 null）插入到页面中。 这个过程会暴露几个钩子（hook）方便你往里面加代码： 12341. constructor()2. componentWillMount()3. render()4. componentDidMount() updatemount 之后，如果数据有任何变动，就会来到 update 过程，这个过程有 5 个钩子： 1234567891011121314// - 我要读取 props 啦！componentWillReceiveProps(nextProps)// - 请问要不要更新组件？true / falseshouldComponentUpdate(nextProps, nextState) // - 我要更新组件啦！componentWillUpdate() // - 更新！render() // - 更新完毕啦！componentDidUpdate() unmount当一个组件将要从页面中移除时，会进入 unmount 过程，这个过程就一个钩子： 12// - 我要死啦！componentWillUnmount() 你可以在这个组件死之前做一些清理工作。 总结一般情况下只在这几个钩子里 setState：1234componentWillMount()componentDidMount()componentWillReceiveProps(nextProps, nextState) componentDidUpdate() 参考：React lifecycle cheatsheet]]></content>
      <categories>
        <category>javascript</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 基础入门实例]]></title>
    <url>%2F2017%2F08%2F25%2FReact-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[react 基本语法一、ReactDOM.render()ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 1234ReactDOM.render( &lt;h1&gt;Hello React&lt;/h1&gt;, document.getElementById("example")) 二、JSX 语法HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写. JSX 的基本语法规则： 遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析； 遇到 代码块 （以 { 开头），就用 JavaScript 规则解析。 1234567891011121314var names = ['傻龙', '大鳖', '大宝', '煜神'];ReactDOM.render( &lt;div&gt; &#123; // map会返回一个新数组，不对原数组产生影响,foreach不会产生新数组， // map因为返回数组所以可以链式操作，foreach不能 names.map(function (name, index) &#123; return &lt;div key=&#123;index&#125;&gt;Hello &#123;name&#125;&lt;/div&gt; &#125;) &#125; &lt;/div&gt;, document.getElementById('example')) JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员，添加到模板， 123456789var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;,];ReactDOM.render( //如果这个变量是一个数组，JSX 会把它的所有成员，添加到模板 &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById(&apos;example&apos;)); 三、组件React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。 React.createClass() 方法就用于生成一个组件类 123456789101112131415var HelloMessage = React.createClass(&#123; render: function () &#123; return ( //class 跟 for 是js的保留字，所以使用规则如下： &lt;div className="thisIsClass" htmlFor='thisIsFor'&gt; &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;)ReactDOM.render( &lt;HelloMessage name="Albert"/&gt;, document.getElementById("example")) 上面代码中，变量 HelloMessage 就是一个组件类。模板插入 &lt;HelloMessage /&gt; 时，会自动生生成 HelloMessage 的一个实例。 所有组件类都必须有自己的 render 方法，用于输出组件。 注意，组件类的第一个字母必须大写，否则会报错，比如HelloMessage不能写成helloMessage。 另外，组件类只能包含一个顶层标签，否则也会报错。 组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 &lt;HelloMessage name=&quot;Albert&quot;&gt; ，就是 HelloMessage 组件加入一个 name 属性，值为 Albert。 组件的属性可以在组件类的 this.props 对象上获取，比如 name 属性就可以通过 this.props.name 读取。 因为 class 和 for 是 JavaScript 的保留字，所以添加组件属性时，有一个地方需要注意： class 属性需要写成 className ； for 属性需要写成 htmlFor ； 四、this.props.childrenthis.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点。 1234567891011121314151617181920212223var NotesList = React.createClass(&#123; render: function () &#123; return ( &lt;ol&gt; &#123; //this.props.children 表示组件的所有子节点 React.Children.map(this.props.children, function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ol&gt; ); &#125;&#125;);ReactDOM.render( &lt;NotesList&gt; &#123;/*以下就是组件的两个子节点*/&#125; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.getElementById('example')); 上面代码的 NoteList 组件有两个 span 子节点，它们都可以通过 this.props.children 读取 这里需要注意， this.props.children 的值有三种可能： 如果当前组件没有子节点，它就是 undefined ; 如果有一个子节点，数据类型是 object ； 如果有多个子节点，数据类型就是 array ； 但是 ，好在 React 提供一个工具方法 React.Children 来处理 this.props.children 。 我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。 更多的 React.Children 的方法，请参考官方文档。 五、PropTypes组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。 组件类的 PropTypes 属性，就是用来验证组件实例的属性是否符合要求。 12345678910111213141516171819202122232425// 如果把引号去掉就是数值类型，就会报错var data = "string!";var MyTitle = React.createClass(&#123; PropTypes: &#123; //通过 React.PropTypes 规定 title 接受值的类型 title: React.PropTypes.string.isRequired &#125;, //设置组件属性的默认值 getDefaultProps: function () &#123; return &#123; title: "hello world" &#125; &#125;, render: function () &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;MyTitle title=&#123;data&#125;/&gt;, document.getElementById('example')); 上面的 Mytitle 组件有一个 title 属性。PropTypes 告诉 React，这个 title 属性是必须的，而且它的值必须是字符串。 此外，getDefaultProps 方法可以用来设置组件属性的默认值。 六、获取真实的DOM节点组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。 但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性 12345678910111213141516171819202122var Component = React.createClass(&#123; handleClick: function () &#123; //this.refs.[refName].[handler] this.refs.refName.focus() &#125;, render: function () &#123; return ( &lt;div&gt; &#123;/* ref：为了从组件获取真实 DOM 节点 */&#125; &lt;input type="text" ref="refName" /&gt; &lt;input type="button" value="focus the text input" onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ) &#125;&#125;);ReactDOM.render( &lt;Component /&gt;, document.getElementById("example")) Component 组件中的输入框用于获取用户的输入，这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。 需要注意的是，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 Click 事件的回调函数，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性。 七、this.state组件免不了要与用户互动，React 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI 123456789101112131415161718192021var LikeButton = React.createClass(&#123; getInitialState: function () &#123; return &#123;liked: false&#125; &#125;, handleClick: function () &#123; this.setState(&#123;liked: !this.state.liked&#125;) &#125;, render: function () &#123; var text = this.state.liked ? "like" : "haven\'t liked"; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ) &#125;&#125;)ReactDOM.render( &lt;LikeButton/&gt;, document.getElementById('example')); 上面代码是一个 LikeButton 组件，它的 getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。 当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。 由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。 八、表单用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取。 1234567891011121314151617181920212223242526var Input = React.createClass(&#123; //初始化 this.state getInitialState: function () &#123; return &#123;value: "init"&#125; &#125;, //setState 改变 this.state 的值 //event.target.value 读取表单值 handleChange: function (event) &#123; this.setState(&#123;value: event.target.value&#125;) &#125;, render: function () &#123; var value = this.state.value; return ( &lt;div&gt; &#123;/*回调函数触发*/&#125; &lt;input type="text" value=&#123;value&#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;)ReactDOM.render( &lt;Input/&gt;, document.getElementById('example')); 上面代码中，文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。 textarea 元素、select元素、radio元素都属于这种情况，更多介绍请参考官方文档。 九、组件的生命周期组件的生命周期分成三个状态：123- Mounting：已插入真实 DOM- Updating：正在被重新渲染- Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。1234567- componentWillMount()- componentDidMount()- componentWillUpdate(object nextProps, object nextState)- componentDidUpdate(object prevProps, object prevState)- componentWillUnmount() 此外，React 还提供两种特殊状态的处理函数。 123- componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用- shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 这些方法的详细说明，可以参[考官方文档]。(http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods) 123456789101112131415161718192021222324252627282930313233var Hello = React.createClass(&#123; getInitialState: function () &#123; return &#123; opacity: 1 &#125;; &#125;, //插入真实 DOM 之后调用 componentDidMount: function () &#123; this.timer = setInterval(function () &#123; var opacity = this.state.opacity; opacity -= .05; if (opacity &lt; .1) &#123; opacity = 1; &#125; this.setState(&#123; opacity: opacity &#125;); //bind(this) 绑定自定义函数的 this &#125;.bind(this), 100) &#125;, render: function () &#123; return ( &lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt; Hello &#123;this.props.name&#125; &lt;/div&gt; ); &#125;,&#125;);ReactDOM.render( &lt;Hello name="World"/&gt;, document.getElementById("example")) 上面代码在Hello组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。 另外，组件的style属性的设置方式也值得注意，不能写成1style="opacity:&#123;this.state.opacity&#125;;" 而要写成1style=&#123;&#123;opacity: this.state.opacity&#125;&#125; 这是因为 React 组件样式 一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。 十、Ajax组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 componentDidMount 方法设置 Ajax 请求，等到请求成功，再用 this.setState 方法重新渲染 UI 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 定义一个 RepoList 组件var RepoList = React.createClass(&#123; // 初始化 this.state getInitialState: function () &#123; return &#123; loading: true, error: null, data: null &#125;; &#125;, // 组件添加到真实 DOM 后调用 componentDidMount() &#123; // 定义一个 promise this.props.promise.then( // promise 延时成功 value =&gt; &#123; // 改变 loading 状态，data 数据 this.setState(&#123;loading: false, data: value&#125;) &#125;, // promise 延时失败 改变 loading 状态，error 数据 error =&gt; this.setState(&#123;loading: false, error: error&#125;)); &#125;, // 渲染函数 render: function () &#123; // promise pending ... if (this.state.loading) &#123; return &lt;span&gt;Loading...&lt;/span&gt;; &#125; // promise reject! else if (this.state.error !== null) &#123; return &lt;span&gt;Error: &#123;this.state.error.message&#125;&lt;/span&gt;; &#125; else &#123; // 成功请求到数据，添加到变量和标签中 var repos = this.state.data.items; // 遍历 ajax 请求存储好的数据 var repoList = repos.map(function (repo, index) &#123; // 循环创建jsx html 标签，返回保存到repoList return ( &lt;li key=&#123;index&#125;&gt;&lt;a href=&#123;repo.html_url&#125;&gt;&#123;repo.name&#125;&lt;/a&gt; (&#123;repo.stargazers_count&#125; stars) &lt;br/&gt; &#123;repo.description&#125;&lt;/li&gt; ); &#125;); // 返回 创建 jsx html 标签并将 repolist 添加进去 return ( &lt;main&gt; &lt;h1&gt;Most Popular JavaScript Projects in Github&lt;/h1&gt; &lt;ol&gt;&#123;repoList&#125;&lt;/ol&gt; &lt;/main&gt; ); &#125; &#125;&#125;);// 插入 DOMReactDOM.render( // AJAX 请求数据 &lt;RepoList promise=&#123;$.getJSON('https://api.github.com/search/repositories?q=javascript&amp;sort=stars')&#125;/&gt;, document.getElementById('example')); 如果Promise对象正在抓取数据（pending状态），组件显示”正在加载”；如果Promise对象报错（rejected状态），组件显示报错信息；如果Promise对象抓取数据成功（fulfilled状态），组件显示获取的数据。 参考：React 入门实例教程]]></content>
      <categories>
        <category>javascript</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Albert's Favorites]]></title>
    <url>%2F2017%2F08%2F25%2FAlbert-s-Favorites%2F</url>
    <content type="text"><![CDATA[CSS Flex 布局教程：语法篇-阮一峰 Flex 布局教程：实例篇-阮一峰 张鑫旭的个人博客 大漠的个人博客w3cplus JS JavaScript 标准参考教程（alpha）-阮一峰 ECMAScript 6 入门-阮一峰 JavaScript秘密花园 ES 5 新增特性汇总 JavaScript Promise迷你书（中文版） 【翻译】Promises/A+规范 React facebook：官方文档 FCC：中文翻译 极客学院：中文翻译 知乎：setState：这个API设计到底怎么样 阮一峰：React 技术栈系列教程 知乎：从零学习React技术栈 React China 掘金：React 开源项目合集整理 博文你真的会使用XMLHttpRequest吗？ webpack：从入门到真实项目配置]]></content>
      <categories>
        <category>收藏夹</category>
      </categories>
      <tags>
        <tag>收藏夹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用CSS3实现一个立方体]]></title>
    <url>%2F2017%2F08%2F25%2F%E7%94%A8CSS3%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AB%8B%E6%96%B9%E4%BD%93%2F</url>
    <content type="text"></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详说 Cookie, LocalStorage 与 SessionStorage]]></title>
    <url>%2F2017%2F08%2F24%2F%E8%AF%A6%E8%AF%B4-Cookie-LocalStorage-%E4%B8%8E-SessionStorage%2F</url>
    <content type="text"><![CDATA[Cookie, LocalStorage 与 SessionStorage具体 Web Storage API 的使用可以参考 MDN的文档 基本概念CookieCookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。 localStoragelocalStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。 特性 Chrome Firefox (Gecko) Internet Explorer Opera Safari (WebKit) localStorage 4 3.5 8 10.50 4 sessionStorage 5 2 8 10.50 4 sessionStoragesessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。 三者的异同 特性 Cookie localStorage sessionStorage 数据的生命期 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 一般为5MB &lt;= 同localStorage 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 &lt;= 同localStorage 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 &lt;= 同localStorage 应用场景有了对上面这些差别的直观理解，我们就可以讨论三者的应用场景了。 因为考虑到每个 HTTP 请求都会带着 Cookie 的信息，所以 Cookie 当然是能精简就精简啦，比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。曾经还使用 Cookie 来保存用户在电商网站的购物车信息，如今有了 localStorage，似乎在这个方面也可以给 Cookie 放个假了~ 而另一方面 localStorage 接替了 Cookie 管理购物车的工作，同时也能胜任其他一些工作。比如HTML5游戏通常会产生一些本地数据，localStorage 也是非常适用的。如果遇到一些内容特别多的表单，为了优化用户体验，我们可能要把表单页面拆分成多个子页面，然后按步骤引导用户填写。这时候 sessionStorage 的作用就发挥出来了。 安全性的考虑需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为。所以千万不要用它们存储你系统中的敏感数据。 参考资料 what is the difference between localStorage, sessionStorage, session and cookie? HTML5 localStorage security 维基百科 - Cookie Web Storage API 浏览器本地数据（sessionStorage、localStorage、cookie）与server端数据 HTMl5的sessionStorage和localStorage HTML5 LocalStorage 本地存储 转自：详说 Cookie, LocalStorage 与 SessionStorage]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[低版本IE支持HTML5]]></title>
    <url>%2F2017%2F08%2F24%2F%E4%BD%8E%E7%89%88%E6%9C%ACIE%E6%94%AF%E6%8C%81HTML5%2F</url>
    <content type="text"><![CDATA[如何让低版本的 IE 支持 HTML5新标签1. 利用条件注释针对 IE 来调用这个 JS 文件。Opera，FireFox 等其他非 IE 浏览器就会忽视这段代码，也不会存在 http 请求。引用 html5shiv.js 文件，代码内容可以自己下载下来看。 BootCDN-html5shiv 123&lt;!--[if lt IE 9]&gt; &lt;script src="bower_components/html5shiv/dist/html5shiv.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 将以上代码放到 head 标签区间，由于现在国内网络环境（你懂的QAQ），直接引入外部 JS会让网页打开非常慢，所以建议大家先下载到服务器上，再进行本地文件的引用。 更多细节参考：The HTML5 Shiv 2. 用JS创建元素，然后添加CSS属性：1234567// 页面头部(function () &#123; var a = ['article', 'aside', 'details', 'figcaption', 'figure', 'footer', 'header', 'hgroup', 'nav', 'section']; for (var i = 0, j = a.length; i &lt; j; i++) &#123; document.createElement(a[i]); &#125;&#125;)(); 同理，可以用类数组转为数组： 12345678910111213// 页面头部function createHtml5Mark() &#123; // arguments 序列化成数组 var args = Array.prototype.slice.call(arguments, 0); argLen = args.length, doc = document; // 循环数据创建元素 for (var i = 0; i &lt; argLen; i++) &#123; doc.createElement(args[i]); &#125;&#125;createHtml5Mark('article', 'aside', 'details', 'figcaption', 'figure', 'footer', 'header', 'hgroup', 'nav', 'section'); 最后，需要在CSS添加属性： 1section,article,nav,header,footer&#123;display:block;&#125; （完）]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>IE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5入坑简单概览]]></title>
    <url>%2F2017%2F08%2F24%2FHTML5%E5%85%A5%E5%9D%91%E7%AE%80%E5%8D%95%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[HTML5 概览 本文概览：HTML5 新特性；标签的变化；属性的变化；新增的标签 HTML5是什么？ HTML5是超文本标记语言的第五次重大修改，2014年10月29日标准规范制定完成。 设计目的 HTML5 的设计目的是为了在移动设备上支持多媒体。新的语法特征被引进以支持这一点，如 video 、audio 和 canvas 标记。 HTML5 还引进了新的功能，可以真正改变用户与文档的交互方式，包括： 新的解析规则增强了灵活性 新属性 淘汰过时的或冗余的属性 一个HTML5文档到另一个文档间的拖放功能 离线编辑 信息传递的增强 详细的解析规则 多用途互联网邮件扩展（MIME）和协议处理程序注册 在SQL数据库中存储数据的通用标准（Web SQL） 有哪些新特性？MDN-HTML5 1. 语义特性HTML5 赋予网页更好的意义和结构。更加丰富的标签将随着对 RDFa，微数据与微格式等方面的支持，构建对程序、对用户都更有价值的数据驱动的Web。 2. 本地存储特性基于 HTML5 开发的网页APP拥有更短的启动时间，更快的联网速度，这些全得益于 HTML5 APP Cache ，以及本地存储功能。Indexed DB（HTML5本地存储最重要的技术之一）和 API 说明文档。 3. 设备兼容特性从 Geolocation 功能的API文档公开以来，HTML5 为网页应用开发者们提供了更多功能上的优化选择，带来了更多体验功能的优势。HTML5 提供了前所未有的数据与应用接入开放接口。使外部应用可以直接与浏览器内部的数据直接相连，例如视频影音可直接与microphones及摄像头相联。 4. 连接特性更有效的连接工作效率，使得基于页面的实时聊天，更快速的网页游戏体验，更优化的在线交流得到了实现。HTML5 拥有更有效的服务器推送技术，Server-Sent Events 和 WebSocket 就是其中的两个特性，这两个特性能够帮助我们实现服务器将数据“推送”到客户端的功能。 5. 网页多媒体特性 支持网页端的 audio 、video 等多媒体功能。 三维、图形及特效特性（Class: 3D, Graphics &amp; Effects） 基于 SVG、Canvas、WebGL 及CSS3 的 3D 功能，用户会惊叹于在浏览器中，所呈现的惊人视觉效果。 6. 性能与集成特性没有用户会永远等待你的Loading —— HTML5会通过 XMLHttpRequest2 等技术，解决以前的跨域等问题，帮助您的Web应用和网站在多样化的环境中更快速的工作。 7. CSS3特性在不牺牲性能和语义结构的前提下，CSS3 中提供了更多的风格和更强的效果。此外，较之以前的Web排版，Web的开放字体格式（WOFF）也提供了更高的灵活性和控制性。 关于标签1. 标签变化 DOCTYPE 1&lt;!DOCTYPE html&gt; 文档编码 1&lt;meta charset=&quot;UTF-8&quot; /&gt; 标签结尾 在 HTML5 中对于一些标签不再是必要的：（但是建议每个标签都要结束）li , dt , dd , p , rt , rp , optgroup , option , colgroup , thead , tbody , tfoot , tr , td , th 自结束的标签最后的 / 也不再必要img , input , br , hr 等 2. 属性变化2.1 具有 boolean 值的属性对于具有 boolean 值的属性，例如 disable 和 readonly 等，只写属性不写属性值时，其默认值为 true1234&lt;!-- 以下三条 checked 全部为选中状态 --&gt;&lt;input type=&quot;checkbox&quot; checked &gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; &gt;&lt;input type=&quot;checkbox&quot; checked=&quot;&quot; &gt; 2.2 省略属性值的引号属性值可以用单引号或者双引号，在属性值不包括 &lt;、&gt;、=、&#39;、&quot;时可以忽略引号12&lt;!-- 这里的text就省略了引号 --&gt;&lt;input type=text &gt; 2.3 input 新增 type注意：日期与时间相关的 type 目前均存在bugMDN：HTML元素参考-input1234567891011121314151617181920&lt;!-- 提交表单会自动验证是否为邮箱、电话、URL --&gt;&lt;input type=&quot;email&quot;&gt;&lt;input type=&quot;tel&quot;&gt;&lt;input type=&quot;url&quot;&gt;&lt;!-- 非数字无法输入 --&gt;&lt;input type=&quot;number&quot;&gt;&lt;!-- 一个指示范围的横向滚动条 --&gt;&lt;input type=&quot;range&quot;&gt;&lt;!-- 搜索框 --&gt;&lt;input type=&quot;search&quot;&gt;&lt;!-- 日期与时间（不建议使用） --&gt;&lt;input type=&quot;date&quot;&gt;&lt;input type=&quot;month&quot;&gt;&lt;input type=&quot;week&quot;&gt;&lt;input type=&quot;time&quot;&gt;&lt;input type=&quot;datetime-local&quot;&gt; 2.4 移除的元素 能被CSS替代的元素basefont , big , center , font , s , u , tt ,strike 不再使用frame框架frame , frameset , noframes 其它rb =&gt; rubyacronym =&gt; abbrdir =&gt; ulisindex =&gt; inputlisting =&gt; prexmp =&gt; codenextid =&gt; CUIDSplaintext =&gt; text/plain 2.5 新增属性 全局属性contentEditable , designMode , hidden , spellcheck , tabindex 表单相关autofocus , placeholder , form , required , novalidateformaction , formenctype , formmethod , formtarget , formnovalidate 链接相关a和area新增medialink新增sizes属性base新增target属性area新增hreflang和rel 其它ol新增reversedmeta新增charsetmenu新增type和labelstyle新增scopedscript新增asynchtml新增manifestiframe新增sandbox， seamless， srcdoc 2.6 废弃属性废弃的元素和属性 3. 新增标签 元素 描述 canvas 标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API audio 定义音频内容 video 定义视频（video 或者 movie） source 定义多媒体资源 &lt;video&gt; 和&lt;audio&gt; embed 定义嵌入的内容，比如插件 track 为诸如 &lt;video&gt; 和 &lt;audio&gt; 元素之类的媒介规定外部文本轨道 datalist 定义选项列表。与 input 元素配合使用该元素，来定义 input 可能的值 keygen 规定用于表单的密钥对生成器字段 output 定义不同类型的输出，比如脚本的输出 article 定义页面正文内容 aside 定义页面内容之外的内容 bdi 设置一段文本，使其脱离其父元素的文本方向设置 command 定义命令按钮，比如单选按钮、复选框或按钮 details 用于描述文档或文档某个部分的细节 dialog 定义对话框，比如提示框 summary 标签包含 details 元素的标题 figure 规定独立的流内容（图像、图表、照片、代码等等） figcaption 定义 &lt;figure&gt; 元素的标题 footer 定义 section 或 document 的页脚 header 定义了文档的头部区域 mark 定义带有记号的文本 meter 定义度量衡。仅用于已知最大和最小值的度量 nav 导航 progress 定义任何类型的任务的进度 ruby 定义 ruby 注释（中文注音或字符） rt 定义字符（中文注音或字符）的解释或发音 rp 在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容 section 定义文档中的节（section、区段） time 定义日期或时间 wbr 规定在文本中的何处适合添加换行符 参考 w3school：HTML 参考手册 MDN：HTML5 MDN：HTML5 标签列表 HTML5 学习笔记简明版 知乎：HTML5 到底是什么？ （完）]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim常用基础命令整理]]></title>
    <url>%2F2017%2F08%2F22%2Fvim%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[@vim | center #vim常用基础命令整理 1.进入Vim 编辑器1vim 文件名 &lt;回车&gt; 2.退出 Vim 编辑器 放弃所有改动 1&lt;ESC&gt; :q! &lt;回车&gt; //q=Quit ; !=强制执行 ； 保存改动 1&lt;ESC&gt; :wq &lt;回车&gt; //w=Write ; q=Quit ; 3.删除光标所在位置的字符1x 4.在光标前插入文本1i 输入欲插入文本 &lt;ESC&gt; 5.在一行后插入文本1A 输入欲添加文本 &lt;ESC&gt; 6.从当前光标删除至下一个单词1dw //d=Delete ; w=Word ; 7.从当前光标删除至当前行末尾1d$ 8.删除整行1dd 9.重复一个动作1operator [number] motion 123operator - 操作符，代表要做的事情，比如 d 代表删除[number] - 可以附加的数字，代表动作重复的次数motion - 动作，代表在所操作的文本上的移动 1234例如 ：2w //从光标开始偏移2个单词d2w //从光标开始删除2个单词w 代表单词(word)，$ 代表行末等等。 10.移动光标到行首10 //数字0键 11.撤销相关123u //小写的u，撤消以前的操作U //大写的U，撤消在一行中所做的所有改动CTRL-R //撤消以前的撤消命令 12.要重新置入已经删除的文本内容1p //删除的内容留在寄存器中，把p想成paste 12该操作可以将已删除的文本内容置于光标之后。如删除的是一个整行，操作将置于当前光标所在行的下一行。 13.要替换光标所在位置的字符12r 新字符 // 替换单个字符R 新字符 &lt;ESC&gt; // 替换多个字符 14.更改命令c1c [number] motion // 参数同9. 15.定位及文件状态1234CTRL-G //显示当前光标所在行的位置以及文件状态信息数字 G //（这里G大写）直接跳转到文件中的某一指定行G //当前光标直接跳转到文件最后一行gg //当前光标直接跳转到文件第一行 16.搜索类命令1/ 要搜索的字符 &lt;回车&gt; //在当前文件中查找该字符串 12n //正向查找同上一次的字符N //向相反方向查找同上一次的字符 1? 要搜索的字符 &lt;回车&gt; //同N，反向查找字符 12:set ic //忽略大小写ignorecase:set noic //禁用忽略大小写 12:set hls is //设置 高亮显示所有的匹配短语hlsearch 和 查找短语时显示部分匹配incsearch 这两个选项，:nohlsearch //移除匹配项的高亮显示 12CTRL-O //字母o，回到之前的位置，重复可回退多步CTRL-I //跳转到较新的位置 17.配对括号的查找1% //在第一个括号处按下%，光标将跳转到闭合处，再次按下将回跳 18.替换命令1:s/字符1/字符2/g //将光标所在行中所有的 字符1 替换为 字符2 1:#,#s/old/new/g // #,# 代表的是替换操作的若干行中首尾两行的行号 1:%s/old/new/g //替换整个文件中的每个匹配字符old替换为字符new 1:%s/old/new/gc //找到整个文件中的每个匹配字符，并且对每个匹配字符提示是否进行替换 19.在VIM内执行外部命令1:!command //执行一个外部命令command 123例如:!ls //显示当前目录内容:!rm FILENAME //删除名为FILENAME的文件 20.保存命令12:w TEST //以 TEST 为文件名保存整个文件v motion :w FILENAME //选择性保存文件的部分内容，按v并移动光标以选择 21.提取与合并12:r FILENAME //将FILENAME内容提取并插入到光标后:r !ls //读取 ls 命令的输出结果，并将其插入在光标后 22.打开新的一行 12o //小写字母o，在光标下方打开新的一行,并进入插入模式O //大写字母O，在光标上方打开新的一行,并进入插入模式 23.插入文本12a 要插入的文本 //在光标后插入文本A 要插入的文本 //在光标所在行的行末插入文本 24.复制粘贴1v 光标移动选择内容 y 移动光标到要粘贴的位置 p //v选择，y复制，p粘贴 25.获取帮助信息123- 按下 &lt;HELP&gt; 键 (如果键盘上有的话)- 按下 &lt;F1&gt; 键 (如果键盘上有的话)- 输入 :help &lt;回车&gt; 12CTRL-W //使光标在窗口之间跳转:q &lt;回车&gt; //关闭帮助窗口 26.创建启动脚本及vimrc配置123:edit ~/.vimrc //Unix所使用的命令:edit $VIM/_vimrc //MS-Windows所使用的命令:write //保存文件 12:r $VIMRUNTIME/vimrc_example.vim //读取vimrc 示例文件的内容:help vimrc-intro //获取vimrc配置帮助 27.命令补全1:e CTRL-D &lt;TAB&gt; //Vim 会显示以 e 开始的命令的列表，TAB选择补全]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础入坑（二）]]></title>
    <url>%2F2017%2F08%2F22%2Fwebpack%E5%9F%BA%E7%A1%80%E5%85%A5%E5%9D%91%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[webpack基础入坑（二 接上回 上回主要操作了指南的 Installation 与 GettingStarted 这两部分，这时候我们大概能猜出 webpack 的某些功能了： 使用各种 loader 加载不同的资源 把所有资源打包起来 bundle.js我们可以阅读一下最后生成的 bundle.js（可以写几个简单的JS文件打包，参数部分看起来会更方便一些）bundle.js 是一个并不复杂的自执行函数（每一行都有代码注释）容主要由两部分组成： webpackBootstrap 函数入口，主体部分打包的功能就在这部分，有兴趣的话可以看一下每一行的功能，大致就是把每个模块call一下，然后把模块保存到 installedModules 里，然后需要用到的时候可以直接调用。 参数部分传入一个数组，数组的每一项都是一个模块，每个模块都有一个独立的模块ID，模块需要其他依赖时直接通过模块ID来调用。 就此打住，这篇文章主题并不在讲 bundle.js。 JS 压缩webpack打包之后我们发现 dist/bundle.js 有800KB，因为我们引入了 lodash 和 jQuery 这两个库，但是并没有压缩代码，那么如何压缩呢？方法很多，其中最简单的一种就是使用 webpack 自带的压缩插件 UglifyJsPlugin： 我们修改一下 npm scripts 的配置，添加一个字段启动webpack的压缩功能：1"build-p": "webpack -p" 重新运行命令打包文件，得到的 bundle.js 就是一个压缩过的文件。 更多使用方法参考这里：UglifyJS 1npm run build-p 运行帮助命令查看 -p 参数的具体功能1234./node_modules/.bin/webpack --help# 找到如下介绍-p shortcut for --optimize-minimize --define process.env.NODE_ENV="production" 123webpack -p# 相当于以下命令webpack --optimize-minimize --define process.env.NODE_ENV="'production'" 它会执行如下步骤： 使用 UglifyJsPlugin 进行 JS 文件压缩 运行 LoaderOptionsPlugin 设置 NodeJS 环境变量，触发某些 package 包，以不同的方式进行编译。 开发环境每次改完代码都要运行一次打包命令是不是很烦人？没关系，webpack 肯定也考虑到了，于是乎我们就可以通过 webpack 自带的监听功能自动监听文件变动然后执行编译。 Development 这一章节就是专门介绍如何快速开发的。 1. 调整编辑器首先，我们先拉到文章底部，按照它的要求调整我们的编辑器： 2. Source Maps调整好编辑器后我们再返回页面顶部，找到Source Maps功能：将编译后的代码映射回原始源代码，如果某个源文件中存在错误，source map会追踪到错误和警告在源代码中的原始位置，方便代码调试。123456789 var path = require('path'); module.exports = &#123; entry: './src/index.js',+ devtool: 'inline-source-map', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125; &#125;; 故意改错源文件中的代码，然后运行 npm run build 打包，然后在浏览器控制台你会发现 bundle.js 的报错会指向源文件。 3. Watch Mode再修改一下 npm scripts 的配置，添加一个字段以启动监听模式：1"watch": "webpack --watch" 运行 npm run watch12npm run watch# 运行成功直接编译然后光标继续闪动表示监听中... 如果你想要退出，请按 Ctrl+c 好了现在我们试一下这个监听功能，我们随便修改一个文件内容，按 Ctrl+s 保存。 切换回命令行，你会发现 webpack 自动执行了编译操作。 4. webpack-dev-server此功能能够让你的浏览器自动刷新，是不是棒棒哒~（虽然很多编辑器也都有这个功能=。=） 按照老规矩，第一步添加修改 npm scripts 的配置，添加一个字段以启动开发服务器：1"start": "webpack-dev-server --open" 修改 webpack.config.js ，在 module.exports 对象中添加一个字段 devServer ，告知 webpack-dev-server 将指定目录下的文件作为可访问文件。123devServer: &#123; contentBase: './'&#125;, 运行 npm run start 启动服务器，然后浏览器就会自动打开 http://localhost:8080/ ，你会看到 index.html 页面。1npm run start 接下来如果我们改一下 src/index.js，你就会发现 bundle.js 自动打包 http://localhost:8080/ 自动刷新 注意：期间 dist/bundle.js 不会自动变化，在部署代码之前，依然要运行 npm run build 才行。 5. webpack-dev-middleware功能与 webpack-dev-server 类似，新手入坑不建议使用 webpack-dev-middleware （完）]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础入坑（一）]]></title>
    <url>%2F2017%2F08%2F22%2Fwebpack%E5%9F%BA%E7%A1%80%E5%85%A5%E5%9D%91%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[webpck 基础入坑（一）安装这里有webpack发布的所有版本：https://github.com/webpack/webpack/releases 当然你也可以直接通过 npm 命令安装：1npm install --save-dev webpack 如果你要体验最新版本的webpack请使用以下命令安装：1npm install webpack@beta 文档Google 搜索 webpack 第一条结果：https://webpack.github.io/ 页面中指明了三个链接： documentation - 文档所有功能的罗列，文档一般不是按照从易到难的顺序给出，但是肯定包含的几乎所有功能的介绍。 introducation - 介绍简单说明了 webpack 的作用和基本概念。 tutorial - 教程比较容易上手，教你一步一步自学 webpack 需要中文的小伙伴请点这里：https://doc.webpack-china.org/ 实践（抄写）点开 tutorial - 教程 ，然后一行一行地复制里面的命令：123456# 新建并进入 webpack-demo 目录mkdir webpack-demo &amp;&amp; cd webpack-demo# npm 初始化一个 package.jsonnpm init -y# 安装 webpack 作为开发依赖npm install --save-dev webpack ps: 安装过慢请自行切换国内淘宝源 按教程上说的做123456# 新建一个index.hrmltouch index.html# 新建一个src文件夹mkdir src# 在src文件夹内新建一个index.jscd src &amp;&amp; touch index.js 现在你的目录结构是这样的：12345webpack-demo|- package.json|- index.html|- /src |- index.js ok，咱们继续抄12345678910function component() &#123; var element = document.createElement('div'); // Lodash, currently included via a script, is required for this line to work element.innerHTML = _.join(['Hello', 'webpack'], ' '); return element;&#125;document.body.appendChild(component()); 注意上面代码中的 _.join ，这个 _ 实际上是 lodash 暴露的全局变量。 编辑 webpack-demo 目录下的 index.html123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/lodash@4.16.6&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;./src/index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 为了使用 lodash，HTML 使用 script 引入了 lodash v4.16.6。 教程里说这样引用逼格太低，我们可以用更高端的方法引入安装 lodash 为必要依赖123# 请先确保命令行当前所在目录是 webpack-demonpm install --save lodash# 上面命令可以简写成 npm i -S lodash 好了，lodash 的源代码已经下载到 ./node_modules/lodash/ 目录中。 然后在 src/index.js 的第一行添加12import _ from 'lodash';// 然后是function component () &#123; 意思是从 lodash 里得到默认导出，并将默认导出命名为 _，这个 _ 可以换成任何一个其他的变量名。 然后按照教程说的把 index.html 也改了12345678910 &lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt;- &lt;script src="https://unpkg.com/lodash@4.16.6"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;- &lt;script src="./src/index.js"&gt;&lt;/script&gt;+ &lt;script src="./dist/bundle.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 然后命令行输入：1./node_modules/.bin/webpack app/index.js dist/bundle.js 12# 如果你是全局安装的webpack直接运行以下代码webpack app/index.js dist/bundle.js 在浏览器中打开 index.html，如果你看到’Hello webpack’ 说明运行成功。 这是目前的文件结构：1234567|- src |- index.js|- dist |- bundle.js|- index.html|- node_modules/|- package.json ./node_modules/.bin/webpack app/index.js dist/bundle.js 将 src/index.js 转化成 dist/bundle.js index.html 引用的是 dist/bundle.js lodash 安装在 node_modules 里，在index.js中用import引用 webpack 也安装在 node_modules里，./node_modules/.bin/webpack 是一个可执行文件 webpack、lodash 的版本号都被写在 package.json 里 修改引入 jQuery如果我们要在页面中引入 jQuery，先安装：12# 确定你在 webpack-demo 目录npm i -S jquery 以上命令相当于：1npm install --save jquery 然后 jquery 模块就被下载到了 node_modules 中。 然后我们继续在 src./index.js 中引入 jquery123456789101112131415 import _ from 'lodash'+import j from 'jquery' function component () &#123;- var element = document.createElement('div');+ var element = j('&lt;div&gt;&lt;/div&gt;');- element.innerHTML = _.join(['Hello','webpack'], ' ');+ element.html(_.join(['Hello','webpack'], ' '))- return element;+ return element.get(0); &#125; document.body.appendChild(component()); 然后再次运行1./node_modules/.bin/webpack app/index.js dist/bundle.js 打开 index.html。如果你看到 “Hello webpack”，那就说明 jquery 也成功引入，只不过我们把它命名为 j，显然命名为 $ 更符合习惯，你可以自己改一下试试！ 改进上面每次都要运行 ./node_modules/.bin/webpack app/index.js dist/bundle.js 实在是烦人，教程里给出了方法：123# 确保你在项目根目录 webpack-demo# 新建一个 webpack.config.js 文件touch webpack.config.js 然后编辑它：123456789var path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;; output 出口设置，必须是绝对路径，因此在第一行引入 path 模块，方便路径的设置； entry 入口设置，可以是相对路径； filename 输出的文件名； 然后命令行运行：1./node_modules/.bin/webpack --config webpack.config.js 不过这句话依然很长，每次输入很麻烦，教程又教了一个办法：使用 npm-scripts 修改 package.json12345 "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",+ "build": "webpack" &#125;, "keywords": [], 然后命令行运行：1npm run build 说明运行 npm run build 就等于运行 node_modules 里的 webpack 可执行文件，这个可执行文件会找到项目根目录下的 webpack.config.js 并按照其中的设置执行对应的操作 最后再看一下文件目录：123456789webpack-demo|- /src |- index.js|- /dist |- bundle.js|- index.html|- webpack.config.js|- /node_modules|- package.json （完）]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章彻底入门 SCSS]]></title>
    <url>%2F2017%2F08%2F21%2F%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%BD%BB%E5%BA%95%E5%85%A5%E9%97%A8%20SCSS%2F</url>
    <content type="text"><![CDATA[SCSS 起飞指南 写在前面：本文看起来比较长，其实是罗列了比较多的示例代码，如果你能坚持看完，对照学习，相信两个小时后你就能自己起飞愉快地去写scss了。 （一）Sass 与SCSS的区别1.1 什么是Sass Sass 是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。 1.2 Sass 与SCSS有什么区别 Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass ，两者之间不同之处有以下两点： 文件扩展名不同：Sass 是以 .sass 后缀为扩展名SCSS 是以 .scss 后缀为扩展名 语法书写方式不同：Sass 是以严格的缩进式语法规则来书写，不带大括号 {} 和分号 ;SCSS 的语法书写和我们的 CSS 语法书写方式非常类似 建议使用后缀名为 scss 的文件，以避免 sass 后缀名的严格格式要求报错。 （二）安装和使用2.1 安装 Sass 基于Ruby语言，但两者语法之间没有关系。使用Sass 无需先学习ruby，但是必须先安装Ruby，然后再安装Sass 。 macbook自带ruby环境，直接打开终端运行 gem 命令安装sass 即可； windows需要先自行安装ruby，然后在 CMD 或其他命令行工具中运行安装命令； ruby官网 安装时请勾选Add Ruby executables to your PATH这个选项，添加环境变量，不然以后使用编译软件的时候会提示找不到ruby环境 正确安装完ruby依赖后，安装sass： 1gem install sass 安装sass完成后查看版本测试安装有没有成功： 123sass -v# 安装成功会打印版本号Sass 3.5.1 (Bleeding Edge) 如上已经安装成功。但因为国内网络（不可描述）的问题导致gem源间歇性中断，因此我们需要更换gem源。 使用淘宝的gem源 https://ruby.taobao.org/： 123456789101112# 1.删除原gem源gem sources --remove https://rubygems.org/# 2.添加国内淘宝源gem sources -a https://ruby.taobao.org/# 3.打印是否替换成功gem sources -l# 4.更换成功后打印如下*** CURRENT SOURCES ***https://ruby.taobao.org/ 2.2 使用 windows 用户注意：编译 scss 文件中如果存在中文，可能出现类似于这样的报错：1`Syntax error: Invalid GBK character "\xE5"` 请一定不要惊慌，找到类似于下面的目录：1C:\Ruby24-x64\lib\ruby\gems\2.4.0\gems\sass-3.5.1\lib\sass 然后在该目录中找到 engine.rb ，编辑添加一行代码：1Encoding.default_external = Encoding.find('utf-8') 编译sass sass 编译有很多种方式，如命令行编译模式、sublime插件SASS-Build、编译软件koala、前端自动化软件codekit、Grunt打造前端自动化工作流grunt-sass、Gulp打造前端自动化工作流gulp-ruby-sass等。 命令行编译; 1234567891011# 1. 直接打印转化后的代码sass test.scss# 2. 单文件转换命令sass input.scss output.css# 3.1 单文件监听命令,实时转换sass --watch input.scss:output.css# 3.2 如果你有很多的sass文件，也可以监听整个目录：sass --watch app/sass:public/stylesheets SASS提供四个编译风格的选项： 1234* nested：嵌套缩进的css代码，它是默认值。* expanded：没有缩进的、扩展的css代码。* compact：简洁格式的css代码。* compressed：压缩后的css代码。 操作命令：12# 添加指令 --style [编译风格]sass test.sass test.css --style compressed 四种编译排版演示:123456789//未编译样式.box &#123; width: 300px; height: 400px; &amp;-title &#123; height: 30px; line-height: 30px; &#125;&#125; nested 嵌套缩进的css代码 1234567/*编译过后样式*/.box &#123; width: 300px; height: 400px; &#125; .box-title &#123; height: 30px; line-height: 30px; &#125; expanded 没有缩进的、扩展的css代码 123456789/*编译过后样式*/.box &#123; width: 300px; height: 400px;&#125;.box-title &#123; height: 30px; line-height: 30px;&#125; compact 简洁格式的css代码 123/*编译过后样式*/.box &#123; width: 300px; height: 400px; &#125;.box-title &#123; height: 30px; line-height: 30px; &#125; compressed 压缩后的css代码 12/*编译过后样式*/.box&#123;width:300px;height:400px&#125;.box-title&#123;height:30px;line-height:30px&#125; （三）基本用法 建议先下载示例代码，然后跟着走一遍，结束之后你会大致掌握Sass的基本用法 本部分主要分为六块，目录中未提及的变量、注释等其他基础用法已包含在其中。 Sass的官方网站，提供了一个在线转换器。你可以在那里，试运行下面的各种例子。 注： 以下所有代码块的第一行注释/*SCSS*/ 和 /*CSS*/ 是人为添加的！ 以下所有编译风格默认 nested 如果命令行出现类似如下提示说明该方法即将弃用，有时会向下面那样提示你用其他方法代替：123DEPRECATION WARNING on line 77 of input/calculate.scss:The operation `#123123 plus #040506` is deprecated and will be an error in future versions.Consider using Sass's color functions instead. 3.1 嵌套规则1. 选择器嵌套 父子层级关系明显； 代码具有良好的可读性； 示例：123456789101112/*SCSS*/#a &#123; .a-1 &#123; background: yellow; .child &#123; font-size: 12px; .child-1 &#123; color: red &#125; &#125; &#125;&#125; 1234567/*CSS*/#a .a-1 &#123; background: yellow; &#125; #a .a-1 .child &#123; font-size: 12px; &#125; #a .a-1 .child .child-1 &#123; color: red; &#125; 2. 引用父选择符： &amp;&amp; 在编译时将被替换为父选择符，输出到 CSS 中 示例：1234567891011/*scss*/.hello &#123; .dropdown &#123; display: none; &#125; &amp;:hover &#123; .dropdown &#123; display: block; &#125; &#125;&#125; 12345/*css*/.hello .dropdown &#123; display: none; &#125;.hello:hover .dropdown &#123; display: block; &#125; 3. 属性嵌套某些属性具有可选参数的，类似于 border 、font 、background 这样的，可以让你少复制自己的代码，当然直接使用缩写更方便一些，但使用属性嵌套的方法可读性更佳不是吗？ 示例：123456789101112/*scss*/.funky &#123; font: &#123; family: fantasy; size: 30em; weight: bold; &#125; border: &#123; radius: 20px; color: red; &#125;&#125; 1234567/*css*/.funky &#123; font-family: fantasy; font-size: 30em; font-weight: bold; border-radius: 20px; border-color: red; &#125; 4. 注释规则/*标准的CSS注释*/ 编译后依旧存在//单行注释 编译后被删除/*!重要注释*/在/*后面加一个感叹号 ! ，表示这是重要注释。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。 示例： 1234/*scss*//*标准的CSS注释*///单行注释/*!重要注释*/ 123/*css*//*标准的CSS注释*//*!重要注释*/ 3.2 计算规则1. 定义变量 $varSCSS中所有的变量由一个 $ 符号定义12345/*scss*/$width: 10px;#main &#123; width: $width;&#125; 123/*css*/#main &#123; width: 10px; &#125; 2. 插值: #{}将 #{里面的值}当做字符串插入1234567/*scss*/$name: foo;$attr: border;p.#&#123;$name&#125; &#123; #&#123;$attr&#125;-color: blue; content: "hello world #&#123;$name&#125;"&#125; 1234/*css*/p.foo &#123; border-color: blue; content: "hello world foo"; &#125; 在文本字符串中，#{} 形式的表达式可以被用来在字符串中添加动态值，空值会被视作空字符串：12345678/*scss*/p:before &#123; content: "I ate #&#123;5 + 10&#125; pies!";&#125;$value: null;p:before &#123; content: "I ate #&#123;$value&#125; pies!";&#125; 123456/*css*/p:before &#123; content: "I ate 15 pies!"; &#125;p:before &#123; content: "I ate pies!"; &#125; 3. +、-、*、/ 的运算 在SCSS中+ 、- 、* 的运算方法与日常使用相同，需要单位的还请都带上你的单位； / 除法运算比较特殊，直接使用最后编译出来的结果可能并不是你日常所想的那样，其特殊性大致分为三种情况，下面的代码演示中已一一说明； 圆括号 () 可以改变运算顺序； 1234567891011/*scss*//*加减法运算*/p &#123; width: 1px + 8px; height: 10px - 2px;&#125;/*乘法运算*/div &#123; width: 3px * 5; height: 2px + 6px * 3;&#125; 12345678910/*css*//*加减法运算*/p &#123; width: 9px; height: 8px; &#125;/*乘法运算*/div &#123; width: 15px; height: 20px; &#125; 圆括号 () 变运算顺序：1234/*scss*/p &#123; width: (1em + 2em) * 3;&#125; 123/*css*/p &#123; width: 9em; &#125; 除法运算比较特殊：在以下三种情况中，/ 会被解释为除法运算。 覆盖了绝大多数真正使用除法运算的情况。 这些情况是： 如果数值或它的任意部分是存储在一个变量中或是函数的返回值。 如果数值被圆括号包围。 如果数值是另一个数学表达式的一部分 12345678910/*scss*//*除法运算*/p &#123; font: 10px/8px; // 纯 CSS，不是除法运算，兼容IE8的写法 $width: 1000px; width: $width/2; // 使用了变量，是除法运算 line-height: round(3.5)/2; // 使用了函数，是除法运算 height: (500px/2); // 使用了圆括号，是除法运算 margin-left: 5px + 8px/2px; // 使用了加（+）号，是除法运算&#125; 1234567/*css*/p &#123; font: 10px/8px; width: 500px; line-height: 2; height: 250px; margin-left: 9px; &#125; 如果你希望在纯 CSS 中使用 变量 和 /， 你可以用 #{} 包住 变量 。 例如：123456/*scss*/p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125; 123/*css*/p &#123; font: 12px/30px; &#125; 3.3 @import@media@extend 指令1. 引入 @import@import &quot;basic&quot;：查找当前目录下的 basic.scss 或者 basic.sass 引入到当前文件中1234567891011121314/*scss*/@import "basic";//basic.sass内容如下//#a &#123;// .a-1 &#123;// background: yellow;// .child &#123;// font-size: 12px;// .child-1 &#123;// color: red// &#125;// &#125;// &#125;//&#125; 1234567/*css*/#a .a-1 &#123; background: yellow; &#125; #a .a-1 .child &#123; font-size: 12px; &#125; #a .a-1 .child .child-1 &#123; color: red; &#125; 直接 @import test.css 相当于原生CSS的 @import 引用12/*scss*/@import "test.css"; 12/*css*/@import url(test.css); 2. 嵌套 @import有助于创建一个新的命名空间123456789101112131415/*scss*/.example &#123; @import "basic.scss";&#125;//basic.sass内容如下//#a &#123;// .a-1 &#123;// background: yellow;// .child &#123;// font-size: 12px;// .child-1 &#123;// color: red// &#125;// &#125;/ 12345678/*css*/.example &#123;&#125; .example #a .a-1 &#123; background: yellow; &#125; .example #a .a-1 .child &#123; font-size: 12px; &#125; .example #a .a-1 .child .child-1 &#123; color: red; &#125; 3. 媒体查询 @media用法与原生CSS一样123456789101112/*scss*/.father &#123; .sidebar &#123; width: 300px; @media screen and (orientation: landscape) &#123; width: 500px; .hello &#123; font-size: 20px &#125; &#125; &#125;&#125; 12345678/*css*/.father .sidebar &#123; width: 300px; &#125; @media screen and (orientation: landscape) &#123; .father .sidebar &#123; width: 500px; &#125; .father .sidebar .hello &#123; font-size: 20px; &#125; &#125; 4. 继承 @extend使用 @extend 可以让一个选择器继承另一个选择器 4.1 继承单个选择器12345678910111213/*scss*/.error &#123; border: 1px #f00; &amp;.intrusion &#123; background-image: url("/image/hacked.png"); &#125; &amp;:hover &#123; color: #00b88d; &#125;&#125;.extendError &#123; @extend .error;&#125; 1234567/*css*/.error, .extendError, .seriousError, .criticalError &#123; border: 1px #f00; &#125; .error.intrusion, .intrusion.extendError, .intrusion.seriousError, .intrusion.criticalError &#123; background-image: url("/image/hacked.png"); &#125; .error:hover, .extendError:hover, .seriousError:hover, .criticalError:hover &#123; color: #00b88d; &#125; 4.2 继承复合选择器12345678910111213/*scss*/.div1.div2 &#123; text-decoration: underline;&#125;.div3:hover &#123; text-decoration: overline;&#125;.extend1 &#123; @extend .div1.div2;&#125;.extend2 &#123; @extend .div3:hover&#125; 123456/*css*/.div1.div2, .extend1 &#123; text-decoration: underline; &#125;.div3:hover, .extend2 &#123; text-decoration: overline; &#125; 4.3 继承多个选择器1234567891011121314151617/*scss*/.error &#123; border: 1px #f00; background-color: #fdd;&#125;.attention &#123; font-size: 3em; background-color: #ff0;&#125;.seriousError &#123; // ===&gt; @extend .error; @extend .attention; border-width: 3px;&#125; 1234567891011/*css*/.error, .seriousError &#123; border: 1px #f00; background-color: #fdd; &#125;.attention, .seriousError &#123; font-size: 3em; background-color: #ff0; &#125;.seriousError &#123; border-width: 3px; &#125; 4.4 连续继承12345678910111213141516171819/*scss*/.error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125;.criticalError &#123; @extend .seriousError; position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%;&#125; 1234567891011121314/*css*/.error, .seriousError, .criticalError &#123; border: 1px #f00; background-color: #fdd; &#125;.seriousError, .criticalError &#123; border-width: 3px; &#125;.criticalError &#123; position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%; &#125; 3.4 mixin 指令@mixin 可以预先定义样式的代码块；@include 可以引入 @mixin 预定义的样式；该指令类似于 @extend 的继承效果，区别是@mixin指令预定义的样式编译后会自动去除，可以有效避免使用非语义化的类名； 1. @mixin 与 @include示例1：样式123456789101112131415/*scss*/@mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125;.page-title &#123; @include large-text; padding: 4px; margin-top: 10px;&#125; 12345678/*css*/.page-title &#123; font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px; &#125; 示例2：选择器 + 样式123456789/*scss*/@mixin silly-links &#123; a &#123; color: blue; background-color: red; &#125;&#125;@include silly-links; 1234/*css*/a &#123; color: blue; background-color: red; &#125; 示例3：复合使用1234567891011121314151617/*scss*/@mixin highlighted-background &#123; background-color: #fc0;&#125;@mixin header-text &#123; font-size: 20px;&#125;@mixin compound &#123; @include highlighted-background; @include header-text;&#125;.test &#123; @include compound&#125; 1234/*css*/.test &#123; background-color: #fc0; font-size: 20px; &#125; 2. 定义参数示例4：$arguments@mixin 可以定义参数，@include调用的时候传参；123456789101112/*scss*/@mixin sexy-border($color, $width) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue, 10px);&#125; 12345/*css*/p &#123; border-color: blue; border-width: 10px; border-style: dashed; &#125; 3. 指定参数的缺省值123456789/*scss*/@mixin left($value: 10px) &#123; float: left; margin-right: $value;&#125;p &#123; @include left;&#125; 1234/*css*/p &#123; float: left; margin-right: 10px; &#125; 4. $arg...示例5：$arg...可以用 $参数... 表示所有传入的参数1234567891011/*scss*/$b: box-shadow;@mixin box-shadow($shadows...) &#123; -moz-#&#123;$b&#125;: $shadows; -webkit-#&#123;$b&#125;: $shadows; #&#123;$b&#125;: $shadows;&#125;.shadows &#123; @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);&#125; 12345/*css*/.shadows &#123; -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; &#125; 3.5 条件语句、循环语句1. 条件语句@if...else... 条件判断，判断结果为 true 时赋值样式 示例1：123456789101112131415/*scss*/p &#123; @if 1 + 1 == 2 &#123; border: 1px solid; &#125; @if true &#123; background-image: url(''); &#125; @if 5 &lt; 3 &#123; border: 2px dotted; &#125; @if null &#123; border: 3px double; &#125;&#125; 1234/*css*/p &#123; border: 1px solid; background-image: url(""); &#125; 示例2：12345678910111213/*scss*/$type: monster;p &#123; @if $type == ocean &#123; color: blue; &#125; @else if $type == matador &#123; color: red; &#125; @else if $type == monster &#123; color: green; &#125; @else &#123; color: black; &#125;&#125; 123/*css*/p &#123; color: green; &#125; 2. 循环语句注意form...through与from ... to循环的范围 2.1 @for $var form...through...示例：from … through123456/*scss*/@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; 123456789/*css*/.item-1 &#123; width: 2em; &#125;.item-2 &#123; width: 4em; &#125;.item-3 &#123; width: 6em; &#125; 2.2 @for $var from...to...示例：from … to123456/*scss*/@for $i from 1 to 3 &#123; .item-to-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; 123456/*css*/.item-to-1 &#123; width: 2em; &#125;.item-to-2 &#123; width: 4em; &#125; 2.3 @each $var in ...@each 为 $var 循环所有 in 后面列出的值示例：@each … in …123456/*scss*/@each $animal in puma, sea-slug, egret, salamander &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/images/#&#123;$animal&#125;.png'); &#125;&#125; 123456789101112/*css*/.puma-icon &#123; background-image: url("/images/puma.png"); &#125;.sea-slug-icon &#123; background-image: url("/images/sea-slug.png"); &#125;.egret-icon &#123; background-image: url("/images/egret.png"); &#125;.salamander-icon &#123; background-image: url("/images/salamander.png"); &#125; 2.4 @while $var ...示例：while循环12345678/*scss*/$i: 6;@while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2;&#125; 123456789/*css*/.item-6 &#123; width: 12em; &#125;.item-4 &#123; width: 8em; &#125;.item-2 &#123; width: 4em; &#125; 2.5 条件 + 循环示例：12345678/*scss*///@for 后面的第一个$i 相当于参数，第二个$i 直接将变量的值拿过来用$i: 6;@for $i from 1 through $i &#123; .col-#&#123;$i&#125; &#123; width: $i/6*100% &#125;&#125; 相当于：1234567/*scss*/$i: 6;@for $j from 1 through $i &#123; .col-#&#123;$j&#125; &#123; width: $j/6*100% &#125;&#125; 123456789101112131415161718/*css*/.col-1 &#123; width: 16.6666666667%; &#125;.col-2 &#123; width: 33.3333333333%; &#125;.col-3 &#123; width: 50%; &#125;.col-4 &#123; width: 66.6666666667%; &#125;.col-5 &#123; width: 83.3333333333%; &#125;.col-6 &#123; width: 100%; &#125; 3.6 自定义函数12345678910111213141516171819202122/*scss*/$grid-width: 40px;$gutter-width: 10px;@function test($a) &#123; @return $a + 10;&#125;@function grid-width($n) &#123; $hello: 1px; @for $i from 1 through $n &#123; $hello: $hello + $i; &#125; @if $hello &gt; 10 &#123; $hello: 15px; &#125; @return $hello + test(2);&#125;#sidebar &#123; width: grid-width(5);&#125; 123/*css*/#sidebar &#123; width: 27px; &#125; （教程结束） 复习 如果你对着教程自己有在操作，那么你可以再抽时间过一遍阮一峰老师的SASS用法指南，配合食用味道更佳哦~ （完） 参考SASS用法指南-阮一峰SASS中文文档-bootcss]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Blog！]]></title>
    <url>%2F2017%2F08%2F19%2FHello%20Blog%EF%BC%81%2F</url>
    <content type="text"><![CDATA[一、为什么要写博客不知道大家写博客的理由都是什么，反正我的理由很简单，不外乎以下几点： 记录自己的学习笔记； 记录自己的生活动态； 分享一些有趣的东西； 一个全平台的收藏夹； 处女座来强行凑个数； 二、写博客的好处我的天！这个标题让我想起还在学校的时候，本宝宝是经管学院市场营销专业的QAQ，还记得网络营销的第一课就是经典的企业博客营销，所以你有事没事分享点有趣的东西骗骗粉也不错吖，指不定哪天就火了呢~尤其是在目前这个粉丝经济尤为突出的市场环境下，万一你一不小心火了，博客就是你的招牌，你说是不咯？ 当然本宝宝并不是冲着营销号方向走的=。=纯粹是为了记录自己的进步与二逼的想法QAQ 强化记忆！个人觉得这是写博客对自己最大的好处了。 学习上以前没有记笔记的习惯，但是现在要转行做码农辣，学习了一段时候后才发现，不记笔记是硬伤！不记笔记是硬伤！不记笔记是硬伤！ 重要的事情说三遍。不知道其他的圈子是什么样的 ，至少以我目前浅薄的目光来看前端圈，琳（luan）琅（qi）满（ba）目（zao）的API，除非有着超超超超一流的记忆能力，否则你很难记住一些奇奇怪怪的东西。 生活上可以记录一些有意思的生活动态，比如说游记、菜谱、随笔、灵感等。指不定某天冒出个想法改变了自己的未来呢，哈哈。 三、写好博客的秘诀贵在坚持，仅此而已。自己也是第一次开始尝试写个人博客，就先这样吧=。= （完）]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
