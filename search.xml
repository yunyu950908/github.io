<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[map 与 forEach 简单比较]]></title>
    <url>%2F2017%2F09%2F04%2Fmap-%E4%B8%8E-forEach-%E7%AE%80%E5%8D%95%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[map 与 forEach 简单比较 参考资料：MDN文档：Array.prototype.forEach()MDN文档：Array.prototype.map() 结论先写结论： forEach 不会产生新数组，返回值 undefined map 会返回一个新数组，不对原数组产生影响 map 因为返回新数组，所以可以链式操作（可操作性强） 速度 forEach &gt; map &gt; for（网上有说map &gt; forEach 然而测试结果并不是） 一、Array.prototype.forEach()forEach() 方法对数组的每个元素执行一次提供的函数。 语法：12345array.forEach(callback(currentValue, index, array)&#123; //do something&#125;, this)array.forEach(callback[, thisArg]) 参数： callback为数组中每个元素执行的函数，该函数接收三个参数： currentValue(当前值)数组中正在处理的当前元素。 index(索引)数组中正在处理的当前元素的索引。 arrayforEach()方法正在操作的数组。 thisArg可选可选参数。当执行回调 函数时用作this的值(参考对象)。 返回值undefined. 使用： 示例1：注意 callback 和 返回值1234567const arr = [1,2,3,"a","b","c"]let _arr = arr.forEach((e,i,arr)=&gt;&#123; console.log(e) // 1, 2, 3, "a","b","c" console.log(i) // 0, 1, 2, 3, 4, 5 console.log(arr) // 输出6次 [1, 2, 3, "a", "b", "c"]&#125;)console.log(_arr) // undefined 1、对数组的每一项都调用一次 callback 回调函数；2、总是返回值 undefined 示例2：可选参数 thisArg12345678910111213141516171819class Calculate&#123; constructor(x,y)&#123; this.x = 0; this.y = 0; &#125; sum(array)&#123; array.forEach(function(e)&#123; this.x += e; ++this.y; &#125;,this) console.log(this); // 指向该构造函数 &#125;&#125;const obj = new Calculate();obj.sum([1,2,3,4]);console.log(obj.x) // 10console.log(obj.y) // 4 1、thisArg 参数 (this) 传给了forEach()2、每次调用时，它都被传给 callback 函数，作为它的this值 示例3：forEach() 不会在迭代之前创建数组的副本1234567const words = ["one","two","three","four"];words.forEach((word)=&gt;&#123; console.log(word); // "one","two","four" if(word === "two")&#123; words.shift(); // "two"输出完后删除了第一项，索引改变 &#125;&#125;) 遍历 two 后，整个数组的第一个项被移除了，导致所有剩余项索引 -1，而下一次执行回调遍历的那一项索引依旧 +1，所以three被跳过了。 Array.prototype.map()map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 语法：123let array = arr.map(function callback(currentValue, index, array) &#123; // Return element for new_array&#125;[, thisArg]) 参数： callback生成新数组元素的函数，使用三个参数： currentValuecallback 的第一个参数，数组中正在处理的当前元素。 indexcallback 的第二个参数，数组中正在处理的当前元素的索引。 arraycallback 的第三个参数，map 方法被调用的数组。 thisArg可选的。执行 callback 函数时 使用的this 值。 返回值（与 forEach 最大的不同点）一个新数组，每个元素都是回调函数的结果。 使用： 示例1：map 方法返回处理后的数组，不修改原数组123const numbers = [1, 4, 9];let roots = numbers.map(Math.sqrt);// roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9] 示例2：格式化数组中的对象1234567891011const kvArray = [&#123;key: 1, value: 10&#125;, &#123;key: 2, value: 20&#125;, &#123;key: 3, value: 30&#125;];let reformattedArray = kvArray.map(function(obj) &#123; let rObj = &#123;&#125;; rObj[obj.key] = obj.value; return rObj;&#125;);// reformattedArray = [&#123;key: 1, value: 10&#125;, &#123;key: 2, value: 20&#125;, &#123;key: 3, value: 30&#125;]; 示例3：在类数组集合上调用，利用 call 改变 this 指向1234const oLis = document.querySelectorAll("ul li");let arrOlis = Array.prototype.map.call(oLis，function(e)&#123; return e.value;&#125;) 示例4：反转字符串，原理同上（示例3）；链式调用（返回新数组）123456const str = "12345";let _str = Array.prototype.map.call(str,x=&gt;&#123; return x;&#125;).reverse().join("");// _str = "54321";// str = "12345"; 性能对比123456789101112131415161718192021let arr1 = [];for(let i=0; i&lt;50000; i++)&#123; arr1.push(i)&#125;const start = Date.now()// forEach ==&gt; 2ms ~ 3ms// let arr2 = [];// arr1.forEach((e)=&gt;arr2.push(e*2))// map ==&gt; 10ms ~ 13ms// let arr2 = arr1.map(e=&gt;return e*2)// for ==&gt; 20ms ~ 26ms// let arr2 = [];// for(let i = 0;i&lt;arr1.length;i++)&#123;// arr2[i] = arr1[1]// &#125;const end = Date.now()console.log(end-start) 通过以上的代码测试，速度方面 forEach &gt; map &gt; for 但是 由于前端处理数据的局限性，速度并不是我们实际使用考虑的因素，实际情况是： 代码量：map &gt; forEach &gt; for 代码量：map &gt; forEach &gt; for 代码量：map &gt; forEach &gt; for 综上，如果出于 代码量 和 链式调用 的需求，用 map 可能会更好一些。 （完）]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试题：数组、递归]]></title>
    <url>%2F2017%2F08%2F30%2F%E8%AF%95%E9%A2%98%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[试题：数组、递归题干：实现一个 flatten 函数，将一个嵌套多层的数组 array (嵌套可以是任何层数) 转换为只有一层的数组。 1234567// 数组中元素仅基本类型的元素或数组，不存在循环引用的情况。var arr = [1, [2], [3, [[4]]]];/* 在这里定义你的 flatten 函数 */var _arr = flatten(arr);console.log(_arr); // 输出 [1,2,3,4] 审题：先看一眼题目给出的这个 arr ，按照题意的说法，这就是给你一个数组，数组内包含 基本类型元素 和 嵌套了任意层数的数组 ，然后注意这个数组 不存在循环引用的情况 也就是说嵌套数组中也只有基本类型元素或数组，这就简单多啦，我们只需要把所有数组中的基本类型元素提取出来，然后放进一个新数组就可以咯~ 首先，写代码遵循一个 DRY 的基本准则： Don&#39;t Repeat Yourself；然后，这种有规律、层级多、需要重复调用的，第一反应就是 递归 嘛，那接下来就用递归思想写一个 flatten 函数。 这是我们要操作的数组： 1arr = [1, [2], [3, [[4]]]] 然后这是 flatten 函数大概要做的事情： 次数 — — — 第一次 数字 1 数组 [2] 数组 [3,[[4]]] 第二次 数字 2 数字 3 数组 [[4]] 第三次 数组 [4] 第四次 数字 4 做题emmmmm . . . 下面是我能想到的方法，实现方式有很多，大家可以自由发挥。 方法一：Array.prototype.reduce() + Array.isArray() + Array.prototype.concat() 文档链接：Array.prototype.reduce() 文档链接：Array.isArray() 文档链接：Array.prototype.concat() 1234567891011121314function flatten(arr) &#123; return arr.reduce(function (initArr, currentArr) &#123; return initArr.concat(Array.isArray(currentArr) ? flatten1(currentArr) : currentArr); &#125;, [])&#125;var arr = [1, [2], [3, [[4]]]]var arr1 = [-1, [0, 1], ["String", [[[undefined, null]], true, false]]]var _arr = flatten(arr)console.log(_arr) // [ 1, 2, 3, 4 ]var _arr1 = flatten(arr1)console.log(_arr1) // [ -1, 0, 1, 'String', undefined, null, true, false ] 方法二：Array.prototype.forEach() + 闭包 + Array.prototype.push() 文档：Array.prototype.forEach() 文档：Array.prototype.push() 闭包：来自《JavaScript 标准参考教程（alpha）》，by 阮一峰 12345678910111213141516171819202122232425function flatten(arr) &#123; // 定义一个空数组用来存放提取出来的基本类型元素 var _arr = []; // 用一个自执行函数处理多层嵌套数组 (function _flatten(arr) &#123; arr.forEach(function (e, i) &#123; if (e instanceof Array) &#123; // 当然也可以写成其他形式，比如：if(typeof e === 'object') _flatten(e); &#125; else &#123; _arr.push(e); &#125; &#125;); &#125;)(arr); return _arr;&#125;var arr = [1, [2], [3, [[4]]]]var arr1 = [-1, [0, 1], ["String", [[[undefined, null]], true, false]]]var _arr = flatten(arr)console.log(_arr) // [ 1, 2, 3, 4 ]var _arr1 = flatten(arr1)console.log(_arr1) // [ -1, 0, 1, 'String', undefined, null, true, false ] 总结好了，以上就是我大概的想法，希望大家思考更多其他的方法实现。 最后，要注意的是： 不要为了做题而做题！ 那么，做题能干嘛呢？ 做题能检查自己知识点的掌握情况； 做题能够快速学习不熟悉的 API ； 做题能够整理巩固已掌握的知识点； 不信？你看这篇文章，如果你把我列出的代码跟文档读过一遍，你可能学习/复习了以下知识点： 递归思想 Array.prototype.reduce() Array.isArray() Array.prototype.concat() Array.prototype.forEach() Array.prototype.push() instanceof 、typeof 闭包 （完）]]></content>
      <categories>
        <category>试题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>递归</tag>
        <tag>试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数声明、函数表达式、匿名函数]]></title>
    <url>%2F2017%2F08%2F29%2F%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E3%80%81%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数声明、函数表达式、匿名函数 本文内容为函数基础，欢迎全段位玩家划水吐槽(^▽^) 一、函数声明、函数表达式的区别 函数声明：function functionName(){} 函数表达式：var fn = function(){} 匿名函数：function(){} 区别：函数声明与函数表达式的区别主要表现在声明前置与函数标识符两部分。 :—: 声明前置 标识符（函数名） 函数声明 函数声明前置 不可省略 函数表达式 变量声明前置 可以省略 匿名函数 无 无 示例： 函数声明不可省略标识符，否则抛出 error SyntaxError 错误，通过 foo 调用； 函数表达式省略了函数标识符，通过 fn 调用 12345678910111213141516// 判断声明前置console.log(foo) // function foo()&#123;console.log('foo: "函数声明"')&#125;console.log(fn) // undefined// 函数声明function foo()&#123;console.log('foo: "函数声明"')&#125;// 函数表达式 var fn = function()&#123;console.log('fn: "函数表达式"')&#125;// 函数表达式声明后打印console.log(fn) // function ()&#123;console.log('fn: "函数表达式"')&#125;// 调用foo() // foo: "函数声明"fn() // fn: "函数表达式" 二、变量的声明前置、函数的声明前置变量的声明前置： 在一个作用域块中，所有的变量声明都会被JS引擎放在作用域块范围的顶部进行； 函数的声明前置： 和变量声明前置一样，执行代码之前会先读取函数声明，只要函数在代码中进行了声明，无论它在作用域块的哪个位置上进行声明，JS引擎都会将它的声明放在作用域块范围的顶部进行； 优先级： 函数声明的优先级高于变量声明的优先级（函数声明 &gt; 变量声明） 示例：利用同名 函数/变量 判断 声明前置的优先级123456789101112131415// 判断声明优先级console.log(foo) // function foo()&#123;console.log("foo")&#125;console.log(fn) // function fn()&#123;console.log("fn")&#125;// 声明：函数 ==&gt; 变量function foo()&#123;console.log("foo")&#125;var foo = 1;// 声明：变量 ==&gt; 函数var fn =2;function fn()&#123;console.log("fn")&#125;// 赋值后打印console.log(foo) // 1console.log(fn) // 2 以上代码正确的执行顺序是：12345678910111213// 因为函数声明优先提升，所以后提升的变量声明把函数声明挤到了后面var foo;var fn;function foo()&#123;console.log("foo")&#125;function fn()&#123;console.log("fn")&#125;// 然后JS引擎从上到下解释运行，后面的函数声明会覆盖掉前面的变量声明console.log(foo) // function foo()&#123;console.log("foo")&#125;console.log(fn) // function fn()&#123;console.log("fn")&#125;foo = 1;fn = 2;console.log(foo) // 1console.log(fn) // 2 三、匿名函数匿名函数在 javascript 中广泛用于赋值、传参、构建闭包等操作。 函数表达式啊咧咧？函数表达式怎么跑这里来了？？？ 没错，函数表达式就是匿名函数的一种应用。 不信你看函数表达式右边，这就是一个把匿名函数赋值给一个变量的过程。12var foo = function()&#123;console.log(1)&#125;foo() // 1 构建闭包闭包是 javascript 最强大的特性之一。它的最大用处有两个，一个是可以读取其他函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 示例：这里只将闭包作为匿名函数的应用示例，并不展开讨论闭包。1234567891011var a = 1000;function foo()&#123; var a = 1; return function()&#123; //匿名函数 a = a + 1; console.log(a) &#125;&#125;var fn = foo()fn() // 2fn() // 3 立即执行函数表达式（IIFE）这是一个写在任何地方都不会抛出 Uncaught SyntaxError 错误的匿名函数 立即执行函数表达式（Immediately-Invoked Function Expression），简称IIFE。表示定义函数之后，立即调用该函数。 作用：隔离作用域，保护私有变量，防止污染全局变量 最常用的两种写法：1(function()&#123; /* code */ &#125;()); 1(function()&#123; /* code */ &#125;)(); 示例：定义之后立即调用1(function(a)&#123;console.log(a)&#125;)(10) // 10 参考：（译）详解javascript立即执行函数表达式（IIFE） ##抛出错误 如果匿名函数直接写成以下形式会抛出 Uncaught SyntaxError 错误，不过相信你也不会这样写，毕竟这样写的话你就没有办法调用它了QAQ1function（）&#123;/*code*/&#125; // Uncaught SyntaxError: （完）]]></content>
      <categories>
        <category>函数</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>闭包</tag>
        <tag>声明前置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试题：作用域链+闭包]]></title>
    <url>%2F2017%2F08%2F29%2F%E8%AF%95%E9%A2%98%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[试题：作用域链 + 闭包在开始阅读本文之前，你可能需要了解包括且不限于以下知识点，否则极有可能会浪费您宝贵的时间。 闭包 作用域 执行上下文 this 自执行函数 伪代码声明本文没有用中文汉字解释每一行代码执行做了哪些事情，但是有很详细的伪代码作为参考，虽然略为繁琐，但如果你将它整理成自己的思路，以后遇到类似的问题就能迅速思考得出答案。 约定： Context 执行上下文 AO 活动对象 Scope 作用域链 先来一道开胃菜，至少可以让我们大概知道每一行伪代码说明了什么。 开胃菜：1234567891011var x = 10bar()function foo() &#123; console.log(x)&#125;function bar()&#123; var x = 30 foo() // 输出什么&#125; 注意： 调用函数的时候，先从该函数体内查找所需的变量，如果没有，再从函数定义的那个作用域查找所需变量。以此类推，直到顶层作用域，如果依旧没有，输出 undefined 以下是我的伪代码规则：伪代码：1234567891011121314151617181920212223242526272829303132333435363738394041/* * 执行上下文 * globalContext = &#123; * 活动对象 * AO: &#123; * x: 10 * foo: function * bar: function * &#125;, * 作用域链 * Scope: null * &#125; * * 声明 foo 时 得到下面 * foo.[[scope]] = globalContext.AO * * 声明 bar 时 得到下面 * bar.[[scope]] = globalContext.AO * * 注意： 在当前的执行上下文内声明的函数，这个函数的[[scope]]就指向当前执行上下文的 AO * * 当调用 bar() 时， 进入 bar 的执行上下文 * * barContext = &#123; * AO: &#123; * x: 30 * &#125;, * Scope: bar.[[scope]] //globalContext.AO * &#125; * * 当调用 foo() 时，先从 bar 执行上下文中的 AO里找foo函数，找不到再从 bar 的 [[scope]]里找找到后即调用 * * 当调用 foo() 时，进入 foo 的执行上下文 * * fooContext = &#123; * AO: &#123;&#125;, * Scope: foo.[[scope]] // globalContext.AO * &#125; * * 所以最后在console中输出 10 * */ ok，开胃菜没有任何难度，接下来上正餐咯 (*^▽^*) 主菜一：123456789101112131415161718var num = 7;var obj = &#123; num: 8, fn: (function () &#123; this.num *= 2; num += 3; num = 6; return function () &#123; this.num *= 5; num += 6; console.log(num); &#125; &#125;)(num)&#125;var fn = obj.fn;fn();obj.fn();console.log(window.num, obj.num); 如需文字说明，请留言注明。以下是每一步操作的伪代码，希望诸君在思考过后再参考：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* * 1. 栈底 ==&gt; 全局上下文 * 执行上下文 * globalContext=&#123; * 活动对象 * AO: &#123; * num: 7, * obj: &#123;&#125;, * (function()&#123;&#125;)(): function, * fn: obj.fn, * fn(): function, * obj.fn(): function * &#125; * 作用域链 * scope: none * &#125; * 通过以上伪代码可以得出以下的作用域链 * (function()&#123;&#125;)().[[scope]] = globalContext.AO * fn().[[scope]] = globalContext.AO * obj.fn().[[scope]] = globalContext.AO * * 2. 自执行函数 * (function()&#123;&#125;)()Context=&#123; * AO: &#123; * (globalContext.AO.num: 14 ==&gt; 17 ==&gt; 6) * (return function(): function) * &#125; * scope: globalContext.AO * &#125; * * 3. fn() * fnContext = &#123; * AO: &#123; * num: 30 ==&gt; 36 * &#125; * scope: globalContext.AO * &#125; * * 4. obj.fn() * step1: * objContext = &#123; * AO: &#123; * num: 8, * fn: function * &#125; * scope: globalContext.AO * &#125; * fn.[[scope]] = objContext.AO * * step2: * obj.fn Context=&#123; * AO: &#123; * (objContext.AO.num: 40) * (globalContext.AO.num: 42) * &#125; * scope: objContext.AO * &#125; * * */ 主菜二：123456789101112131415161718var num = 20;var obj = &#123; num: 30, fn: (function (num) &#123; num += 15; var num = 45; return function () &#123; this.num *= 4; num += 20; console.log(num); &#125; &#125;)(num)&#125;var fn = obj.fn;fn();obj.fn();console.log(window.num, obj.num); 如需文字说明，请留言注明。以下是每一步操作的伪代码，希望诸君在思考过后再参考：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * 1. 栈底 ==&gt; globalContext * globalContext=&#123; * AO: &#123; * num: 20, * obj: &#123;&#125;, * (function()&#123;&#125;)(), * fn: obj.fn, * fn(): function, * obj.fn(): function * &#125; * scope: none * &#125; * (function()&#123;&#125;)().[[scope]] = globalContext.AO * fn().[[scope]] = globalContext.AO * obj.fn().[[scope]] = globalContext.AO * * 2. (function()&#123;&#125;()) * (function()&#123;&#125;())Context = &#123; * AO: &#123; * num: 45 * (return function(): function) * &#125; * scope: globalContext.AO * &#125; * * 3. fn() * fnContext = &#123; * AO: &#123; * (globalContext.AO.num: 80) * ((function()&#123;&#125;()).AO.num: 45 ==&gt; 65) * num: 65 * &#125; * scope: globalContext.AO * &#125; * * 4. obj.fn() * step1: * objContext = &#123; * AO: &#123; * num: 30, * fn: function * &#125; * scope: globalContext.AO * &#125; * fn.[[scope]] = objContext * * step2: * obj.fn()Context = &#123; * AO: &#123; * (objContext.AO.num: 120) * ((function()&#123;&#125;()).AO.num: 65 ==&gt; 85) * num: 85 * &#125; * scope: objContext.AO * &#125; * * */ 本文示例中的伪代码全为个人喜好，没有标准规范，诸君可为自身喜好量身定制，直到自己用的 [ 爽 ] 为止。 另外，诚如本文一开始所说的那样，虽然书写出伪代码能够得出一个精确的答案，但过程比较繁琐，所以应尽量把伪代码变成自己的思路，这样才在实际操作中迅速找到问题所在，解决问题。 （完）]]></content>
      <categories>
        <category>试题</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>试题</tag>
        <tag>作用域</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leanCloud存储数据]]></title>
    <url>%2F2017%2F08%2F29%2FleanCloud%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据存储</category>
      </categories>
      <tags>
        <tag>leanCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 生命周期（Lifecycle）]]></title>
    <url>%2F2017%2F08%2F27%2FReact-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%88%9D%2F</url>
    <content type="text"><![CDATA[React 生命周期（Lifecycle）参考：The Component Lifecycle React 的生命周期包括三个阶段：1231. mount（挂载）2. update（更新）3. unmount（移除） mountmount 就是第一次让组件出现在页面中的过程。这个过程的关键就是 render 方法。React 会将 render 的返回值（一般是虚拟 DOM，也可以是 DOM 或者 null）插入到页面中。 这个过程会暴露几个钩子（hook）方便你往里面加代码： 12341. constructor()2. componentWillMount()3. render()4. componentDidMount() updatemount 之后，如果数据有任何变动，就会来到 update 过程，这个过程有 5 个钩子： 1234567891011121314// - 我要读取 props 啦！componentWillReceiveProps(nextProps)// - 请问要不要更新组件？true / falseshouldComponentUpdate(nextProps, nextState) // - 我要更新组件啦！componentWillUpdate() // - 更新！render() // - 更新完毕啦！componentDidUpdate() ##unmount 当一个组件将要从页面中移除时，会进入 unmount 过程，这个过程就一个钩子： 12// - 我要死啦！componentWillUnmount() 你可以在这个组件死之前做一些清理工作。 总结一般情况下只在这几个钩子里 setState：1234componentWillMount()componentDidMount()componentWillReceiveProps(nextProps, nextState) componentDidUpdate() 参考：React lifecycle cheatsheet]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 基础入门实例]]></title>
    <url>%2F2017%2F08%2F25%2FReact-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[react 基本语法一、ReactDOM.render()ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 1234ReactDOM.render( &lt;h1&gt;Hello React&lt;/h1&gt;, document.getElementById("example")) 二、JSX 语法HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写. JSX 的基本语法规则： 遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析； 遇到 代码块 （以 { 开头），就用 JavaScript 规则解析。 1234567891011121314var names = ['傻龙', '大鳖', '大宝', '煜神'];ReactDOM.render( &lt;div&gt; &#123; // map会返回一个新数组，不对原数组产生影响,foreach不会产生新数组， // map因为返回数组所以可以链式操作，foreach不能 names.map(function (name, index) &#123; return &lt;div key=&#123;index&#125;&gt;Hello &#123;name&#125;&lt;/div&gt; &#125;) &#125; &lt;/div&gt;, document.getElementById('example')) JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员，添加到模板， 123456789var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;,];ReactDOM.render( //如果这个变量是一个数组，JSX 会把它的所有成员，添加到模板 &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById(&apos;example&apos;)); 三、组件React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。 React.createClass() 方法就用于生成一个组件类 123456789101112131415var HelloMessage = React.createClass(&#123; render: function () &#123; return ( //class 跟 for 是js的保留字，所以使用规则如下： &lt;div className="thisIsClass" htmlFor='thisIsFor'&gt; &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;)ReactDOM.render( &lt;HelloMessage name="Albert"/&gt;, document.getElementById("example")) 上面代码中，变量 HelloMessage 就是一个组件类。模板插入 &lt;HelloMessage /&gt; 时，会自动生生成 HelloMessage 的一个实例。 所有组件类都必须有自己的 render 方法，用于输出组件。 注意，组件类的第一个字母必须大写，否则会报错，比如HelloMessage不能写成helloMessage。 另外，组件类只能包含一个顶层标签，否则也会报错。 组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 &lt;HelloMessage name=&quot;Albert&quot;&gt; ，就是 HelloMessage 组件加入一个 name 属性，值为 Albert。 组件的属性可以在组件类的 this.props 对象上获取，比如 name 属性就可以通过 this.props.name 读取。 因为 class 和 for 是 JavaScript 的保留字，所以添加组件属性时，有一个地方需要注意： class 属性需要写成 className ； for 属性需要写成 htmlFor ； 四、this.props.childrenthis.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点。 1234567891011121314151617181920212223var NotesList = React.createClass(&#123; render: function () &#123; return ( &lt;ol&gt; &#123; //this.props.children 表示组件的所有子节点 React.Children.map(this.props.children, function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ol&gt; ); &#125;&#125;);ReactDOM.render( &lt;NotesList&gt; &#123;/*以下就是组件的两个子节点*/&#125; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.getElementById('example')); 上面代码的 NoteList 组件有两个 span 子节点，它们都可以通过 this.props.children 读取 这里需要注意， this.props.children 的值有三种可能： 如果当前组件没有子节点，它就是 undefined ; 如果有一个子节点，数据类型是 object ； 如果有多个子节点，数据类型就是 array ； 但是 ，好在 React 提供一个工具方法 React.Children 来处理 this.props.children 。 我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。 更多的 React.Children 的方法，请参考官方文档。 五、PropTypes组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。 组件类的 PropTypes 属性，就是用来验证组件实例的属性是否符合要求。 12345678910111213141516171819202122232425// 如果把引号去掉就是数值类型，就会报错var data = "string!";var MyTitle = React.createClass(&#123; PropTypes: &#123; //通过 React.PropTypes 规定 title 接受值的类型 title: React.PropTypes.string.isRequired &#125;, //设置组件属性的默认值 getDefaultProps: function () &#123; return &#123; title: "hello world" &#125; &#125;, render: function () &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;MyTitle title=&#123;data&#125;/&gt;, document.getElementById('example')); 上面的 Mytitle 组件有一个 title 属性。PropTypes 告诉 React，这个 title 属性是必须的，而且它的值必须是字符串。 此外，getDefaultProps 方法可以用来设置组件属性的默认值。 六、获取真实的DOM节点组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。 但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性 12345678910111213141516171819202122var Component = React.createClass(&#123; handleClick: function () &#123; //this.refs.[refName].[handler] this.refs.refName.focus() &#125;, render: function () &#123; return ( &lt;div&gt; &#123;/* ref：为了从组件获取真实 DOM 节点 */&#125; &lt;input type="text" ref="refName" /&gt; &lt;input type="button" value="focus the text input" onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ) &#125;&#125;);ReactDOM.render( &lt;Component /&gt;, document.getElementById("example")) Component 组件中的输入框用于获取用户的输入，这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。 需要注意的是，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 Click 事件的回调函数，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性。 七、this.state组件免不了要与用户互动，React 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI 123456789101112131415161718192021var LikeButton = React.createClass(&#123; getInitialState: function () &#123; return &#123;liked: false&#125; &#125;, handleClick: function () &#123; this.setState(&#123;liked: !this.state.liked&#125;) &#125;, render: function () &#123; var text = this.state.liked ? "like" : "haven\'t liked"; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ) &#125;&#125;)ReactDOM.render( &lt;LikeButton/&gt;, document.getElementById('example')); 上面代码是一个 LikeButton 组件，它的 getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。 当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。 由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。 八、表单用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取。 1234567891011121314151617181920212223242526var Input = React.createClass(&#123; //初始化 this.state getInitialState: function () &#123; return &#123;value: "init"&#125; &#125;, //setState 改变 this.state 的值 //event.target.value 读取表单值 handleChange: function (event) &#123; this.setState(&#123;value: event.target.value&#125;) &#125;, render: function () &#123; var value = this.state.value; return ( &lt;div&gt; &#123;/*回调函数触发*/&#125; &lt;input type="text" value=&#123;value&#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;)ReactDOM.render( &lt;Input/&gt;, document.getElementById('example')); 上面代码中，文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。 textarea 元素、select元素、radio元素都属于这种情况，更多介绍请参考官方文档。 九、组件的生命周期组件的生命周期分成三个状态：123- Mounting：已插入真实 DOM- Updating：正在被重新渲染- Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。1234567- componentWillMount()- componentDidMount()- componentWillUpdate(object nextProps, object nextState)- componentDidUpdate(object prevProps, object prevState)- componentWillUnmount() 此外，React 还提供两种特殊状态的处理函数。 123- componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用- shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 这些方法的详细说明，可以参[考官方文档]。(http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods) 123456789101112131415161718192021222324252627282930313233var Hello = React.createClass(&#123; getInitialState: function () &#123; return &#123; opacity: 1 &#125;; &#125;, //插入真实 DOM 之后调用 componentDidMount: function () &#123; this.timer = setInterval(function () &#123; var opacity = this.state.opacity; opacity -= .05; if (opacity &lt; .1) &#123; opacity = 1; &#125; this.setState(&#123; opacity: opacity &#125;); //bind(this) 绑定自定义函数的 this &#125;.bind(this), 100) &#125;, render: function () &#123; return ( &lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt; Hello &#123;this.props.name&#125; &lt;/div&gt; ); &#125;,&#125;);ReactDOM.render( &lt;Hello name="World"/&gt;, document.getElementById("example")) 上面代码在Hello组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。 另外，组件的style属性的设置方式也值得注意，不能写成1style="opacity:&#123;this.state.opacity&#125;;" 而要写成1style=&#123;&#123;opacity: this.state.opacity&#125;&#125; 这是因为 React 组件样式 一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。 十、Ajax组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 componentDidMount 方法设置 Ajax 请求，等到请求成功，再用 this.setState 方法重新渲染 UI 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 定义一个 RepoList 组件var RepoList = React.createClass(&#123; // 初始化 this.state getInitialState: function () &#123; return &#123; loading: true, error: null, data: null &#125;; &#125;, // 组件添加到真实 DOM 后调用 componentDidMount() &#123; // 定义一个 promise this.props.promise.then( // promise 延时成功 value =&gt; &#123; // 改变 loading 状态，data 数据 this.setState(&#123;loading: false, data: value&#125;) &#125;, // promise 延时失败 改变 loading 状态，error 数据 error =&gt; this.setState(&#123;loading: false, error: error&#125;)); &#125;, // 渲染函数 render: function () &#123; // promise pending ... if (this.state.loading) &#123; return &lt;span&gt;Loading...&lt;/span&gt;; &#125; // promise reject! else if (this.state.error !== null) &#123; return &lt;span&gt;Error: &#123;this.state.error.message&#125;&lt;/span&gt;; &#125; else &#123; // 成功请求到数据，添加到变量和标签中 var repos = this.state.data.items; // 遍历 ajax 请求存储好的数据 var repoList = repos.map(function (repo, index) &#123; // 循环创建jsx html 标签，返回保存到repoList return ( &lt;li key=&#123;index&#125;&gt;&lt;a href=&#123;repo.html_url&#125;&gt;&#123;repo.name&#125;&lt;/a&gt; (&#123;repo.stargazers_count&#125; stars) &lt;br/&gt; &#123;repo.description&#125;&lt;/li&gt; ); &#125;); // 返回 创建 jsx html 标签并将 repolist 添加进去 return ( &lt;main&gt; &lt;h1&gt;Most Popular JavaScript Projects in Github&lt;/h1&gt; &lt;ol&gt;&#123;repoList&#125;&lt;/ol&gt; &lt;/main&gt; ); &#125; &#125;&#125;);// 插入 DOMReactDOM.render( // AJAX 请求数据 &lt;RepoList promise=&#123;$.getJSON('https://api.github.com/search/repositories?q=javascript&amp;sort=stars')&#125;/&gt;, document.getElementById('example')); 如果Promise对象正在抓取数据（pending状态），组件显示”正在加载”；如果Promise对象报错（rejected状态），组件显示报错信息；如果Promise对象抓取数据成功（fulfilled状态），组件显示获取的数据。 参考：React 入门实例教程]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Albert's Favorites]]></title>
    <url>%2F2017%2F08%2F25%2FAlbert-s-Favorites%2F</url>
    <content type="text"></content>
      <categories>
        <category>收藏夹</category>
      </categories>
      <tags>
        <tag>收藏夹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用CSS3实现一个立方体]]></title>
    <url>%2F2017%2F08%2F25%2F%E7%94%A8CSS3%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AB%8B%E6%96%B9%E4%BD%93%2F</url>
    <content type="text"></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详说 Cookie, LocalStorage 与 SessionStorage]]></title>
    <url>%2F2017%2F08%2F24%2F%E8%AF%A6%E8%AF%B4-Cookie-LocalStorage-%E4%B8%8E-SessionStorage%2F</url>
    <content type="text"><![CDATA[Cookie, LocalStorage 与 SessionStorage具体 Web Storage API 的使用可以参考 MDN的文档 基本概念CookieCookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。 localStoragelocalStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。 特性 Chrome Firefox (Gecko) Internet Explorer Opera Safari (WebKit) localStorage 4 3.5 8 10.50 4 sessionStorage 5 2 8 10.50 4 sessionStoragesessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。 三者的异同 特性 Cookie localStorage sessionStorage 数据的生命期 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 一般为5MB &lt;= 同localStorage 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 &lt;= 同localStorage 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 &lt;= 同localStorage 应用场景有了对上面这些差别的直观理解，我们就可以讨论三者的应用场景了。 因为考虑到每个 HTTP 请求都会带着 Cookie 的信息，所以 Cookie 当然是能精简就精简啦，比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。曾经还使用 Cookie 来保存用户在电商网站的购物车信息，如今有了 localStorage，似乎在这个方面也可以给 Cookie 放个假了~ 而另一方面 localStorage 接替了 Cookie 管理购物车的工作，同时也能胜任其他一些工作。比如HTML5游戏通常会产生一些本地数据，localStorage 也是非常适用的。如果遇到一些内容特别多的表单，为了优化用户体验，我们可能要把表单页面拆分成多个子页面，然后按步骤引导用户填写。这时候 sessionStorage 的作用就发挥出来了。 安全性的考虑需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为。所以千万不要用它们存储你系统中的敏感数据。 参考资料 what is the difference between localStorage, sessionStorage, session and cookie? HTML5 localStorage security 维基百科 - Cookie Web Storage API 浏览器本地数据（sessionStorage、localStorage、cookie）与server端数据 HTMl5的sessionStorage和localStorage HTML5 LocalStorage 本地存储 转自：详说 Cookie, LocalStorage 与 SessionStorage]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[低版本IE支持HTML5]]></title>
    <url>%2F2017%2F08%2F24%2F%E4%BD%8E%E7%89%88%E6%9C%ACIE%E6%94%AF%E6%8C%81HTML5%2F</url>
    <content type="text"><![CDATA[如何让低版本的 IE 支持 HTML5新标签1. 利用条件注释针对 IE 来调用这个 JS 文件。Opera，FireFox 等其他非 IE 浏览器就会忽视这段代码，也不会存在 http 请求。引用 html5shiv.js 文件，代码内容可以自己下载下来看。 BootCDN-html5shiv 123&lt;!--[if lt IE 9]&gt; &lt;script src="bower_components/html5shiv/dist/html5shiv.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 将以上代码放到 head 标签区间，由于现在国内网络环境（你懂的QAQ），直接引入外部 JS会让网页打开非常慢，所以建议大家先下载到服务器上，再进行本地文件的引用。 更多细节参考：The HTML5 Shiv 2. 用JS创建元素，然后添加CSS属性：1234567// 页面头部(function () &#123; var a = ['article', 'aside', 'details', 'figcaption', 'figure', 'footer', 'header', 'hgroup', 'nav', 'section']; for (var i = 0, j = a.length; i &lt; j; i++) &#123; document.createElement(a[i]); &#125;&#125;)(); 同理，可以用类数组转为数组： 12345678910111213// 页面头部function createHtml5Mark() &#123; // arguments 序列化成数组 var args = Array.prototype.slice.call(arguments, 0); argLen = args.length, doc = document; // 循环数据创建元素 for (var i = 0; i &lt; argLen; i++) &#123; doc.createElement(args[i]); &#125;&#125;createHtml5Mark('article', 'aside', 'details', 'figcaption', 'figure', 'footer', 'header', 'hgroup', 'nav', 'section'); 最后，需要在CSS添加属性： 1section,article,nav,header,footer&#123;display:block;&#125; （完）]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>IE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5入坑简单概览]]></title>
    <url>%2F2017%2F08%2F24%2FHTML5%E5%85%A5%E5%9D%91%E7%AE%80%E5%8D%95%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[HTML5 概览 本文概览：HTML5 新特性；标签的变化；属性的变化；新增的标签 HTML5是什么？ HTML5是超文本标记语言的第五次重大修改，2014年10月29日标准规范制定完成。 设计目的 HTML5 的设计目的是为了在移动设备上支持多媒体。新的语法特征被引进以支持这一点，如 video 、audio 和 canvas 标记。 HTML5 还引进了新的功能，可以真正改变用户与文档的交互方式，包括： 新的解析规则增强了灵活性 新属性 淘汰过时的或冗余的属性 一个HTML5文档到另一个文档间的拖放功能 离线编辑 信息传递的增强 详细的解析规则 多用途互联网邮件扩展（MIME）和协议处理程序注册 在SQL数据库中存储数据的通用标准（Web SQL） 有哪些新特性？MDN-HTML5 1. 语义特性HTML5 赋予网页更好的意义和结构。更加丰富的标签将随着对 RDFa，微数据与微格式等方面的支持，构建对程序、对用户都更有价值的数据驱动的Web。 2. 本地存储特性基于 HTML5 开发的网页APP拥有更短的启动时间，更快的联网速度，这些全得益于 HTML5 APP Cache ，以及本地存储功能。Indexed DB（HTML5本地存储最重要的技术之一）和 API 说明文档。 3. 设备兼容特性从 Geolocation 功能的API文档公开以来，HTML5 为网页应用开发者们提供了更多功能上的优化选择，带来了更多体验功能的优势。HTML5 提供了前所未有的数据与应用接入开放接口。使外部应用可以直接与浏览器内部的数据直接相连，例如视频影音可直接与microphones及摄像头相联。 4. 连接特性更有效的连接工作效率，使得基于页面的实时聊天，更快速的网页游戏体验，更优化的在线交流得到了实现。HTML5 拥有更有效的服务器推送技术，Server-Sent Events 和 WebSocket 就是其中的两个特性，这两个特性能够帮助我们实现服务器将数据“推送”到客户端的功能。 5. 网页多媒体特性 支持网页端的 audio 、video 等多媒体功能。 三维、图形及特效特性（Class: 3D, Graphics &amp; Effects） 基于 SVG、Canvas、WebGL 及CSS3 的 3D 功能，用户会惊叹于在浏览器中，所呈现的惊人视觉效果。 6. 性能与集成特性没有用户会永远等待你的Loading —— HTML5会通过 XMLHttpRequest2 等技术，解决以前的跨域等问题，帮助您的Web应用和网站在多样化的环境中更快速的工作。 7. CSS3特性在不牺牲性能和语义结构的前提下，CSS3 中提供了更多的风格和更强的效果。此外，较之以前的Web排版，Web的开放字体格式（WOFF）也提供了更高的灵活性和控制性。 关于标签1. 标签变化 DOCTYPE 1&lt;!DOCTYPE html&gt; 文档编码 1&lt;meta charset=&quot;UTF-8&quot; /&gt; 标签结尾 在 HTML5 中对于一些标签不再是必要的：（但是建议每个标签都要结束）li , dt , dd , p , rt , rp , optgroup , option , colgroup , thead , tbody , tfoot , tr , td , th 自结束的标签最后的 / 也不再必要img , input , br , hr 等 2. 属性变化2.1 具有 boolean 值的属性对于具有 boolean 值的属性，例如 disable 和 readonly 等，只写属性不写属性值时，其默认值为 true1234&lt;!-- 以下三条 checked 全部为选中状态 --&gt;&lt;input type=&quot;checkbox&quot; checked &gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; &gt;&lt;input type=&quot;checkbox&quot; checked=&quot;&quot; &gt; 2.2 省略属性值的引号属性值可以用单引号或者双引号，在属性值不包括 &lt;、&gt;、=、&#39;、&quot;时可以忽略引号12&lt;!-- 这里的text就省略了引号 --&gt;&lt;input type=text &gt; 2.3 input 新增 type注意：日期与时间相关的 type 目前均存在bugMDN：HTML元素参考-input1234567891011121314151617181920&lt;!-- 提交表单会自动验证是否为邮箱、电话、URL --&gt;&lt;input type=&quot;email&quot;&gt;&lt;input type=&quot;tel&quot;&gt;&lt;input type=&quot;url&quot;&gt;&lt;!-- 非数字无法输入 --&gt;&lt;input type=&quot;number&quot;&gt;&lt;!-- 一个指示范围的横向滚动条 --&gt;&lt;input type=&quot;range&quot;&gt;&lt;!-- 搜索框 --&gt;&lt;input type=&quot;search&quot;&gt;&lt;!-- 日期与时间（不建议使用） --&gt;&lt;input type=&quot;date&quot;&gt;&lt;input type=&quot;month&quot;&gt;&lt;input type=&quot;week&quot;&gt;&lt;input type=&quot;time&quot;&gt;&lt;input type=&quot;datetime-local&quot;&gt; 2.4 移除的元素 能被CSS替代的元素basefont , big , center , font , s , u , tt ,strike 不再使用frame框架frame , frameset , noframes 其它rb =&gt; rubyacronym =&gt; abbrdir =&gt; ulisindex =&gt; inputlisting =&gt; prexmp =&gt; codenextid =&gt; CUIDSplaintext =&gt; text/plain 2.5 新增属性 全局属性contentEditable , designMode , hidden , spellcheck , tabindex 表单相关autofocus , placeholder , form , required , novalidateformaction , formenctype , formmethod , formtarget , formnovalidate 链接相关a和area新增medialink新增sizes属性base新增target属性area新增hreflang和rel 其它ol新增reversedmeta新增charsetmenu新增type和labelstyle新增scopedscript新增asynchtml新增manifestiframe新增sandbox， seamless， srcdoc 2.6 废弃属性废弃的元素和属性 3. 新增标签 元素 描述 canvas 标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API audio 定义音频内容 video 定义视频（video 或者 movie） source 定义多媒体资源 &lt;video&gt; 和&lt;audio&gt; embed 定义嵌入的内容，比如插件 track 为诸如 &lt;video&gt; 和 &lt;audio&gt; 元素之类的媒介规定外部文本轨道 datalist 定义选项列表。与 input 元素配合使用该元素，来定义 input 可能的值 keygen 规定用于表单的密钥对生成器字段 output 定义不同类型的输出，比如脚本的输出 article 定义页面正文内容 aside 定义页面内容之外的内容 bdi 设置一段文本，使其脱离其父元素的文本方向设置 command 定义命令按钮，比如单选按钮、复选框或按钮 details 用于描述文档或文档某个部分的细节 dialog 定义对话框，比如提示框 summary 标签包含 details 元素的标题 figure 规定独立的流内容（图像、图表、照片、代码等等） figcaption 定义 &lt;figure&gt; 元素的标题 footer 定义 section 或 document 的页脚 header 定义了文档的头部区域 mark 定义带有记号的文本 meter 定义度量衡。仅用于已知最大和最小值的度量 nav 导航 progress 定义任何类型的任务的进度 ruby 定义 ruby 注释（中文注音或字符） rt 定义字符（中文注音或字符）的解释或发音 rp 在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容 section 定义文档中的节（section、区段） time 定义日期或时间 wbr 规定在文本中的何处适合添加换行符 参考 w3school：HTML 参考手册 MDN：HTML5 MDN：HTML5 标签列表 HTML5 学习笔记简明版 知乎：HTML5 到底是什么？ （完）]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack：bundle.js解析]]></title>
    <url>%2F2017%2F08%2F22%2Fwebpack%EF%BC%9Abundle-js%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础入坑（二）]]></title>
    <url>%2F2017%2F08%2F22%2Fwebpack%E5%9F%BA%E7%A1%80%E5%85%A5%E5%9D%91%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[webpack基础入坑（二 接上回 上回主要操作了指南的 Installation 与 GettingStarted 这两部分，这时候我们大概能猜出 webpack 的某些功能了： 使用各种 loader 加载不同的资源 把所有资源打包起来 bundle.js我们可以阅读一下最后生成的 bundle.js（可以写几个简单的JS文件打包，参数部分看起来会更方便一些）bundle.js 是一个并不复杂的自执行函数（每一行都有代码注释）容主要由两部分组成： webpackBootstrap 函数入口，主体部分打包的功能就在这部分，有兴趣的话可以看一下每一行的功能，大致就是把每个模块call一下，然后把模块保存到 installedModules 里，然后需要用到的时候可以直接调用。 参数部分传入一个数组，数组的每一项都是一个模块，每个模块都有一个独立的模块ID，模块需要其他依赖时直接通过模块ID来调用。 就此打住，这篇文章主题并不在讲 bundle.js。 JS 压缩webpack打包之后我们发现 dist/bundle.js 有800KB，因为我们引入了 lodash 和 jQuery 这两个库，但是并没有压缩代码，那么如何压缩呢？方法很多，其中最简单的一种就是使用 webpack 自带的压缩插件 UglifyJsPlugin： 我们修改一下 npm scripts 的配置，添加一个字段启动webpack的压缩功能：1"build-p": "webpack -p" 重新运行命令打包文件，得到的 bundle.js 就是一个压缩过的文件。 更多使用方法参考这里：UglifyJS 1npm run build-p 运行帮助命令查看 -p 参数的具体功能1234./node_modules/.bin/webpack --help# 找到如下介绍-p shortcut for --optimize-minimize --define process.env.NODE_ENV="production" 123webpack -p# 相当于以下命令webpack --optimize-minimize --define process.env.NODE_ENV="'production'" 它会执行如下步骤： 使用 UglifyJsPlugin 进行 JS 文件压缩 运行 LoaderOptionsPlugin 设置 NodeJS 环境变量，触发某些 package 包，以不同的方式进行编译。 开发环境每次改完代码都要运行一次打包命令是不是很烦人？没关系，webpack 肯定也考虑到了，于是乎我们就可以通过 webpack 自带的监听功能自动监听文件变动然后执行编译。 Development 这一章节就是专门介绍如何快速开发的。 1. 调整编辑器首先，我们先拉到文章底部，按照它的要求调整我们的编辑器： 2. Source Maps调整好编辑器后我们再返回页面顶部，找到Source Maps功能：将编译后的代码映射回原始源代码，如果某个源文件中存在错误，source map会追踪到错误和警告在源代码中的原始位置，方便代码调试。123456789 var path = require('path'); module.exports = &#123; entry: './src/index.js',+ devtool: 'inline-source-map', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125; &#125;; 故意改错源文件中的代码，然后运行 npm run build 打包，然后在浏览器控制台你会发现 bundle.js 的报错会指向源文件。 3. Watch Mode再修改一下 npm scripts 的配置，添加一个字段以启动监听模式：1"watch": "webpack --watch" 运行 npm run watch12npm run watch# 运行成功直接编译然后光标继续闪动表示监听中... 如果你想要退出，请按 Ctrl+c 好了现在我们试一下这个监听功能，我们随便修改一个文件内容，按 Ctrl+s 保存。 切换回命令行，你会发现 webpack 自动执行了编译操作。 4. webpack-dev-server此功能能够让你的浏览器自动刷新，是不是棒棒哒~（虽然很多编辑器也都有这个功能=。=） 按照老规矩，第一步添加修改 npm scripts 的配置，添加一个字段以启动开发服务器：1"start": "webpack-dev-server --open" 修改 webpack.config.js ，在 module.exports 对象中添加一个字段 devServer ，告知 webpack-dev-server 将指定目录下的文件作为可访问文件。123devServer: &#123; contentBase: './'&#125;, 运行 npm run start 启动服务器，然后浏览器就会自动打开 http://localhost:8080/ ，你会看到 index.html 页面。1npm run start 接下来如果我们改一下 src/index.js，你就会发现 bundle.js 自动打包 http://localhost:8080/ 自动刷新 注意：期间 dist/bundle.js 不会自动变化，在部署代码之前，依然要运行 npm run build 才行。 5. webpack-dev-middleware功能与 webpack-dev-server 类似，新手入坑不建议使用 webpack-dev-middleware （完）]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础入坑（一）]]></title>
    <url>%2F2017%2F08%2F22%2Fwebpack%E5%9F%BA%E7%A1%80%E5%85%A5%E5%9D%91%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[webpck 基础入坑（一）安装这里有webpack发布的所有版本：https://github.com/webpack/webpack/releases 当然你也可以直接通过 npm 命令安装：1npm install --save-dev webpack 如果你要体验最新版本的webpack请使用以下命令安装：1npm install webpack@beta 文档Google 搜索 webpack 第一条结果：https://webpack.github.io/ 页面中指明了三个链接： documentation - 文档所有功能的罗列，文档一般不是按照从易到难的顺序给出，但是肯定包含的几乎所有功能的介绍。 introducation - 介绍简单说明了 webpack 的作用和基本概念。 tutorial - 教程比较容易上手，教你一步一步自学 webpack 需要中文的小伙伴请点这里：https://doc.webpack-china.org/ 实践（抄写）点开 tutorial - 教程 ，然后一行一行地复制里面的命令：123456# 新建并进入 webpack-demo 目录mkdir webpack-demo &amp;&amp; cd webpack-demo# npm 初始化一个 package.jsonnpm init -y# 安装 webpack 作为开发依赖npm install --save-dev webpack ps: 安装过慢请自行切换国内淘宝源 按教程上说的做123456# 新建一个index.hrmltouch index.html# 新建一个src文件夹mkdir src# 在src文件夹内新建一个index.jscd src &amp;&amp; touch index.js 现在你的目录结构是这样的：12345webpack-demo|- package.json|- index.html|- /src |- index.js ok，咱们继续抄12345678910function component() &#123; var element = document.createElement('div'); // Lodash, currently included via a script, is required for this line to work element.innerHTML = _.join(['Hello', 'webpack'], ' '); return element;&#125;document.body.appendChild(component()); 注意上面代码中的 _.join ，这个 _ 实际上是 lodash 暴露的全局变量。 编辑 webpack-demo 目录下的 index.html123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/lodash@4.16.6&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;./src/index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 为了使用 lodash，HTML 使用 script 引入了 lodash v4.16.6。 教程里说这样引用逼格太低，我们可以用更高端的方法引入安装 lodash 为必要依赖123# 请先确保命令行当前所在目录是 webpack-demonpm install --save lodash# 上面命令可以简写成 npm i -S lodash 好了，lodash 的源代码已经下载到 ./node_modules/lodash/ 目录中。 然后在 src/index.js 的第一行添加12import _ from 'lodash';// 然后是function component () &#123; 意思是从 lodash 里得到默认导出，并将默认导出命名为 _，这个 _ 可以换成任何一个其他的变量名。 然后按照教程说的把 index.html 也改了12345678910 &lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt;- &lt;script src="https://unpkg.com/lodash@4.16.6"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;- &lt;script src="./src/index.js"&gt;&lt;/script&gt;+ &lt;script src="./dist/bundle.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 然后命令行输入：1./node_modules/.bin/webpack app/index.js dist/bundle.js 12# 如果你是全局安装的webpack直接运行以下代码webpack app/index.js dist/bundle.js 在浏览器中打开 index.html，如果你看到’Hello webpack’ 说明运行成功。 这是目前的文件结构：1234567|- src |- index.js|- dist |- bundle.js|- index.html|- node_modules/|- package.json ./node_modules/.bin/webpack app/index.js dist/bundle.js 将 src/index.js 转化成 dist/bundle.js index.html 引用的是 dist/bundle.js lodash 安装在 node_modules 里，在index.js中用import引用 webpack 也安装在 node_modules里，./node_modules/.bin/webpack 是一个可执行文件 webpack、lodash 的版本号都被写在 package.json 里 修改引入 jQuery如果我们要在页面中引入 jQuery，先安装：12# 确定你在 webpack-demo 目录npm i -S jquery 以上命令相当于：1npm install --save jquery 然后 jquery 模块就被下载到了 node_modules 中。 然后我们继续在 src./index.js 中引入 jquery123456789101112131415 import _ from 'lodash'+import j from 'jquery' function component () &#123;- var element = document.createElement('div');+ var element = j('&lt;div&gt;&lt;/div&gt;');- element.innerHTML = _.join(['Hello','webpack'], ' ');+ element.html(_.join(['Hello','webpack'], ' '))- return element;+ return element.get(0); &#125; document.body.appendChild(component()); 然后再次运行1./node_modules/.bin/webpack app/index.js dist/bundle.js 打开 index.html。如果你看到 “Hello webpack”，那就说明 jquery 也成功引入，只不过我们把它命名为 j，显然命名为 $ 更符合习惯，你可以自己改一下试试！ 改进上面每次都要运行 ./node_modules/.bin/webpack app/index.js dist/bundle.js 实在是烦人，教程里给出了方法：123# 确保你在项目根目录 webpack-demo# 新建一个 webpack.config.js 文件touch webpack.config.js 然后编辑它：123456789var path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;; output 出口设置，必须是绝对路径，因此在第一行引入 path 模块，方便路径的设置； entry 入口设置，可以是相对路径； filename 输出的文件名； 然后命令行运行：1./node_modules/.bin/webpack --config webpack.config.js 不过这句话依然很长，每次输入很麻烦，教程又教了一个办法：使用 npm-scripts 修改 package.json12345 "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",+ "build": "webpack" &#125;, "keywords": [], 然后命令行运行：1npm run build 说明运行 npm run build 就等于运行 node_modules 里的 webpack 可执行文件，这个可执行文件会找到项目根目录下的 webpack.config.js 并按照其中的设置执行对应的操作 最后再看一下文件目录：123456789webpack-demo|- /src |- index.js|- /dist |- bundle.js|- index.html|- webpack.config.js|- /node_modules|- package.json （完）]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章彻底入门 SCSS]]></title>
    <url>%2F2017%2F08%2F21%2F%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%BD%BB%E5%BA%95%E5%85%A5%E9%97%A8%20SCSS%2F</url>
    <content type="text"><![CDATA[SCSS 起飞指南 写在前面：本文看起来比较长，其实是罗列了比较多的示例代码，如果你能坚持看完，对照学习，相信两个小时后你就能自己起飞愉快地去写scss了。 （一）Sass 与SCSS的区别1.1 什么是Sass Sass 是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。 1.2 Sass 与SCSS有什么区别 Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass ，两者之间不同之处有以下两点： 文件扩展名不同：Sass 是以 .sass 后缀为扩展名SCSS 是以 .scss 后缀为扩展名 语法书写方式不同：Sass 是以严格的缩进式语法规则来书写，不带大括号 {} 和分号 ;SCSS 的语法书写和我们的 CSS 语法书写方式非常类似 建议使用后缀名为 scss 的文件，以避免 sass 后缀名的严格格式要求报错。 （二）安装和使用2.1 安装 Sass 基于Ruby语言，但两者语法之间没有关系。使用Sass 无需先学习ruby，但是必须先安装Ruby，然后再安装Sass 。 macbook自带ruby环境，直接打开终端运行 gem 命令安装sass 即可； windows需要先自行安装ruby，然后在 CMD 或其他命令行工具中运行安装命令； ruby官网 安装时请勾选Add Ruby executables to your PATH这个选项，添加环境变量，不然以后使用编译软件的时候会提示找不到ruby环境 正确安装完ruby依赖后，安装sass： 1gem install sass 安装sass完成后查看版本测试安装有没有成功： 123sass -v# 安装成功会打印版本号Sass 3.5.1 (Bleeding Edge) 如上已经安装成功。但因为国内网络（不可描述）的问题导致gem源间歇性中断，因此我们需要更换gem源。 使用淘宝的gem源 https://ruby.taobao.org/： 123456789101112# 1.删除原gem源gem sources --remove https://rubygems.org/# 2.添加国内淘宝源gem sources -a https://ruby.taobao.org/# 3.打印是否替换成功gem sources -l# 4.更换成功后打印如下*** CURRENT SOURCES ***https://ruby.taobao.org/ 2.2 使用 windows 用户注意：编译 scss 文件中如果存在中文，可能出现类似于这样的报错：1`Syntax error: Invalid GBK character "\xE5"` 请一定不要惊慌，找到类似于下面的目录：1C:\Ruby24-x64\lib\ruby\gems\2.4.0\gems\sass-3.5.1\lib\sass 然后在该目录中找到 engine.rb ，编辑添加一行代码：1Encoding.default_external = Encoding.find('utf-8') 编译sass sass 编译有很多种方式，如命令行编译模式、sublime插件SASS-Build、编译软件koala、前端自动化软件codekit、Grunt打造前端自动化工作流grunt-sass、Gulp打造前端自动化工作流gulp-ruby-sass等。 命令行编译; 1234567891011# 1. 直接打印转化后的代码sass test.scss# 2. 单文件转换命令sass input.scss output.css# 3.1 单文件监听命令,实时转换sass --watch input.scss:output.css# 3.2 如果你有很多的sass文件，也可以监听整个目录：sass --watch app/sass:public/stylesheets SASS提供四个编译风格的选项： 1234* nested：嵌套缩进的css代码，它是默认值。* expanded：没有缩进的、扩展的css代码。* compact：简洁格式的css代码。* compressed：压缩后的css代码。 操作命令：12# 添加指令 --style [编译风格]sass test.sass test.css --style compressed 四种编译排版演示:123456789//未编译样式.box &#123; width: 300px; height: 400px; &amp;-title &#123; height: 30px; line-height: 30px; &#125;&#125; nested 嵌套缩进的css代码 1234567/*编译过后样式*/.box &#123; width: 300px; height: 400px; &#125; .box-title &#123; height: 30px; line-height: 30px; &#125; expanded 没有缩进的、扩展的css代码 123456789/*编译过后样式*/.box &#123; width: 300px; height: 400px;&#125;.box-title &#123; height: 30px; line-height: 30px;&#125; compact 简洁格式的css代码 123/*编译过后样式*/.box &#123; width: 300px; height: 400px; &#125;.box-title &#123; height: 30px; line-height: 30px; &#125; compressed 压缩后的css代码 12/*编译过后样式*/.box&#123;width:300px;height:400px&#125;.box-title&#123;height:30px;line-height:30px&#125; （三）基本用法 建议先下载示例代码，然后跟着走一遍，结束之后你会大致掌握Sass的基本用法 本部分主要分为六块，目录中未提及的变量、注释等其他基础用法已包含在其中。 Sass的官方网站，提供了一个在线转换器。你可以在那里，试运行下面的各种例子。 注： 以下所有代码块的第一行注释/*SCSS*/ 和 /*CSS*/ 是人为添加的！ 以下所有编译风格默认 nested 如果命令行出现类似如下提示说明该方法即将弃用，有时会向下面那样提示你用其他方法代替：123DEPRECATION WARNING on line 77 of input/calculate.scss:The operation `#123123 plus #040506` is deprecated and will be an error in future versions.Consider using Sass's color functions instead. 3.1 嵌套规则1. 选择器嵌套 父子层级关系明显； 代码具有良好的可读性； 示例：123456789101112/*SCSS*/#a &#123; .a-1 &#123; background: yellow; .child &#123; font-size: 12px; .child-1 &#123; color: red &#125; &#125; &#125;&#125; 1234567/*CSS*/#a .a-1 &#123; background: yellow; &#125; #a .a-1 .child &#123; font-size: 12px; &#125; #a .a-1 .child .child-1 &#123; color: red; &#125; 2. 引用父选择符： &amp;&amp; 在编译时将被替换为父选择符，输出到 CSS 中 示例：1234567891011/*scss*/.hello &#123; .dropdown &#123; display: none; &#125; &amp;:hover &#123; .dropdown &#123; display: block; &#125; &#125;&#125; 12345/*css*/.hello .dropdown &#123; display: none; &#125;.hello:hover .dropdown &#123; display: block; &#125; 3. 属性嵌套某些属性具有可选参数的，类似于 border 、font 、background 这样的，可以让你少复制自己的代码，当然直接使用缩写更方便一些，但使用属性嵌套的方法可读性更佳不是吗？ 示例：123456789101112/*scss*/.funky &#123; font: &#123; family: fantasy; size: 30em; weight: bold; &#125; border: &#123; radius: 20px; color: red; &#125;&#125; 1234567/*css*/.funky &#123; font-family: fantasy; font-size: 30em; font-weight: bold; border-radius: 20px; border-color: red; &#125; 4. 注释规则/*标准的CSS注释*/ 编译后依旧存在//单行注释 编译后被删除/*!重要注释*/在/*后面加一个感叹号 ! ，表示这是重要注释。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。 示例： 1234/*scss*//*标准的CSS注释*///单行注释/*!重要注释*/ 123/*css*//*标准的CSS注释*//*!重要注释*/ 3.2 计算规则1. 定义变量 $varSCSS中所有的变量由一个 $ 符号定义12345/*scss*/$width: 10px;#main &#123; width: $width;&#125; 123/*css*/#main &#123; width: 10px; &#125; 2. 插值: #{}将 #{里面的值}当做字符串插入1234567/*scss*/$name: foo;$attr: border;p.#&#123;$name&#125; &#123; #&#123;$attr&#125;-color: blue; : "hello world #&#123;$name&#125;"&#125; 1234/*css*/p.foo &#123; border-color: blue; : "hello world foo"; &#125; 在文本字符串中，#{} 形式的表达式可以被用来在字符串中添加动态值，空值会被视作空字符串：12345678/*scss*/p:before &#123; : "I ate #&#123;5 + 10&#125; pies!";&#125;$value: null;p:before &#123; : "I ate #&#123;$value&#125; pies!";&#125; 123456/*css*/p:before &#123; : "I ate 15 pies!"; &#125;p:before &#123; : "I ate pies!"; &#125; 3. +、-、*、/ 的运算 在SCSS中+ 、- 、* 的运算方法与日常使用相同，需要单位的还请都带上你的单位； / 除法运算比较特殊，直接使用最后编译出来的结果可能并不是你日常所想的那样，其特殊性大致分为三种情况，下面的代码演示中已一一说明； 圆括号 () 可以改变运算顺序； 1234567891011/*scss*//*加减法运算*/p &#123; width: 1px + 8px; height: 10px - 2px;&#125;/*乘法运算*/div &#123; width: 3px * 5; height: 2px + 6px * 3;&#125; 12345678910/*css*//*加减法运算*/p &#123; width: 9px; height: 8px; &#125;/*乘法运算*/div &#123; width: 15px; height: 20px; &#125; 圆括号 () 变运算顺序：1234/*scss*/p &#123; width: (1em + 2em) * 3;&#125; 123/*css*/p &#123; width: 9em; &#125; 除法运算比较特殊：在以下三种情况中，/ 会被解释为除法运算。 覆盖了绝大多数真正使用除法运算的情况。 这些情况是： 如果数值或它的任意部分是存储在一个变量中或是函数的返回值。 如果数值被圆括号包围。 如果数值是另一个数学表达式的一部分 12345678910/*scss*//*除法运算*/p &#123; font: 10px/8px; // 纯 CSS，不是除法运算，兼容IE8的写法 $width: 1000px; width: $width/2; // 使用了变量，是除法运算 line-height: round(3.5)/2; // 使用了函数，是除法运算 height: (500px/2); // 使用了圆括号，是除法运算 margin-left: 5px + 8px/2px; // 使用了加（+）号，是除法运算&#125; 1234567/*css*/p &#123; font: 10px/8px; width: 500px; line-height: 2; height: 250px; margin-left: 9px; &#125; 如果你希望在纯 CSS 中使用 变量 和 /， 你可以用 #{} 包住 变量 。 例如：123456/*scss*/p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125; 123/*css*/p &#123; font: 12px/30px; &#125; 3.3 @import@media@extend 指令1. 引入 @import@import &quot;basic&quot;：查找当前目录下的 basic.scss 或者 basic.sass 引入到当前文件中1234567891011121314/*scss*/@import "basic";//basic.sass内容如下//#a &#123;// .a-1 &#123;// background: yellow;// .child &#123;// font-size: 12px;// .child-1 &#123;// color: red// &#125;// &#125;// &#125;//&#125; 1234567/*css*/#a .a-1 &#123; background: yellow; &#125; #a .a-1 .child &#123; font-size: 12px; &#125; #a .a-1 .child .child-1 &#123; color: red; &#125; 直接 @import test.css 相当于原生CSS的 @import 引用12/*scss*/@import "test.css"; 12/*css*/@import url(test.css); 2. 嵌套 @import有助于创建一个新的命名空间123456789101112131415/*scss*/.example &#123; @import "basic.scss";&#125;//basic.sass内容如下//#a &#123;// .a-1 &#123;// background: yellow;// .child &#123;// font-size: 12px;// .child-1 &#123;// color: red// &#125;// &#125;/ 12345678/*css*/.example &#123;&#125; .example #a .a-1 &#123; background: yellow; &#125; .example #a .a-1 .child &#123; font-size: 12px; &#125; .example #a .a-1 .child .child-1 &#123; color: red; &#125; 3. 媒体查询 @media用法与原生CSS一样123456789101112/*scss*/.father &#123; .sidebar &#123; width: 300px; @media screen and (orientation: landscape) &#123; width: 500px; .hello &#123; font-size: 20px &#125; &#125; &#125;&#125; 12345678/*css*/.father .sidebar &#123; width: 300px; &#125; @media screen and (orientation: landscape) &#123; .father .sidebar &#123; width: 500px; &#125; .father .sidebar .hello &#123; font-size: 20px; &#125; &#125; 4. 继承 @extend使用 @extend 可以让一个选择器继承另一个选择器 4.1 继承单个选择器12345678910111213/*scss*/.error &#123; border: 1px #f00; &amp;.intrusion &#123; background-image: url("/image/hacked.png"); &#125; &amp;:hover &#123; color: #00b88d; &#125;&#125;.extendError &#123; @extend .error;&#125; 1234567/*css*/.error, .extendError, .seriousError, .criticalError &#123; border: 1px #f00; &#125; .error.intrusion, .intrusion.extendError, .intrusion.seriousError, .intrusion.criticalError &#123; background-image: url("/image/hacked.png"); &#125; .error:hover, .extendError:hover, .seriousError:hover, .criticalError:hover &#123; color: #00b88d; &#125; 4.2 继承复合选择器12345678910111213/*scss*/.div1.div2 &#123; text-decoration: underline;&#125;.div3:hover &#123; text-decoration: overline;&#125;.extend1 &#123; @extend .div1.div2;&#125;.extend2 &#123; @extend .div3:hover&#125; 123456/*css*/.div1.div2, .extend1 &#123; text-decoration: underline; &#125;.div3:hover, .extend2 &#123; text-decoration: overline; &#125; 4.3 继承多个选择器1234567891011121314151617/*scss*/.error &#123; border: 1px #f00; background-color: #fdd;&#125;.attention &#123; font-size: 3em; background-color: #ff0;&#125;.seriousError &#123; // ===&gt; @extend .error; @extend .attention; border-width: 3px;&#125; 1234567891011/*css*/.error, .seriousError &#123; border: 1px #f00; background-color: #fdd; &#125;.attention, .seriousError &#123; font-size: 3em; background-color: #ff0; &#125;.seriousError &#123; border-width: 3px; &#125; 4.4 连续继承12345678910111213141516171819/*scss*/.error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125;.criticalError &#123; @extend .seriousError; position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%;&#125; 1234567891011121314/*css*/.error, .seriousError, .criticalError &#123; border: 1px #f00; background-color: #fdd; &#125;.seriousError, .criticalError &#123; border-width: 3px; &#125;.criticalError &#123; position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%; &#125; 3.4 mixin 指令@mixin 可以预先定义样式的代码块；@include 可以引入 @mixin 预定义的样式；该指令类似于 @extend 的继承效果，区别是@mixin指令预定义的样式编译后会自动去除，可以有效避免使用非语义化的类名； 1. @mixin 与 @include示例1：样式123456789101112131415/*scss*/@mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125;.page-title &#123; @include large-text; padding: 4px; margin-top: 10px;&#125; 12345678/*css*/.page-title &#123; font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px; &#125; 示例2：选择器 + 样式123456789/*scss*/@mixin silly-links &#123; a &#123; color: blue; background-color: red; &#125;&#125;@include silly-links; 1234/*css*/a &#123; color: blue; background-color: red; &#125; 示例3：复合使用1234567891011121314151617/*scss*/@mixin highlighted-background &#123; background-color: #fc0;&#125;@mixin header-text &#123; font-size: 20px;&#125;@mixin compound &#123; @include highlighted-background; @include header-text;&#125;.test &#123; @include compound&#125; 1234/*css*/.test &#123; background-color: #fc0; font-size: 20px; &#125; 2. 定义参数示例4：$arguments@mixin 可以定义参数，@include调用的时候传参；123456789101112/*scss*/@mixin sexy-border($color, $width) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue, 10px);&#125; 12345/*css*/p &#123; border-color: blue; border-width: 10px; border-style: dashed; &#125; 3. 指定参数的缺省值123456789/*scss*/@mixin left($value: 10px) &#123; float: left; margin-right: $value;&#125;p &#123; @include left;&#125; 1234/*css*/p &#123; float: left; margin-right: 10px; &#125; 4. $arg...示例5：$arg...可以用 $参数... 表示所有传入的参数1234567891011/*scss*/$b: box-shadow;@mixin box-shadow($shadows...) &#123; -moz-#&#123;$b&#125;: $shadows; -webkit-#&#123;$b&#125;: $shadows; #&#123;$b&#125;: $shadows;&#125;.shadows &#123; @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);&#125; 12345/*css*/.shadows &#123; -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; &#125; 3.5 条件语句、循环语句1. 条件语句@if...else... 条件判断，判断结果为 true 时赋值样式 示例1：123456789101112131415/*scss*/p &#123; @if 1 + 1 == 2 &#123; border: 1px solid; &#125; @if true &#123; background-image: url(''); &#125; @if 5 &lt; 3 &#123; border: 2px dotted; &#125; @if null &#123; border: 3px double; &#125;&#125; 1234/*css*/p &#123; border: 1px solid; background-image: url(""); &#125; 示例2：12345678910111213/*scss*/$type: monster;p &#123; @if $type == ocean &#123; color: blue; &#125; @else if $type == matador &#123; color: red; &#125; @else if $type == monster &#123; color: green; &#125; @else &#123; color: black; &#125;&#125; 123/*css*/p &#123; color: green; &#125; 2. 循环语句注意form...through与from ... to循环的范围 2.1 @for $var form...through...示例：from … through123456/*scss*/@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; 123456789/*css*/.item-1 &#123; width: 2em; &#125;.item-2 &#123; width: 4em; &#125;.item-3 &#123; width: 6em; &#125; 2.2 @for $var from...to...示例：from … to123456/*scss*/@for $i from 1 to 3 &#123; .item-to-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; 123456/*css*/.item-to-1 &#123; width: 2em; &#125;.item-to-2 &#123; width: 4em; &#125; 2.3 @each $var in ...@each 为 $var 循环所有 in 后面列出的值示例：@each … in …123456/*scss*/@each $animal in puma, sea-slug, egret, salamander &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/images/#&#123;$animal&#125;.png'); &#125;&#125; 123456789101112/*css*/.puma-icon &#123; background-image: url("/images/puma.png"); &#125;.sea-slug-icon &#123; background-image: url("/images/sea-slug.png"); &#125;.egret-icon &#123; background-image: url("/images/egret.png"); &#125;.salamander-icon &#123; background-image: url("/images/salamander.png"); &#125; 2.4 @while $var ...示例：while循环12345678/*scss*/$i: 6;@while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2;&#125; 123456789/*css*/.item-6 &#123; width: 12em; &#125;.item-4 &#123; width: 8em; &#125;.item-2 &#123; width: 4em; &#125; 2.5 条件 + 循环示例：12345678/*scss*///@for 后面的第一个$i 相当于参数，第二个$i 直接将变量的值拿过来用$i: 6;@for $i from 1 through $i &#123; .col-#&#123;$i&#125; &#123; width: $i/6*100% &#125;&#125; 相当于：1234567/*scss*/$i: 6;@for $j from 1 through $i &#123; .col-#&#123;$j&#125; &#123; width: $j/6*100% &#125;&#125; 123456789101112131415161718/*css*/.col-1 &#123; width: 16.6666666667%; &#125;.col-2 &#123; width: 33.3333333333%; &#125;.col-3 &#123; width: 50%; &#125;.col-4 &#123; width: 66.6666666667%; &#125;.col-5 &#123; width: 83.3333333333%; &#125;.col-6 &#123; width: 100%; &#125; 3.6 自定义函数12345678910111213141516171819202122/*scss*/$grid-width: 40px;$gutter-width: 10px;@function test($a) &#123; @return $a + 10;&#125;@function grid-width($n) &#123; $hello: 1px; @for $i from 1 through $n &#123; $hello: $hello + $i; &#125; @if $hello &gt; 10 &#123; $hello: 15px; &#125; @return $hello + test(2);&#125;#sidebar &#123; width: grid-width(5);&#125; 123/*css*/#sidebar &#123; width: 27px; &#125; （教程结束） 复习 如果你对着教程自己有在操作，那么你可以再抽时间过一遍阮一峰老师的SASS用法指南，配合食用味道更佳哦~ （完） 参考SASS用法指南-阮一峰SASS中文文档-bootcss]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Blog！]]></title>
    <url>%2F2017%2F08%2F19%2FHello%20Blog%EF%BC%81%2F</url>
    <content type="text"><![CDATA[一、为什么要写博客不知道大家写博客的理由都是什么，反正我的理由很简单，不外乎以下几点： 记录自己的学习笔记； 记录自己的生活动态； 分享一些有趣的东西； 一个全平台的收藏夹； 处女座来强行凑个数； 二、写博客的好处我的天！这个标题让我想起还在学校的时候，本宝宝是经管学院市场营销专业的QAQ，还记得网络营销的第一课就是经典的企业博客营销，所以你有事没事分享点有趣的东西骗骗粉也不错吖，指不定哪天就火了呢~尤其是在目前这个粉丝经济尤为突出的市场环境下，万一你一不小心火了，博客就是你的招牌，你说是不咯？ 当然本宝宝并不是冲着营销号方向走的=。=纯粹是为了记录自己的进步与二逼的想法QAQ 强化记忆！个人觉得这是写博客对自己最大的好处了。 学习上以前没有记笔记的习惯，但是现在要转行做码农辣，学习了一段时候后才发现，不记笔记是硬伤！不记笔记是硬伤！不记笔记是硬伤！ 重要的事情说三遍。不知道其他的圈子是什么样的 ，至少以我目前浅薄的目光来看前端圈，琳（luan）琅（qi）满（ba）目（zao）的API，除非有着超超超超一流的记忆能力，否则你很难记住一些奇奇怪怪的东西。 生活上可以记录一些有意思的生活动态，比如说游记、菜谱、随笔、灵感等。指不定某天冒出个想法改变了自己的未来呢，哈哈。 三、写好博客的秘诀贵在坚持，仅此而已。自己也是第一次开始尝试写个人博客，就先这样吧=。= （完）]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
