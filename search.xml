<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Albert's Favorites]]></title>
    <url>%2F2017%2F08%2F25%2FAlbert-s-Favorites%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[用CSS3实现一个立方体]]></title>
    <url>%2F2017%2F08%2F25%2F%E7%94%A8CSS3%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AB%8B%E6%96%B9%E4%BD%93%2F</url>
    <content type="text"></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详说 Cookie, LocalStorage 与 SessionStorage]]></title>
    <url>%2F2017%2F08%2F24%2F%E8%AF%A6%E8%AF%B4-Cookie-LocalStorage-%E4%B8%8E-SessionStorage%2F</url>
    <content type="text"><![CDATA[Cookie, LocalStorage 与 SessionStorage具体 Web Storage API 的使用可以参考 MDN的文档 基本概念CookieCookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。 localStoragelocalStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。 特性 Chrome Firefox (Gecko) Internet Explorer Opera Safari (WebKit) localStorage 4 3.5 8 10.50 4 sessionStorage 5 2 8 10.50 4 sessionStoragesessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。 三者的异同 特性 Cookie localStorage sessionStorage 数据的生命期 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 一般为5MB &lt;= 同localStorage 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 &lt;= 同localStorage 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 &lt;= 同localStorage 应用场景有了对上面这些差别的直观理解，我们就可以讨论三者的应用场景了。 因为考虑到每个 HTTP 请求都会带着 Cookie 的信息，所以 Cookie 当然是能精简就精简啦，比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。曾经还使用 Cookie 来保存用户在电商网站的购物车信息，如今有了 localStorage，似乎在这个方面也可以给 Cookie 放个假了~ 而另一方面 localStorage 接替了 Cookie 管理购物车的工作，同时也能胜任其他一些工作。比如HTML5游戏通常会产生一些本地数据，localStorage 也是非常适用的。如果遇到一些内容特别多的表单，为了优化用户体验，我们可能要把表单页面拆分成多个子页面，然后按步骤引导用户填写。这时候 sessionStorage 的作用就发挥出来了。 安全性的考虑需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为。所以千万不要用它们存储你系统中的敏感数据。 参考资料 what is the difference between localStorage, sessionStorage, session and cookie? HTML5 localStorage security 维基百科 - Cookie Web Storage API 浏览器本地数据（sessionStorage、localStorage、cookie）与server端数据 HTMl5的sessionStorage和localStorage HTML5 LocalStorage 本地存储 转自：详说 Cookie, LocalStorage 与 SessionStorage]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[低版本IE支持HTML5]]></title>
    <url>%2F2017%2F08%2F24%2F%E4%BD%8E%E7%89%88%E6%9C%ACIE%E6%94%AF%E6%8C%81HTML5%2F</url>
    <content type="text"><![CDATA[如何让低版本的 IE 支持 HTML5新标签1. 利用条件注释针对 IE 来调用这个 JS 文件。Opera，FireFox 等其他非 IE 浏览器就会忽视这段代码，也不会存在 http 请求。引用 html5shiv.js 文件，代码内容可以自己下载下来看。 BootCDN-html5shiv 123&lt;!--[if lt IE 9]&gt; &lt;script src="bower_components/html5shiv/dist/html5shiv.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 将以上代码放到 head 标签区间，由于现在国内网络环境（你懂的QAQ），直接引入外部 JS会让网页打开非常慢，所以建议大家先下载到服务器上，再进行本地文件的引用。 更多细节参考：The HTML5 Shiv 2. 用JS创建元素，然后添加CSS属性：1234567// 页面头部(function () &#123; var a = ['article', 'aside', 'details', 'figcaption', 'figure', 'footer', 'header', 'hgroup', 'nav', 'section']; for (var i = 0, j = a.length; i &lt; j; i++) &#123; document.createElement(a[i]); &#125;&#125;)(); 同理，可以用类数组转为数组： 12345678910111213// 页面头部function createHtml5Mark() &#123; // arguments 序列化成数组 var args = Array.prototype.slice.call(arguments, 0); argLen = args.length, doc = document; // 循环数据创建元素 for (var i = 0; i &lt; argLen; i++) &#123; doc.createElement(args[i]); &#125;&#125;createHtml5Mark('article', 'aside', 'details', 'figcaption', 'figure', 'footer', 'header', 'hgroup', 'nav', 'section'); 最后，需要在CSS添加属性： 1section,article,nav,header,footer&#123;display:block;&#125; （完）]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>IE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5入坑简单概览]]></title>
    <url>%2F2017%2F08%2F24%2FHTML5%E5%85%A5%E5%9D%91%E7%AE%80%E5%8D%95%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[HTML5 概览 本文概览：HTML5 新特性；标签的变化；属性的变化；新增的标签 HTML5是什么？ HTML5是超文本标记语言的第五次重大修改，2014年10月29日标准规范制定完成。 设计目的 HTML5 的设计目的是为了在移动设备上支持多媒体。新的语法特征被引进以支持这一点，如 video 、audio 和 canvas 标记。 HTML5 还引进了新的功能，可以真正改变用户与文档的交互方式，包括： 新的解析规则增强了灵活性 新属性 淘汰过时的或冗余的属性 一个HTML5文档到另一个文档间的拖放功能 离线编辑 信息传递的增强 详细的解析规则 多用途互联网邮件扩展（MIME）和协议处理程序注册 在SQL数据库中存储数据的通用标准（Web SQL） 有哪些新特性？MDN-HTML5 1. 语义特性HTML5 赋予网页更好的意义和结构。更加丰富的标签将随着对 RDFa，微数据与微格式等方面的支持，构建对程序、对用户都更有价值的数据驱动的Web。 2. 本地存储特性基于 HTML5 开发的网页APP拥有更短的启动时间，更快的联网速度，这些全得益于 HTML5 APP Cache ，以及本地存储功能。Indexed DB（HTML5本地存储最重要的技术之一）和 API 说明文档。 3. 设备兼容特性从 Geolocation 功能的API文档公开以来，HTML5 为网页应用开发者们提供了更多功能上的优化选择，带来了更多体验功能的优势。HTML5 提供了前所未有的数据与应用接入开放接口。使外部应用可以直接与浏览器内部的数据直接相连，例如视频影音可直接与microphones及摄像头相联。 4. 连接特性更有效的连接工作效率，使得基于页面的实时聊天，更快速的网页游戏体验，更优化的在线交流得到了实现。HTML5 拥有更有效的服务器推送技术，Server-Sent Events 和 WebSocket 就是其中的两个特性，这两个特性能够帮助我们实现服务器将数据“推送”到客户端的功能。 5. 网页多媒体特性 支持网页端的 audio 、video 等多媒体功能。 三维、图形及特效特性（Class: 3D, Graphics &amp; Effects） 基于 SVG、Canvas、WebGL 及CSS3 的 3D 功能，用户会惊叹于在浏览器中，所呈现的惊人视觉效果。 6. 性能与集成特性没有用户会永远等待你的Loading —— HTML5会通过 XMLHttpRequest2 等技术，解决以前的跨域等问题，帮助您的Web应用和网站在多样化的环境中更快速的工作。 7. CSS3特性在不牺牲性能和语义结构的前提下，CSS3 中提供了更多的风格和更强的效果。此外，较之以前的Web排版，Web的开放字体格式（WOFF）也提供了更高的灵活性和控制性。 关于标签1. 标签变化 DOCTYPE 1&lt;!DOCTYPE html&gt; 文档编码 1&lt;meta charset=&quot;UTF-8&quot; /&gt; 标签结尾 在 HTML5 中对于一些标签不再是必要的：（但是建议每个标签都要结束）li , dt , dd , p , rt , rp , optgroup , option , colgroup , thead , tbody , tfoot , tr , td , th 自结束的标签最后的 / 也不再必要img , input , br , hr 等 2. 属性变化2.1 具有 boolean 值的属性对于具有 boolean 值的属性，例如 disable 和 readonly 等，只写属性不写属性值时，其默认值为 true1234&lt;!-- 以下三条 checked 全部为选中状态 --&gt;&lt;input type=&quot;checkbox&quot; checked &gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; &gt;&lt;input type=&quot;checkbox&quot; checked=&quot;&quot; &gt; 2.2 省略属性值的引号属性值可以用单引号或者双引号，在属性值不包括 &lt;、&gt;、=、&#39;、&quot;时可以忽略引号12&lt;!-- 这里的text就省略了引号 --&gt;&lt;input type=text &gt; 2.3 input 新增 type注意：日期与时间相关的 type 目前均存在bugMDN：HTML元素参考-input1234567891011121314151617181920&lt;!-- 提交表单会自动验证是否为邮箱、电话、URL --&gt;&lt;input type=&quot;email&quot;&gt;&lt;input type=&quot;tel&quot;&gt;&lt;input type=&quot;url&quot;&gt;&lt;!-- 非数字无法输入 --&gt;&lt;input type=&quot;number&quot;&gt;&lt;!-- 一个指示范围的横向滚动条 --&gt;&lt;input type=&quot;range&quot;&gt;&lt;!-- 搜索框 --&gt;&lt;input type=&quot;search&quot;&gt;&lt;!-- 日期与时间（不建议使用） --&gt;&lt;input type=&quot;date&quot;&gt;&lt;input type=&quot;month&quot;&gt;&lt;input type=&quot;week&quot;&gt;&lt;input type=&quot;time&quot;&gt;&lt;input type=&quot;datetime-local&quot;&gt; 2.4 移除的元素 能被CSS替代的元素basefont , big , center , font , s , u , tt ,strike 不再使用frame框架frame , frameset , noframes 其它rb =&gt; rubyacronym =&gt; abbrdir =&gt; ulisindex =&gt; inputlisting =&gt; prexmp =&gt; codenextid =&gt; CUIDSplaintext =&gt; text/plain 2.5 新增属性 全局属性contentEditable , designMode , hidden , spellcheck , tabindex 表单相关autofocus , placeholder , form , required , novalidateformaction , formenctype , formmethod , formtarget , formnovalidate 链接相关a和area新增medialink新增sizes属性base新增target属性area新增hreflang和rel 其它ol新增reversedmeta新增charsetmenu新增type和labelstyle新增scopedscript新增asynchtml新增manifestiframe新增sandbox， seamless， srcdoc 2.6 废弃属性废弃的元素和属性 3. 新增标签 元素 描述 canvas 标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API audio 定义音频内容 video 定义视频（video 或者 movie） source 定义多媒体资源 &lt;video&gt; 和&lt;audio&gt; embed 定义嵌入的内容，比如插件 track 为诸如 &lt;video&gt; 和 &lt;audio&gt; 元素之类的媒介规定外部文本轨道 datalist 定义选项列表。与 input 元素配合使用该元素，来定义 input 可能的值 keygen 规定用于表单的密钥对生成器字段 output 定义不同类型的输出，比如脚本的输出 article 定义页面正文内容 aside 定义页面内容之外的内容 bdi 设置一段文本，使其脱离其父元素的文本方向设置 command 定义命令按钮，比如单选按钮、复选框或按钮 details 用于描述文档或文档某个部分的细节 dialog 定义对话框，比如提示框 summary 标签包含 details 元素的标题 figure 规定独立的流内容（图像、图表、照片、代码等等） figcaption 定义 &lt;figure&gt; 元素的标题 footer 定义 section 或 document 的页脚 header 定义了文档的头部区域 mark 定义带有记号的文本 meter 定义度量衡。仅用于已知最大和最小值的度量 nav 导航 progress 定义任何类型的任务的进度 ruby 定义 ruby 注释（中文注音或字符） rt 定义字符（中文注音或字符）的解释或发音 rp 在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容 section 定义文档中的节（section、区段） time 定义日期或时间 wbr 规定在文本中的何处适合添加换行符 参考 w3school：HTML 参考手册 MDN：HTML5 MDN：HTML5 标签列表 HTML5 学习笔记简明版 知乎：HTML5 到底是什么？ （完）]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack：bundle.js解析]]></title>
    <url>%2F2017%2F08%2F22%2Fwebpack%EF%BC%9Abundle-js%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础入坑（二）]]></title>
    <url>%2F2017%2F08%2F22%2Fwebpack%E5%9F%BA%E7%A1%80%E5%85%A5%E5%9D%91%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[webpack基础入坑（二 接上回 上回主要操作了指南的 Installation 与 GettingStarted 这两部分，这时候我们大概能猜出 webpack 的某些功能了： 使用各种 loader 加载不同的资源 把所有资源打包起来 bundle.js我们可以阅读一下最后生成的 bundle.js（可以写几个简单的JS文件打包，参数部分看起来会更方便一些）bundle.js 是一个并不复杂的自执行函数（每一行都有代码注释）容主要由两部分组成： webpackBootstrap 函数入口，主体部分打包的功能就在这部分，有兴趣的话可以看一下每一行的功能，大致就是把每个模块call一下，然后把模块保存到 installedModules 里，然后需要用到的时候可以直接调用。 参数部分传入一个数组，数组的每一项都是一个模块，每个模块都有一个独立的模块ID，模块需要其他依赖时直接通过模块ID来调用。 就此打住，这篇文章主题并不在讲 bundle.js。 JS 压缩webpack打包之后我们发现 dist/bundle.js 有800KB，因为我们引入了 lodash 和 jQuery 这两个库，但是并没有压缩代码，那么如何压缩呢？方法很多，其中最简单的一种就是使用 webpack 自带的压缩插件 UglifyJsPlugin： 我们修改一下 npm scripts 的配置，添加一个字段启动webpack的压缩功能：1"build-p": "webpack -p" 重新运行命令打包文件，得到的 bundle.js 就是一个压缩过的文件。 更多使用方法参考这里：UglifyJS 1npm run build-p 运行帮助命令查看 -p 参数的具体功能1234./node_modules/.bin/webpack --help# 找到如下介绍-p shortcut for --optimize-minimize --define process.env.NODE_ENV="production" 123webpack -p# 相当于以下命令webpack --optimize-minimize --define process.env.NODE_ENV="'production'" 它会执行如下步骤： 使用 UglifyJsPlugin 进行 JS 文件压缩 运行 LoaderOptionsPlugin 设置 NodeJS 环境变量，触发某些 package 包，以不同的方式进行编译。 开发环境每次改完代码都要运行一次打包命令是不是很烦人？没关系，webpack 肯定也考虑到了，于是乎我们就可以通过 webpack 自带的监听功能自动监听文件变动然后执行编译。 Development 这一章节就是专门介绍如何快速开发的。 1. 调整编辑器首先，我们先拉到文章底部，按照它的要求调整我们的编辑器： 2. Source Maps调整好编辑器后我们再返回页面顶部，找到Source Maps功能：将编译后的代码映射回原始源代码，如果某个源文件中存在错误，source map会追踪到错误和警告在源代码中的原始位置，方便代码调试。123456789 var path = require('path'); module.exports = &#123; entry: './src/index.js',+ devtool: 'inline-source-map', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125; &#125;; 故意改错源文件中的代码，然后运行 npm run build 打包，然后在浏览器控制台你会发现 bundle.js 的报错会指向源文件。 3. Watch Mode再修改一下 npm scripts 的配置，添加一个字段以启动监听模式：1"watch": "webpack --watch" 运行 npm run watch12npm run watch# 运行成功直接编译然后光标继续闪动表示监听中... 如果你想要退出，请按 Ctrl+c 好了现在我们试一下这个监听功能，我们随便修改一个文件内容，按 Ctrl+s 保存。 切换回命令行，你会发现 webpack 自动执行了编译操作。 4. webpack-dev-server此功能能够让你的浏览器自动刷新，是不是棒棒哒~（虽然很多编辑器也都有这个功能=。=） 按照老规矩，第一步添加修改 npm scripts 的配置，添加一个字段以启动开发服务器：1"start": "webpack-dev-server --open" 修改 webpack.config.js ，在 module.exports 对象中添加一个字段 devServer ，告知 webpack-dev-server 将指定目录下的文件作为可访问文件。123devServer: &#123; contentBase: './'&#125;, 运行 npm run start 启动服务器，然后浏览器就会自动打开 http://localhost:8080/ ，你会看到 index.html 页面。1npm run start 接下来如果我们改一下 src/index.js，你就会发现 bundle.js 自动打包 http://localhost:8080/ 自动刷新 注意：期间 dist/bundle.js 不会自动变化，在部署代码之前，依然要运行 npm run build 才行。 5. webpack-dev-middleware功能与 webpack-dev-server 类似，新手入坑不建议使用 webpack-dev-middleware （完）]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础入坑（一）]]></title>
    <url>%2F2017%2F08%2F22%2Fwebpack%E5%9F%BA%E7%A1%80%E5%85%A5%E5%9D%91%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[webpck 基础入坑（一）安装这里有webpack发布的所有版本：https://github.com/webpack/webpack/releases 当然你也可以直接通过 npm 命令安装：1npm install --save-dev webpack 如果你要体验最新版本的webpack请使用以下命令安装：1npm install webpack@beta 文档Google 搜索 webpack 第一条结果：https://webpack.github.io/ 页面中指明了三个链接： documentation - 文档所有功能的罗列，文档一般不是按照从易到难的顺序给出，但是肯定包含的几乎所有功能的介绍。 introducation - 介绍简单说明了 webpack 的作用和基本概念。 tutorial - 教程比较容易上手，教你一步一步自学 webpack 需要中文的小伙伴请点这里：https://doc.webpack-china.org/ 实践（抄写）点开 tutorial - 教程 ，然后一行一行地复制里面的命令：123456# 新建并进入 webpack-demo 目录mkdir webpack-demo &amp;&amp; cd webpack-demo# npm 初始化一个 package.jsonnpm init -y# 安装 webpack 作为开发依赖npm install --save-dev webpack ps: 安装过慢请自行切换国内淘宝源 按教程上说的做123456# 新建一个index.hrmltouch index.html# 新建一个src文件夹mkdir src# 在src文件夹内新建一个index.jscd src &amp;&amp; touch index.js 现在你的目录结构是这样的：12345webpack-demo|- package.json|- index.html|- /src |- index.js ok，咱们继续抄12345678910function component() &#123; var element = document.createElement('div'); // Lodash, currently included via a script, is required for this line to work element.innerHTML = _.join(['Hello', 'webpack'], ' '); return element;&#125;document.body.appendChild(component()); 注意上面代码中的 _.join ，这个 _ 实际上是 lodash 暴露的全局变量。 编辑 webpack-demo 目录下的 index.html123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/lodash@4.16.6&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;./src/index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 为了使用 lodash，HTML 使用 script 引入了 lodash v4.16.6。 教程里说这样引用逼格太低，我们可以用更高端的方法引入安装 lodash 为必要依赖123# 请先确保命令行当前所在目录是 webpack-demonpm install --save lodash# 上面命令可以简写成 npm i -S lodash 好了，lodash 的源代码已经下载到 ./node_modules/lodash/ 目录中。 然后在 src/index.js 的第一行添加12import _ from 'lodash';// 然后是function component () &#123; 意思是从 lodash 里得到默认导出，并将默认导出命名为 _，这个 _ 可以换成任何一个其他的变量名。 然后按照教程说的把 index.html 也改了12345678910 &lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt;- &lt;script src="https://unpkg.com/lodash@4.16.6"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;- &lt;script src="./src/index.js"&gt;&lt;/script&gt;+ &lt;script src="./dist/bundle.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 然后命令行输入：1./node_modules/.bin/webpack app/index.js dist/bundle.js 12# 如果你是全局安装的webpack直接运行以下代码webpack app/index.js dist/bundle.js 在浏览器中打开 index.html，如果你看到’Hello webpack’ 说明运行成功。 这是目前的文件结构：1234567|- src |- index.js|- dist |- bundle.js|- index.html|- node_modules/|- package.json ./node_modules/.bin/webpack app/index.js dist/bundle.js 将 src/index.js 转化成 dist/bundle.js index.html 引用的是 dist/bundle.js lodash 安装在 node_modules 里，在index.js中用import引用 webpack 也安装在 node_modules里，./node_modules/.bin/webpack 是一个可执行文件 webpack、lodash 的版本号都被写在 package.json 里 修改引入 jQuery如果我们要在页面中引入 jQuery，先安装：12# 确定你在 webpack-demo 目录npm i -S jquery 以上命令相当于：1npm install --save jquery 然后 jquery 模块就被下载到了 node_modules 中。 然后我们继续在 src./index.js 中引入 jquery123456789101112131415 import _ from 'lodash'+import j from 'jquery' function component () &#123;- var element = document.createElement('div');+ var element = j('&lt;div&gt;&lt;/div&gt;');- element.innerHTML = _.join(['Hello','webpack'], ' ');+ element.html(_.join(['Hello','webpack'], ' '))- return element;+ return element.get(0); &#125; document.body.appendChild(component()); 然后再次运行1./node_modules/.bin/webpack app/index.js dist/bundle.js 打开 index.html。如果你看到 “Hello webpack”，那就说明 jquery 也成功引入，只不过我们把它命名为 j，显然命名为 $ 更符合习惯，你可以自己改一下试试！ 改进上面每次都要运行 ./node_modules/.bin/webpack app/index.js dist/bundle.js 实在是烦人，教程里给出了方法：123# 确保你在项目根目录 webpack-demo# 新建一个 webpack.config.js 文件touch webpack.config.js 然后编辑它：123456789var path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;; output 出口设置，必须是绝对路径，因此在第一行引入 path 模块，方便路径的设置； entry 入口设置，可以是相对路径； filename 输出的文件名； 然后命令行运行：1./node_modules/.bin/webpack --config webpack.config.js 不过这句话依然很长，每次输入很麻烦，教程又教了一个办法：使用 npm-scripts 修改 package.json12345 "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",+ "build": "webpack" &#125;, "keywords": [], 然后命令行运行：1npm run build 说明运行 npm run build 就等于运行 node_modules 里的 webpack 可执行文件，这个可执行文件会找到项目根目录下的 webpack.config.js 并按照其中的设置执行对应的操作 最后再看一下文件目录：123456789webpack-demo|- /src |- index.js|- /dist |- bundle.js|- index.html|- webpack.config.js|- /node_modules|- package.json （完）]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章彻底入门 SCSS]]></title>
    <url>%2F2017%2F08%2F21%2F%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%BD%BB%E5%BA%95%E5%85%A5%E9%97%A8%20SCSS%2F</url>
    <content type="text"><![CDATA[SCSS 起飞指南 写在前面：本文看起来比较长，其实是罗列了比较多的示例代码，如果你能坚持看完，对照学习，相信两个小时后你就能自己起飞愉快地去写scss了。 （一）Sass 与SCSS的区别1.1 什么是Sass Sass 是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。 1.2 Sass 与SCSS有什么区别 Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass ，两者之间不同之处有以下两点： 文件扩展名不同：Sass 是以 .sass 后缀为扩展名SCSS 是以 .scss 后缀为扩展名 语法书写方式不同：Sass 是以严格的缩进式语法规则来书写，不带大括号 {} 和分号 ;SCSS 的语法书写和我们的 CSS 语法书写方式非常类似 建议使用后缀名为 scss 的文件，以避免 sass 后缀名的严格格式要求报错。 （二）安装和使用2.1 安装 Sass 基于Ruby语言，但两者语法之间没有关系。使用Sass 无需先学习ruby，但是必须先安装Ruby，然后再安装Sass 。 macbook自带ruby环境，直接打开终端运行 gem 命令安装sass 即可； windows需要先自行安装ruby，然后在 CMD 或其他命令行工具中运行安装命令； ruby官网 安装时请勾选Add Ruby executables to your PATH这个选项，添加环境变量，不然以后使用编译软件的时候会提示找不到ruby环境 正确安装完ruby依赖后，安装sass： 1gem install sass 安装sass完成后查看版本测试安装有没有成功： 123sass -v# 安装成功会打印版本号Sass 3.5.1 (Bleeding Edge) 如上已经安装成功。但因为国内网络（不可描述）的问题导致gem源间歇性中断，因此我们需要更换gem源。 使用淘宝的gem源 https://ruby.taobao.org/： 123456789101112# 1.删除原gem源gem sources --remove https://rubygems.org/# 2.添加国内淘宝源gem sources -a https://ruby.taobao.org/# 3.打印是否替换成功gem sources -l# 4.更换成功后打印如下*** CURRENT SOURCES ***https://ruby.taobao.org/ 2.2 使用 windows 用户注意：编译 scss 文件中如果存在中文，可能出现类似于这样的报错：1`Syntax error: Invalid GBK character "\xE5"` 请一定不要惊慌，找到类似于下面的目录：1C:\Ruby24-x64\lib\ruby\gems\2.4.0\gems\sass-3.5.1\lib\sass 然后在该目录中找到 engine.rb ，编辑添加一行代码：1Encoding.default_external = Encoding.find('utf-8') 编译sass sass 编译有很多种方式，如命令行编译模式、sublime插件SASS-Build、编译软件koala、前端自动化软件codekit、Grunt打造前端自动化工作流grunt-sass、Gulp打造前端自动化工作流gulp-ruby-sass等。 命令行编译; 1234567891011# 1. 直接打印转化后的代码sass test.scss# 2. 单文件转换命令sass input.scss output.css# 3.1 单文件监听命令,实时转换sass --watch input.scss:output.css# 3.2 如果你有很多的sass文件，也可以监听整个目录：sass --watch app/sass:public/stylesheets SASS提供四个编译风格的选项： 1234* nested：嵌套缩进的css代码，它是默认值。* expanded：没有缩进的、扩展的css代码。* compact：简洁格式的css代码。* compressed：压缩后的css代码。 操作命令：12# 添加指令 --style [编译风格]sass test.sass test.css --style compressed 四种编译排版演示:123456789//未编译样式.box &#123; width: 300px; height: 400px; &amp;-title &#123; height: 30px; line-height: 30px; &#125;&#125; nested 嵌套缩进的css代码 1234567/*编译过后样式*/.box &#123; width: 300px; height: 400px; &#125; .box-title &#123; height: 30px; line-height: 30px; &#125; expanded 没有缩进的、扩展的css代码 123456789/*编译过后样式*/.box &#123; width: 300px; height: 400px;&#125;.box-title &#123; height: 30px; line-height: 30px;&#125; compact 简洁格式的css代码 123/*编译过后样式*/.box &#123; width: 300px; height: 400px; &#125;.box-title &#123; height: 30px; line-height: 30px; &#125; compressed 压缩后的css代码 12/*编译过后样式*/.box&#123;width:300px;height:400px&#125;.box-title&#123;height:30px;line-height:30px&#125; （三）基本用法 建议先下载示例代码，然后跟着走一遍，结束之后你会大致掌握Sass的基本用法 本部分主要分为六块，目录中未提及的变量、注释等其他基础用法已包含在其中。 Sass的官方网站，提供了一个在线转换器。你可以在那里，试运行下面的各种例子。 注： 以下所有代码块的第一行注释/*SCSS*/ 和 /*CSS*/ 是人为添加的！ 以下所有编译风格默认 nested 如果命令行出现类似如下提示说明该方法即将弃用，有时会向下面那样提示你用其他方法代替：123DEPRECATION WARNING on line 77 of input/calculate.scss:The operation `#123123 plus #040506` is deprecated and will be an error in future versions.Consider using Sass's color functions instead. 3.1 嵌套规则1. 选择器嵌套 父子层级关系明显； 代码具有良好的可读性； 示例：123456789101112/*SCSS*/#a &#123; .a-1 &#123; background: yellow; .child &#123; font-size: 12px; .child-1 &#123; color: red &#125; &#125; &#125;&#125; 1234567/*CSS*/#a .a-1 &#123; background: yellow; &#125; #a .a-1 .child &#123; font-size: 12px; &#125; #a .a-1 .child .child-1 &#123; color: red; &#125; 2. 引用父选择符： &amp;&amp; 在编译时将被替换为父选择符，输出到 CSS 中 示例：1234567891011/*scss*/.hello &#123; .dropdown &#123; display: none; &#125; &amp;:hover &#123; .dropdown &#123; display: block; &#125; &#125;&#125; 12345/*css*/.hello .dropdown &#123; display: none; &#125;.hello:hover .dropdown &#123; display: block; &#125; 3. 属性嵌套某些属性具有可选参数的，类似于 border 、font 、background 这样的，可以让你少复制自己的代码，当然直接使用缩写更方便一些，但使用属性嵌套的方法可读性更佳不是吗？ 示例：123456789101112/*scss*/.funky &#123; font: &#123; family: fantasy; size: 30em; weight: bold; &#125; border: &#123; radius: 20px; color: red; &#125;&#125; 1234567/*css*/.funky &#123; font-family: fantasy; font-size: 30em; font-weight: bold; border-radius: 20px; border-color: red; &#125; 4. 注释规则/*标准的CSS注释*/ 编译后依旧存在//单行注释 编译后被删除/*!重要注释*/在/*后面加一个感叹号 ! ，表示这是重要注释。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。 示例： 1234/*scss*//*标准的CSS注释*///单行注释/*!重要注释*/ 123/*css*//*标准的CSS注释*//*!重要注释*/ 3.2 计算规则1. 定义变量 $varSCSS中所有的变量由一个 $ 符号定义12345/*scss*/$width: 10px;#main &#123; width: $width;&#125; 123/*css*/#main &#123; width: 10px; &#125; 2. 插值: #{}将 #{里面的值}当做字符串插入1234567/*scss*/$name: foo;$attr: border;p.#&#123;$name&#125; &#123; #&#123;$attr&#125;-color: blue; : "hello world #&#123;$name&#125;"&#125; 1234/*css*/p.foo &#123; border-color: blue; : "hello world foo"; &#125; 在文本字符串中，#{} 形式的表达式可以被用来在字符串中添加动态值，空值会被视作空字符串：12345678/*scss*/p:before &#123; : "I ate #&#123;5 + 10&#125; pies!";&#125;$value: null;p:before &#123; : "I ate #&#123;$value&#125; pies!";&#125; 123456/*css*/p:before &#123; : "I ate 15 pies!"; &#125;p:before &#123; : "I ate pies!"; &#125; 3. +、-、*、/ 的运算 在SCSS中+ 、- 、* 的运算方法与日常使用相同，需要单位的还请都带上你的单位； / 除法运算比较特殊，直接使用最后编译出来的结果可能并不是你日常所想的那样，其特殊性大致分为三种情况，下面的代码演示中已一一说明； 圆括号 () 可以改变运算顺序； 1234567891011/*scss*//*加减法运算*/p &#123; width: 1px + 8px; height: 10px - 2px;&#125;/*乘法运算*/div &#123; width: 3px * 5; height: 2px + 6px * 3;&#125; 12345678910/*css*//*加减法运算*/p &#123; width: 9px; height: 8px; &#125;/*乘法运算*/div &#123; width: 15px; height: 20px; &#125; 圆括号 () 变运算顺序：1234/*scss*/p &#123; width: (1em + 2em) * 3;&#125; 123/*css*/p &#123; width: 9em; &#125; 除法运算比较特殊：在以下三种情况中，/ 会被解释为除法运算。 覆盖了绝大多数真正使用除法运算的情况。 这些情况是： 如果数值或它的任意部分是存储在一个变量中或是函数的返回值。 如果数值被圆括号包围。 如果数值是另一个数学表达式的一部分 12345678910/*scss*//*除法运算*/p &#123; font: 10px/8px; // 纯 CSS，不是除法运算，兼容IE8的写法 $width: 1000px; width: $width/2; // 使用了变量，是除法运算 line-height: round(3.5)/2; // 使用了函数，是除法运算 height: (500px/2); // 使用了圆括号，是除法运算 margin-left: 5px + 8px/2px; // 使用了加（+）号，是除法运算&#125; 1234567/*css*/p &#123; font: 10px/8px; width: 500px; line-height: 2; height: 250px; margin-left: 9px; &#125; 如果你希望在纯 CSS 中使用 变量 和 /， 你可以用 #{} 包住 变量 。 例如：123456/*scss*/p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125; 123/*css*/p &#123; font: 12px/30px; &#125; 3.3 @import@media@extend 指令1. 引入 @import@import &quot;basic&quot;：查找当前目录下的 basic.scss 或者 basic.sass 引入到当前文件中1234567891011121314/*scss*/@import "basic";//basic.sass内容如下//#a &#123;// .a-1 &#123;// background: yellow;// .child &#123;// font-size: 12px;// .child-1 &#123;// color: red// &#125;// &#125;// &#125;//&#125; 1234567/*css*/#a .a-1 &#123; background: yellow; &#125; #a .a-1 .child &#123; font-size: 12px; &#125; #a .a-1 .child .child-1 &#123; color: red; &#125; 直接 @import test.css 相当于原生CSS的 @import 引用12/*scss*/@import "test.css"; 12/*css*/@import url(test.css); 2. 嵌套 @import有助于创建一个新的命名空间123456789101112131415/*scss*/.example &#123; @import "basic.scss";&#125;//basic.sass内容如下//#a &#123;// .a-1 &#123;// background: yellow;// .child &#123;// font-size: 12px;// .child-1 &#123;// color: red// &#125;// &#125;/ 12345678/*css*/.example &#123;&#125; .example #a .a-1 &#123; background: yellow; &#125; .example #a .a-1 .child &#123; font-size: 12px; &#125; .example #a .a-1 .child .child-1 &#123; color: red; &#125; 3. 媒体查询 @media用法与原生CSS一样123456789101112/*scss*/.father &#123; .sidebar &#123; width: 300px; @media screen and (orientation: landscape) &#123; width: 500px; .hello &#123; font-size: 20px &#125; &#125; &#125;&#125; 12345678/*css*/.father .sidebar &#123; width: 300px; &#125; @media screen and (orientation: landscape) &#123; .father .sidebar &#123; width: 500px; &#125; .father .sidebar .hello &#123; font-size: 20px; &#125; &#125; 4. 继承 @extend使用 @extend 可以让一个选择器继承另一个选择器 4.1 继承单个选择器12345678910111213/*scss*/.error &#123; border: 1px #f00; &amp;.intrusion &#123; background-image: url("/image/hacked.png"); &#125; &amp;:hover &#123; color: #00b88d; &#125;&#125;.extendError &#123; @extend .error;&#125; 1234567/*css*/.error, .extendError, .seriousError, .criticalError &#123; border: 1px #f00; &#125; .error.intrusion, .intrusion.extendError, .intrusion.seriousError, .intrusion.criticalError &#123; background-image: url("/image/hacked.png"); &#125; .error:hover, .extendError:hover, .seriousError:hover, .criticalError:hover &#123; color: #00b88d; &#125; 4.2 继承复合选择器12345678910111213/*scss*/.div1.div2 &#123; text-decoration: underline;&#125;.div3:hover &#123; text-decoration: overline;&#125;.extend1 &#123; @extend .div1.div2;&#125;.extend2 &#123; @extend .div3:hover&#125; 123456/*css*/.div1.div2, .extend1 &#123; text-decoration: underline; &#125;.div3:hover, .extend2 &#123; text-decoration: overline; &#125; 4.3 继承多个选择器1234567891011121314151617/*scss*/.error &#123; border: 1px #f00; background-color: #fdd;&#125;.attention &#123; font-size: 3em; background-color: #ff0;&#125;.seriousError &#123; // ===&gt; @extend .error; @extend .attention; border-width: 3px;&#125; 1234567891011/*css*/.error, .seriousError &#123; border: 1px #f00; background-color: #fdd; &#125;.attention, .seriousError &#123; font-size: 3em; background-color: #ff0; &#125;.seriousError &#123; border-width: 3px; &#125; 4.4 连续继承12345678910111213141516171819/*scss*/.error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125;.criticalError &#123; @extend .seriousError; position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%;&#125; 1234567891011121314/*css*/.error, .seriousError, .criticalError &#123; border: 1px #f00; background-color: #fdd; &#125;.seriousError, .criticalError &#123; border-width: 3px; &#125;.criticalError &#123; position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%; &#125; 3.4 mixin 指令@mixin 可以预先定义样式的代码块；@include 可以引入 @mixin 预定义的样式；该指令类似于 @extend 的继承效果，区别是@mixin指令预定义的样式编译后会自动去除，可以有效避免使用非语义化的类名； 1. @mixin 与 @include示例1：样式123456789101112131415/*scss*/@mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125;.page-title &#123; @include large-text; padding: 4px; margin-top: 10px;&#125; 12345678/*css*/.page-title &#123; font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px; &#125; 示例2：选择器 + 样式123456789/*scss*/@mixin silly-links &#123; a &#123; color: blue; background-color: red; &#125;&#125;@include silly-links; 1234/*css*/a &#123; color: blue; background-color: red; &#125; 示例3：复合使用1234567891011121314151617/*scss*/@mixin highlighted-background &#123; background-color: #fc0;&#125;@mixin header-text &#123; font-size: 20px;&#125;@mixin compound &#123; @include highlighted-background; @include header-text;&#125;.test &#123; @include compound&#125; 1234/*css*/.test &#123; background-color: #fc0; font-size: 20px; &#125; 2. 定义参数示例4：$arguments@mixin 可以定义参数，@include调用的时候传参；123456789101112/*scss*/@mixin sexy-border($color, $width) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue, 10px);&#125; 12345/*css*/p &#123; border-color: blue; border-width: 10px; border-style: dashed; &#125; 3. 指定参数的缺省值123456789/*scss*/@mixin left($value: 10px) &#123; float: left; margin-right: $value;&#125;p &#123; @include left;&#125; 1234/*css*/p &#123; float: left; margin-right: 10px; &#125; 4. $arg...示例5：$arg...可以用 $参数... 表示所有传入的参数1234567891011/*scss*/$b: box-shadow;@mixin box-shadow($shadows...) &#123; -moz-#&#123;$b&#125;: $shadows; -webkit-#&#123;$b&#125;: $shadows; #&#123;$b&#125;: $shadows;&#125;.shadows &#123; @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);&#125; 12345/*css*/.shadows &#123; -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; &#125; 3.5 条件语句、循环语句1. 条件语句@if...else... 条件判断，判断结果为 true 时赋值样式 示例1：123456789101112131415/*scss*/p &#123; @if 1 + 1 == 2 &#123; border: 1px solid; &#125; @if true &#123; background-image: url(''); &#125; @if 5 &lt; 3 &#123; border: 2px dotted; &#125; @if null &#123; border: 3px double; &#125;&#125; 1234/*css*/p &#123; border: 1px solid; background-image: url(""); &#125; 示例2：12345678910111213/*scss*/$type: monster;p &#123; @if $type == ocean &#123; color: blue; &#125; @else if $type == matador &#123; color: red; &#125; @else if $type == monster &#123; color: green; &#125; @else &#123; color: black; &#125;&#125; 123/*css*/p &#123; color: green; &#125; 2. 循环语句注意form...through与from ... to循环的范围 2.1 @for $var form...through...示例：from … through123456/*scss*/@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; 123456789/*css*/.item-1 &#123; width: 2em; &#125;.item-2 &#123; width: 4em; &#125;.item-3 &#123; width: 6em; &#125; 2.2 @for $var from...to...示例：from … to123456/*scss*/@for $i from 1 to 3 &#123; .item-to-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; 123456/*css*/.item-to-1 &#123; width: 2em; &#125;.item-to-2 &#123; width: 4em; &#125; 2.3 @each $var in ...@each 为 $var 循环所有 in 后面列出的值示例：@each … in …123456/*scss*/@each $animal in puma, sea-slug, egret, salamander &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/images/#&#123;$animal&#125;.png'); &#125;&#125; 123456789101112/*css*/.puma-icon &#123; background-image: url("/images/puma.png"); &#125;.sea-slug-icon &#123; background-image: url("/images/sea-slug.png"); &#125;.egret-icon &#123; background-image: url("/images/egret.png"); &#125;.salamander-icon &#123; background-image: url("/images/salamander.png"); &#125; 2.4 @while $var ...示例：while循环12345678/*scss*/$i: 6;@while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2;&#125; 123456789/*css*/.item-6 &#123; width: 12em; &#125;.item-4 &#123; width: 8em; &#125;.item-2 &#123; width: 4em; &#125; 2.5 条件 + 循环示例：12345678/*scss*///@for 后面的第一个$i 相当于参数，第二个$i 直接将变量的值拿过来用$i: 6;@for $i from 1 through $i &#123; .col-#&#123;$i&#125; &#123; width: $i/6*100% &#125;&#125; 相当于：1234567/*scss*/$i: 6;@for $j from 1 through $i &#123; .col-#&#123;$j&#125; &#123; width: $j/6*100% &#125;&#125; 123456789101112131415161718/*css*/.col-1 &#123; width: 16.6666666667%; &#125;.col-2 &#123; width: 33.3333333333%; &#125;.col-3 &#123; width: 50%; &#125;.col-4 &#123; width: 66.6666666667%; &#125;.col-5 &#123; width: 83.3333333333%; &#125;.col-6 &#123; width: 100%; &#125; 3.6 自定义函数12345678910111213141516171819202122/*scss*/$grid-width: 40px;$gutter-width: 10px;@function test($a) &#123; @return $a + 10;&#125;@function grid-width($n) &#123; $hello: 1px; @for $i from 1 through $n &#123; $hello: $hello + $i; &#125; @if $hello &gt; 10 &#123; $hello: 15px; &#125; @return $hello + test(2);&#125;#sidebar &#123; width: grid-width(5);&#125; 123/*css*/#sidebar &#123; width: 27px; &#125; （教程结束） 复习 如果你对着教程自己有在操作，那么你可以再抽时间过一遍阮一峰老师的SASS用法指南，配合食用味道更佳哦~ （完） 参考SASS用法指南-阮一峰SASS中文文档-bootcss]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Blog！]]></title>
    <url>%2F2017%2F08%2F19%2FHello%20Blog%EF%BC%81%2F</url>
    <content type="text"><![CDATA[一、为什么要写博客不知道大家写博客的理由都是什么，反正我的理由很简单，不外乎以下几点： 记录自己的学习笔记； 记录自己的生活动态； 分享一些有趣的东西； 一个全平台的收藏夹； 处女座来强行凑个数； 二、写博客的好处我的天！这个标题让我想起还在学校的时候，本宝宝是经管学院市场营销专业的QAQ，还记得网络营销的第一课就是经典的企业博客营销，所以你有事没事分享点有趣的东西骗骗粉也不错吖，指不定哪天就火了呢~尤其是在目前这个粉丝经济尤为突出的市场环境下，万一你一不小心火了，博客就是你的招牌，你说是不咯？ 当然本宝宝并不是冲着营销号方向走的=。=纯粹是为了记录自己的进步与二逼的想法QAQ 强化记忆！个人觉得这是写博客对自己最大的好处了。 学习上以前没有记笔记的习惯，但是现在要转行做码农辣，学习了一段时候后才发现，不记笔记是硬伤！不记笔记是硬伤！不记笔记是硬伤！ 重要的事情说三遍。不知道其他的圈子是什么样的 ，至少以我目前浅薄的目光来看前端圈，琳（luan）琅（qi）满（ba）目（zao）的API，除非有着超超超超一流的记忆能力，否则你很难记住一些奇奇怪怪的东西。 生活上可以记录一些有意思的生活动态，比如说游记、菜谱、随笔、灵感等。指不定某天冒出个想法改变了自己的未来呢，哈哈。 三、写好博客的秘诀贵在坚持，仅此而已。自己也是第一次开始尝试写个人博客，就先这样吧=。= （完）]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
