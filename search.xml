<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从 0 - 1 的学习书单]]></title>
    <url>%2F2017%2F09%2F19%2F%E4%BB%8E-0-1-%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%A6%E5%8D%95%2F</url>
    <content type="text"><![CDATA[其中部分书籍是开源作品，能在网上免费浏览。如您喜欢，可以购买实体书支持一下出版商。 零、添加收藏夹 (*^▽^*)开源书籍： 《JavaScript 标准参考教程（alpha）》 http://javascript.ruanyifeng.com/ 《ES6 标准入门》 http://es6.ruanyifeng.com/豆瓣读书：ES6 标准入门 《javascript 秘密花园》http://bonsaiden.github.io/JavaScript-Garden/zh/ 《Promise迷你书》 http://liubin.org/promises-book/ 一、阶段一（切静态页面） CSS 那三本书都是经典中的经典，按年代顺序列出，入门阶段只需通读其中一本基本能写出一个 “ 不是太丑 “ 的静态页面。 《 Head First HTML与CSS（第2版）》豆瓣读书：Head First HTML与CSS（第2版） 《CSS权威指南（第三版）》豆瓣读书：CSS权威指南（第三版） 《精通CSS：高级Web标准解决方案（第2版）》豆瓣读书：精通CSS（第2版） 《CSS揭秘》豆瓣读书：CSS揭秘 二、阶段二（简单交互） 《JavaScript DOM编程艺术（第2版）》豆瓣读书：JavaScript DOM编程艺术（第2版） 三、阶段三（能力养成） JavaScript高级程序设计 与 JavaScript权威指南 二选一即可，内容大同小异。但无疑是一本好书，每个阶段翻看都会有不懂的感悟。 《JavaScript高级程序设计（第3版）》豆瓣读书：JavaScript高级程序设计（第3版） 《JavaScript语言精粹》豆瓣读书：JavaScript语言精粹 《JavaScript权威指南(第四版)》豆瓣读书：JAVASCRIPT权威指南(第四版) 《你不知道的JavaScript（上卷）》豆瓣读书：你不知道的JavaScript（上卷） 《你不知道的JavaScript（中卷）》豆瓣读书：你不知道的JavaScript（中卷） 《JavaScript设计模式与开发实践》豆瓣读书：JavaScript设计模式与开发实践 四、最终阶段多逛一些优质社区，向别人学习！ 社区推荐：（不区分顺序，想到什么写什么） 知乎 https://www.zhihu.com/ 掘金 https://juejin.im/ segmentfault https://segmentfault.com/ StackOverflow https://stackoverflow.com/ 简书 http://www.jianshu.com/ freeCodeCamp https://www.freecodecamp.cn/ 各种框架社区 =。= 结语虽然列了很多书，但事实上是，入门阶段看博客与翻文档更多，当你感觉需要提高，补充基础的时候，看书有奇效。 最后，上面列出的那么多东西，我也只看了其中的一小部分，正在慢慢补充中。。。 （完）]]></content>
      <categories>
        <category>书单</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒子模型]]></title>
    <url>%2F2017%2F09%2F18%2F%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[梳理基础知识，从 CSS 盒模型开始！ 一、什么是盒子模型我们先看一张图： @盒子模型 | center 最开始看着这张图的时候，觉得与其说是盒模型，倒不如说是张画布( 不是 canvas svg 的意思 )，直到我遇上了外边距合并 (ｷ｀ﾟДﾟ´)!! 下面，请听我娓娓道来。 首先，这货规定了哪些地方你可以画上哪些东西： 如图所示，由内而外依次是 content , padding , bording , margin content : 真正容纳东西的区域，在 content 中你可以画上 其他元素、文本 等任意内容。 padding : 盒子的内边距，包裹在 content 之外，可以想象成快递中的空气气囊，夹在 border 和 content 之间。 border : 盒子的边框，相当于你在 padding 外镶了一层。border 可以指定 颜色、粗细、样式等。（相当于一个阉割版的 content） margin : 盒子的外边距外边距，这个盒子周围空置的安全区域（在不发生外边距折叠的情况下） 二、使用开发者工具查看盒模型emmmmm，个人觉得先学会使用开发者工具的部分功能后，会对学习盒子模型降低很大的时间成本。 话不多说，直接看图： 不对不对，你打开 Chrome 浏览器先 =。= 这时候你可以单击检查，然后会弹出控制台（开发者工具）。当然你也可以按 F12 Elements : 网页中的各个元素，你可以尝试着移动鼠标到某个元素后，单机选中元素，然后会得到类似如下图一样结果，注意红线选中部分。 （当然一般都是单击左上角的一个小鼠标箭头的图标，然后直接单击网页呈现的内容选择） 右上角的箭头，单击后可以直接单击选择页面呈现的元素，并在控制台中定位 DOM 文档中蓝色背景标签 p，我刚刚选中的那个元素 下面有个类似导航条一样的东西，是当前选中元素所在的层级 右边 styles 是当前元素的 CSS 样式，点击 computed 可以查看最终计算后的样式 styles 一栏滚动到底部有这么一个花里胡哨的框框，就是盒子模型，从内到外依次和上面介绍的那个一样，而且有文字注明 ok,知道了这些基本使用后，我们来了解一下盒子模型的尺寸 三、盒模型的尺寸慢着，在讲盒模型尺寸前，最好先简单了解一个可以帮助你解决很多问题的属性： box-sizing box-sizing 属性可以帮助我们在 标准盒模型 与 IE 盒模型 中自由切换（为什么这么称呼请自行 Google） 需要注意的是：这两个盒子模型的尺寸的计算方法是不一样的！ box-sizing : border-box; （IE 盒模型）观察下图，明显表示了，在 IE 盒模型中 width = content 宽度 + 左右 padding 宽度 + 左右 border 宽度 height = content 高度 + 左右 padding 高度 + 左右 border 高度 @IE盒模型 | center box-sizing : content-box; （标准盒模型）标准盒模型是默认值，现在看一下与 IE 盒模型有什么不同 width = content 宽度 height = content 高度 @标准盒模型 | center box-sizing : inherit;继承父元素的盒模型样式。 以上就是 box-sizing 的简介，很简单，但很实用。 兼容性关于兼容性的问题，请移步 caniuse.com 关于盒子模型的介绍基本就到这里。 （完）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>盒子模型</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nrm ---- npm registry 管理工具]]></title>
    <url>%2F2017%2F09%2F18%2Fnrm-npm-registry-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[一、什么是 nrm一个 npm registry 管理工具。 二、nrm 干嘛用可以快速切换至其他 npm 源下载你需要的包 三、为什么要用 当前源不稳定，安装某些包时经常卡住不动 npm 官方源上不去了（国内互联网不可描述的原因） 你不会手动切换 npm 其他源，或者你不知道还有哪些源 四、如何使用 install 1npm install -g nrm show registry list 123456789nrm ls* npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ change target registry 1234# switch registry to cnpmnrm use cnpm Registry has been set to: http://r.cnpmjs.org/ show help 123nrm help# here to show all of the nrm cmmands 五、注意事项当你使用其他源的时候，你无法使用 npm 的 publish 命令发布你的 npm 包，需要切换回官方源。 参考资料 nrm – NPM registry manager - Github （完）]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>nrm</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX 与 XMLHttpRequest 入门]]></title>
    <url>%2F2017%2F09%2F14%2FAJAX-%E4%B8%8E-XMLHttpRequest%2F</url>
    <content type="text"><![CDATA[一、 AJAX 简介 AJAX 全称 AsynchronousJavascript+XML ==&gt; 异步传输 + js + xml。 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果我们可以再来处理这个事。这个很重要，如果不是这样的话，我们点完按钮，页面就会死在那里，其他的数据请求不会往下走了。这样比等待刷新似乎更加讨厌。 虽然提供异步通讯功能的组件默认情况下都是异步的，但它们也提供了同步选项，如果你好奇把那个默认参数为 true 的选项改为 false ，你的页面就会死在那里，等待请求结果返回之后再执行下一步操作。 xml 只是一种数据格式，在这件事里并不重要，我们在更新一行字的时候理论上说不需要这个格式，但如果我们更新很多内容，那么格式化的数据可以使我们有条理地去实现更新。 目前大部分都是在用 JSON 这种格式来代替 XML 的，因为前者更加简洁，据说目前的解析速度也更快。 总结：只要是 JS 调用异步通讯组件并使用格式化的数据来更新 web 页面上的内容或操作过程，那么我们用的方法就可算是 AJAX 二、使用 AJAXok 看了上面的简介部分，是时候实际运用一波了，来来，把手伸出来 这里是一个简单的例子：12345678910111213141516171819202122232425262728293031// 定义一个存储请求 URL 地址的变量var getWeather = "https://jirenguapi.applinzi.com/weather.php";// 定义一个发送 AJAX 请求的函数function sendAJAX(url)&#123; // 构造一个 XMLHttpRequest 实例 var xhr = new XMLHttpRequest(); // 调用open 方法创建一个新的 HTTP 请求，并指定此请求的方法、URL 等信息 xhr.open("GET", url, true) // 调用 send 方法发送请求 xhr.send() // 追踪 AJAX 请求状态 xhr.onreadystatechange = function()&#123; // 对应 readyState 值为4 表示请求完成 if(xhr.readyState === 4)&#123; // 判断返回的 HTTP 状态码 if(xhr.status === 200 || xhr === 304 )&#123; // 把请求到的 JSON 格式字符串转换为 JSON 格式对象 var yunyu = JSON.parse(xhr.responseText) // 控制台答应请求到的 JSON 对象 console.log(yunyu) &#125;else&#123; console.log("没有拿到数据哦") &#125; &#125; xhr.onerror = function()&#123; console.log("异常！异常！") &#125; &#125;&#125;// 调用 sendAJAX 参数是最初定义的 URLsendAJAX(getWeather) 请求成功后你的控制台可能会出现一个这样子的打印 如果跟以上截图一样的，说明你请求成功了，怎么样 484很简单 (*^▽^*) emmmm，当然也可能出现其他打印，比如请求不成功的时候,或者是一些其他问题，同时会返回其他对应的状态码。 关于状态码的问题，可以移步这里 HTTP 状态码详解 当然，上面的例子还有其他写法，比如这样：123456789101112131415function sendAJAX(url)&#123; var xhr = new XMLHttpRequest() xhr.open("GET", url, true) xhr.send() xhr.onload = function () &#123; if ((xhr.status ===200 ) || xhr.status === 304) &#123; console.log(JSON.parse(xhr.responseText)) &#125; else &#123; console.log("服务器异常") &#125; &#125; xhr.onerror = function () &#123; console.log("服务器异常") &#125;&#125; ok，简单了解了 AJAX 的写法之后我们来看一下它的核心部分 XMLHttpRequest 三、XMLHttpRequest XMLHttpRequest 是 AJAX 的核心部分，上面所说的 AJAX 其实只是一种技术方案，并不是一种新技术。通常所说的 AJAX 请求，实际上是使用 XMLHttpRequest 对象来发送一个 AJAX 请求。 现在我们看另一种发送请求的方法 POST 1234567891011121314151617181920212223242526function sendAJAX() &#123; var xhr = new XMLHttpRequest()// 可选，设置xhr请求的超时时间 xhr.timeout = 3000; xhr.open('POST', '/register', true) xhr.send('username=yunyu&amp;password=123456') xhr.onload = function (e) &#123; if ((xhr.status === 200 ) || xhr.status === 304) &#123; console.log(this.responseText) &#125; &#125;// 可选 xhr.ontimeout = function (e) &#123; console.log('请求超时') &#125;// 可选 xhr.onerror = function (e) &#123; console.log('连接失败') &#125;// 可选 xhr.upload.onprogress = function (e) &#123; //如果是上传文件，可以获取上传进度 &#125;&#125; 当然，以上内容还只是 xhr 对象的冰山一角，有兴趣的同学可以看文末的参考资料，里面有详细的 XMLHttpRequest 描述。 1、获取 response 数据xhr 提供了3个属性来获取请求返回的数据，分别是：xhr.response、xhr.responseText、xhr.responseXML xhr.response 默认值：空字符串”” 当请求完成时，此属性才有正确的值 请求未完成时，此属性的值可能是 &quot;&quot; 或者 null ，具体与 xhr.responseType 有关：当 responseType 为 &quot;&quot; 或 &quot;text&quot; 时，值为 &quot;&quot; ；responseType 为其他值时，值为 null 2、追踪请求当前的状态xhr 对象有个只读属性 readyState , 这个属性可追踪到共 5 种可能值，分别对应 xhr 状态的不同阶段。每次 xhr.readyState 的值发生变化时，都会触发 xhr.onreadystatechange 事件，我们可以在这个事件中进行相关状态判断。 值 状态 描述 0 UNSENT (初始状态，未打开) 此时 xhr 对象被成功构造，open() 方法还未被调用 1 OPENED (已打开，未发送) open() 方法已被成功调用，send() 方法还未被调用。注意：只有 xhr 处于 OPENED 状态，才能调用 xhr.setRequestHeader() 和 xhr.send(),否则会报错 2 HEADERS_RECEIVED (已获取响应头) send() 方法已经被调用, 响应头和响应状态已经返回 3 LOADING (正在下载响应体) 响应体(response entity body)正在下载中，此状态下通过 xhr.response 可能已经有了响应数据 4 DONE (整个数据传输过程结束) 整个数据传输过程结束，不管本次请求是成功还是失败 3、通过控制台调试 通过打断点的方式，在 Source 观察源文件的数据变动。 最右边有个 watch ， readyState 状态变更时候， 会显示 xhr 对象相应的数据和状态的变动。 4、发一个同步请求xhr 默认发的是异步请求，但也支持发同步请求（当然实际开发中应该尽量避免使用）。到底是异步还是同步请求，由 xhr.open() 传入的 async 参数决定。 12// open 语法 参数open(method, url [, async = true [, username = null [, password = null]]]) method: 请求的方式，如GET/POST/HEADER等，这个参数不区分大小写 12xhr.open("GET", url)xhr.open("POST", url) url: 请求的地址，可以是相对地址如example.php，这个相对是相对于当前网页的url路径；也可以是绝对地址如 http://www.example.com/example.php 12xhr.open("GET", "../../example.php")xhr.open("GET", "http://www.example.com/example.php") async: 默认值为 true，即为异步请求，若设置为 false，则为同步请求 12xhr.open("GET", "../../example.php", true)xhr.open("GET", "http://www.example.com/example.php", false) 5、实际使用实际上以上内容已经包含了大部分的使用情况，你可以根据自己的需求进一步封装成一个 AJAX 组件，或者也可以使用现成的 jQuery 封装的 AJAX 组件 （jQuery.ajax()），两者功能是一样的。 当然，如果你对这方面比较感兴趣的话，我想你一定不想错过 fetch API ，它简化了 AJAX 的操作代码，但能够一丝不苟的做着同样的工作。但是，它目前依然只是一个实验中的功能，目前在浏览器的兼容方面还不是特别理想。 Fetch API - MDN 以上，就是 AJAX 和 XMLHttpRequest 的常用玩法，其他更具体更细节的玩法可以在以下的参考资料中学习了解。 参考资料XMLHttpRequest Level 2 使用指南 - 阮一峰 XMLHttpRequest - MDN Using XMLHttpRequest - MDN AJAX tutorial 你真的会使用XMLHttpRequest吗？ - ruoyiqing]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>XMLHttpRequest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS判断数据类型]]></title>
    <url>%2F2017%2F09%2F10%2FJS%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JS判断数据类型 本文摘要：列举了常用的数据类型检查方法、应用场景及使用技巧。 1、JavaScript 数据类型最新的 ECMAScript 标准定义了 7 种数据类型，主要分类两大类： 第一类：Primitive ( 原始类型 ) boolean null undefined number string symbol ( ES6 ) 第二类：Object ( 对象类型 ) Object ( Object , Array , RegExp , Function , etc.) 类型区分 原始类型：直接将值传递给变量 对象类型：将一个堆内存中的引用( 如 0xFFFF ) 传给变量 ( 如果正在看文章的你对类型区分不太了解，请自行查阅补充 ) 2、判断数据类型的方法方法一：typeof 操作符typeof 是一个最简单的判断数据类型的操作符。 语法：typeof() 在 () 中填入你想判断类型的数据。返回值：”boolean” , “string” , “number” , “undefined” , “symbol” , “object” 示例：1234typeof(123) // "number"typeof("string") // "string"typeof(true) // "boolean"typeof(Symbol()) // "symbol" emmmmm…如果你只看这几个示例好像 typeof 并没有什么问题，但实际上typeof 这货比较 呆萌 ，实际使用中往往得不到你想要的结果。示例请看下表：( 如果你对此表抱有疑问，请自行前往控制台输入 ) 注：JavaScript 标准文档中定义: [[Class]] 的值只可能是下面字符串中的一个： Arguments, Array, Boolean, Date, Error, Function, JSON, Math, Number, Object, RegExp, String. Value : typeof 操作符运算的值 Type : typeof 操作符运算的结果 Class : 对象内部属性 [[Class]] 的值 Value Class Type “foo” String string new String(“foo”) String object 1.2 Number number new Number(1.2) Number object true Boolean boolean new Boolean(true) Boolean object new Date() Date object new Error() Error object [1,2,3] Array object new Array(1, 2, 3) Array object new Function(“”) Function function /abc/g RegExp object new RegExp(“meow”) RegExp object {} Object object new Object() Object object 通过以上测试可以发现，用 typeof 操作符判断数据类型的时候，在大多数情况下都返回 “object”，所以呆萌的 typeof 或许不是你想要的那种精明能干的操作符。 方法二：instanceof 操作符instanceof 操作符用来比较两个操作数据的构造函数。 语法：&lt;case&gt; instanceof &lt;Constructor&gt;返回值：true / false instanceof 操作符只有在比较自定义的对象时才有意义。 如果用来比较内置类型，将会和 typeof 操作符 一样用处不大 比较自定义对象12345678910function Foo() &#123;&#125;function Bar() &#123;&#125;Bar.prototype = new Foo();new Bar() instanceof Bar; // truenew Bar() instanceof Foo; // true// 如果仅仅设置 Bar.prototype 为函数 Foo 本身，而不是 Foo 构造函数的一个实例Bar.prototype = Foo;new Bar() instanceof Foo; // false 比较内置类型12345new String('foo') instanceof String; // truenew String('foo') instanceof Object; // true'foo' instanceof String; // false'foo' instanceof Object; // false 注意：instanceof 用来比较属于不同 JavaScript 上下文的对象（比如，浏览器中不同的文档结构）时将会出错， 因为它们的构造函数不会是同一个对象。 方法三：终极必杀技 Object.prototype.toString对象的类定义：JavaScript 标准文档只给出了一种获取 [[Class]] 值的方法，那就是使用 Object.prototype.toString 同样使用上面 typeof 判断类型表中 Value 字段的值，这次我们使用 Object.prototype.toString 12345678910111213141516171819function checkDataType(val)&#123; return Object.prototype.toString.call(val)&#125;checkDataType("foo") // =&gt; "[object String]"checkDataType(new String("foo") ) // =&gt; "[object String]"checkDataType(1.2) // =&gt; "[object Number]"checkDataType(new Number(1.2) ) // =&gt; "[object Number]"checkDataType(true) // =&gt; "[object Boolean]"checkDataType(new Boolean(true) ) // =&gt; "[object Boolean]"checkDataType(new Date()) // =&gt; "[object Date]"checkDataType(new Error() ) // =&gt; "[object Error]"checkDataType([1,2,3] ) // =&gt; "[object Array]"checkDataType(new Array(1, 2, 3)) // =&gt; "[object Array]"checkDataType(new Function("")) // =&gt; "[object Function]"checkDataType(/abc/g) // =&gt; "[object RegExp]"checkDataType(new RegExp("meow")) // =&gt; "[object RegExp]"checkDataType(&#123;&#125;) // =&gt; "[object Object]"checkDataType(new Object()) // =&gt; "[object Object]" 当然，如果你可以通过 slice 让返回值变得简短一点，通过 toLowerCase 变成我们熟悉的小写类型。12345function checkDataType(val)&#123; return Object.prototype.toString.call(val).slice(8,-1).toLowerCase()&#125;checkDataType("foo") // =&gt; "string" 3、结论当检测一个对象类型的时候，建议使用 Object.prototype.toString 方法；通过以上对比可以发现，这是唯一一个靠谱的判断数据类型的方法。正如上面表格所示，typeof 的一些返回值在标准文档中并未定义，所以它可能会给你一个意料之外的答案。而 instanceof 操作符应仅用来比较同一个 JavaScript 上下文 ( 文档 ) 中的自定义对象。 参考资料 JavaScript 数据类型和数据结构 JavaScript-Garden 表达式和运算符 - typeof 表达式和运算符 - instanceof Object.prototype.toString()]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器爸爸之页面渲染]]></title>
    <url>%2F2017%2F09%2F10%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%88%B8%E7%88%B8%E4%B9%8B%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[浏览器爸爸之页面渲染一、CSS 和 JS 在网页中的放置顺序 CSS最好放置在&lt;head&gt;标签中如果将css样式放在底部，会造成浏览器先加载html然后再加载css，重绘页面，造成 闪屏 现象。 JS最好放置在body标签内的最后面 JavaScript的加载： 加载脚本会阻塞后面内容的呈现 加载脚本会阻塞其后组件的下载 原因：对于图片和 CSS，在加载时会并发加载，而 JS 在加载的时候会阻止并发，并禁止其他资源加载，所以如果将JS放入页面顶部会导致白屏现象。（在 CSS 中使用 @import 或将样式表放在页面底部也可能导致白屏） 二、白屏 和 FOUC原理： 主要是由于浏览器在处理 HTML 和 CSS 的方式有些不同： 一类是等 HTML 和 CSS 都加载完了，再展示到页面上，等待时间就是白屏。 另一类先展示 HTML ，等 CSS 加载完之后再展示样式，出现 FOUC （无样式内容闪烁）。 还有一些其他原因也会造成白屏和 FOUC 。 白屏： 如果把样式放在底部,对于IE浏览器,在某些场景下（新窗口打开,刷新等）页面会出现白屏，而不是内容逐步展现； 如果使用 @import 标签，即使是在头部的 &lt;head&gt; 标签内 使用 link 引入 CSS，也可能出现白屏； JS 加载会阻塞后面内容的呈现，如果将 JS 放到 head 标签中并且加载时间很长，页面也有可能出现白屏； FOUC：Flash Of Unstyled Content （文档无样式闪烁） 原因：浏览器先逐步加载无样式的内容，等 CSS加载后页面突然展现样式。 对于 Firefox，渲染机制与 Chrome 略有不同，因此会出现 FOUC; 在底部引入 CSS 样式； 对于IE，在某些场景下（点击链接，输入URL，使用书签进入等），也会出现 FOUC 现象 三、async 和 defer 的作用与区别1. 没有 defer 或 async1&lt;script src="script.js"&gt;&lt;/script&gt; 浏览器会立即加载并执行指定的脚本，” 立即 “的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。 2. 有 async1&lt;script async src="script.js"&gt;&lt;/script&gt; 加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 3. 有 defer1&lt;script defer src="myscript.js"&gt;&lt;/script&gt; 加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 实用角度来说，把所有脚本都丢到 &lt;/body&gt; 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。 四、网页的渲染机制（简版） 解析 HTML 标签，生成 DOM 树 解析 CSS 元素，生成 CSSOM 树 把 DOM 和 CSSOM 组合成渲染树 在渲染树的基础上进行布局，计算每个节点的几何结构 把每个节点绘制到屏幕上 参考资料 Render-tree construction, layout, and paint How browsers work]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件代理（事件委托）]]></title>
    <url>%2F2017%2F09%2F09%2F%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%89%2F</url>
    <content type="text"></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试题：数组、API]]></title>
    <url>%2F2017%2F09%2F06%2F%E8%AF%95%E9%A2%98%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81API%2F</url>
    <content type="text"><![CDATA[试题：数组、API 试题来源：https://www.nowcoder.com/注意：答题器不支持ES6语法 前排提示尽量用不同的 API 去实现题目需求，这样才能更快掌握更多的 API参考 API 都在这里：JavaScript 标准库：Array 前排提示x2：一定要注意 API 的返回值！ 1. 查找数组元素位置找出元素 item 在给定数组 arr 中的位置如果数组中存在 item，则返回元素在数组中的位置，否则返回 -1 123function indexOf(arr, item)&#123; /* your code here */&#125; 输入 [ 1, 2, 3, 4 ], 3 输出 2 indexOf + map1234567891011121314function indexOf(arr, item) &#123; if(Array.prototype.indexOf)&#123; return arr.indexOf(item) &#125;else&#123; var index; arr.map(function(e,i)&#123; if(e === item)&#123; index = i; &#125; &#125;) return index; &#125; return -1;&#125; 2. 数组求和计算给定数组 arr 中所有元素的总和数组中的元素均为 Number 类型 123function sum(arr) &#123; /* your code here */&#125; 输入 [ 1, 2, 3, 4 ] 输出 10 递归 + slice 12345678910function sum(arr) &#123; var len = arr.length; if(len === 0)&#123; return 0; &#125;else if(len === 1)&#123; return arr[0]; &#125;else&#123; return arr[0] + sum(arr.slice(1)) &#125;&#125; reduce 12345function sum(arr) &#123; return arr.reduce(function(prev,curr,idx,arr)&#123; return prev + curr; &#125;)&#125; 3. 移除数组中的元素移除数组 arr 中的所有值与 item 相等的元素。不要直接修改数组 arr，结果返回新的数组 123function remove(arr, item) &#123; /* your code here */&#125; 输入 [1, 2, 3, 4, 2], 2 输出 [1, 3, 4] filter 12345function remove(arr,item)&#123; return arr.filter(function(e)&#123; return e !== item; &#125;)&#125; slice + splice 12345678910function remove(arr,item)&#123; var newArr = arr.slice(0); for(var i=0,len=newArr.length; i&lt;len; i++)&#123; if(newArr[i]===item)&#123; newArr.splice(i,1) // PS：这样会改变后面每一项的索引，当然有更好的写法 i--; &#125; &#125; return newArr;&#125; 4. 移除数组中的元素移除数组 arr 中的所有值与 item 相等的元素，直接在给定的 arr 数组上进行操作，并将结果返回 123function removeWithoutCopy(arr, item) &#123; /* your code here */&#125; 输入 [1, 2, 2, 3, 4, 2, 2], 2 输出 [1, 3, 4] while123456function removeWithoutCopy(arr, item) &#123; while(arr.indexOf(item)!==-1)&#123; arr.splice(arr.indexOf(item),1) &#125; return arr;&#125; 5. 添加元素在数组 arr 末尾添加元素 item。不要直接修改数组 arr，结果返回新的数组 123function append(arr, item) &#123; /* your code here */&#125; 输入 [1, 2, 3, 4], 10 输出 [1, 2, 3, 4, 10] concat123function append(arr, item) &#123; return arr.concat(item)&#125; 6. 删除数组最后一个元素删除数组 arr 最后一个元素。不要直接修改数组 arr，结果返回新的数组 123function truncate(arr) &#123; /* your code here */&#125; 输入 [1, 2, 3, 4] 输出 [1, 2, 3] pop + slice12345function truncate(arr) &#123; var newArr = arr.slice(0); newArr.pop(); return newArr;&#125; 7. 在数组开头添加元素在数组 arr 开头添加元素 item。不要直接修改数组 arr，结果返回新的数组 123function prepend(arr, item) &#123; /* your code here */&#125; 输入 [1, 2, 3, 4], 10 输出 [1, 2, 3, 4], 10 slice + unshift12345function prepend(arr, item) &#123; var newArr = arr.slice(0) newArr.unshift(item) return newArr&#125; 8. 删除数组第一个元素删除数组 arr 第一个元素。不要直接修改数组 arr，结果返回新的数组 123function curtail(arr) &#123; /* your code here */&#125; 输入 [1, 2, 3, 4] 输出 [2, 3, 4] concat + shift12345function curtail(arr) &#123; var newArr = arr.concat() newArr.shift() return newArr&#125; 9. 数组合并合并数组 arr1 和数组 arr2。不要直接修改数组 arr，结果返回新的数组 123function concat(arr1, arr2) &#123; /* your code here */&#125; 输入 [1, 2, 3, 4], [‘a’, ‘b’, ‘c’, 1] 输出 [1, 2, 3, 4, ‘a’, ‘b’, ‘c’, 1] slice + push +apply12345function concat(arr1, arr2) &#123; var newArr = arr1.slice(0); Array.prototype.push.apply(newArr,arr2); return newArr;&#125; 10. 在数组中间添加元素在数组 arr 的 index 处添加元素 item。不要直接修改数组 arr，结果返回新的数组 123function insert(arr, item, index) &#123; /* your code here */&#125; 输入 [1, 2, 3, 4], ‘z’, 2 输出 [1, 2, ‘z’, 3, 4] slice + splice12345function insert(arr, item, index) &#123; var newArr = arr.slice(0); newArr.splice(index,0,item); return newArr;&#125; 11. 计数统计数组 arr 中值等于 item 的元素出现的次数 123function count(arr, item) &#123; /* your code here */&#125; 输入 [1, 2, 4, 4, 3, 4, 3], 4 输出 3 filter123456function count(arr, item) &#123; var newArr = arr.filter(function(e)&#123; return e === item; &#125;); return newArr.length;&#125; 12. 查找重复元素123function duplicates(arr) &#123; /* your code here */&#125; 输入 [1, 2, 4, 4, 3, 3, 1, 5, 3] 输出 [1, 3, 4] indexOf + lastIndexOf123456789function duplicates(arr) &#123; var newArr = []; arr.forEach(function(e,i)&#123; if(newArr.indexOf(e)===-1 &amp;&amp; arr.indexOf(e)!==-1 &amp;&amp; arr.indexOf(e)!== arr.lastIndexOf(e))&#123; newArr.push(e); &#125; &#125;) return newArr;&#125; 13. 求二次方为数组 arr 中的每个元素求二次方。不要直接修改数组 arr，结果返回新的数组 123function square(arr) &#123; /* your code here */&#125; 输入 [1, 2, 3, 4] 输出 [1, 4, 9, 16] map12345function square(arr) &#123; return arr.map(function(e)&#123; return e*e &#125;)&#125; 14. 查找元素位置在数组 arr 中，查找值与 item 相等的元素出现的所有位置 123function findAllOccurrences(arr, target) &#123; /* your code here */&#125; 输入 ‘abcdefabc’,’a’ 输出 [0,6] forEach + || + push1234567function findAllOccurrences(arr, target) &#123;var temp = []; arr.forEach(function(e,i)&#123; e !== target || temp.push(i); &#125;); return temp;&#125; 总结以上 14 道数组类型的题目，按照本文的解题思路走下来，通过参考 MDN 文档，你可能学习掌握了以下 API ： 以下所有数组 API 你都可以在这里找到：JavaScript 标准库：Array Array.length Array.prototype.concat() Array.prototype.filter() Array.prototype.forEach() Array.prototype.indexOf() Array.prototype.lastIndexOf() Array.prototype.map() Array.prototype.pop() Array.prototype.push() Array.prototype.reduce() Array.prototype.shift() Array.prototype.slice() Array.prototype.splice() Array.prototype.unshift() Function.prototype.apply() （完）]]></content>
      <categories>
        <category>试题</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>数组</tag>
        <tag>试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[map 与 forEach 简单比较]]></title>
    <url>%2F2017%2F09%2F04%2Fmap-%E4%B8%8E-forEach-%E7%AE%80%E5%8D%95%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[map 与 forEach 简单比较 参考资料：MDN文档：Array.prototype.forEach()MDN文档：Array.prototype.map() 结论先写结论： forEach 不会产生新数组，返回值 undefined map 会返回一个新数组，不对原数组产生影响 map 因为返回新数组，所以可以链式操作（可操作性强） 速度 forEach &gt; map &gt; for（网上有说map &gt; forEach 然而测试结果并不是） 一、Array.prototype.forEach()forEach() 方法对数组的每个元素执行一次提供的函数。 语法：12345array.forEach(callback(currentValue, index, array)&#123; //do something&#125;, this)array.forEach(callback[, thisArg]) 参数： callback为数组中每个元素执行的函数，该函数接收三个参数： currentValue(当前值)数组中正在处理的当前元素。 index(索引)数组中正在处理的当前元素的索引。 arrayforEach()方法正在操作的数组。 thisArg可选可选参数。当执行回调 函数时用作this的值(参考对象)。 返回值undefined. 使用： 示例1：注意 callback 和 返回值1234567const arr = [1,2,3,"a","b","c"]let _arr = arr.forEach((e,i,arr)=&gt;&#123; console.log(e) // 1, 2, 3, "a","b","c" console.log(i) // 0, 1, 2, 3, 4, 5 console.log(arr) // 输出6次 [1, 2, 3, "a", "b", "c"]&#125;)console.log(_arr) // undefined 1、对数组的每一项都调用一次 callback 回调函数；2、总是返回值 undefined 示例2：可选参数 thisArg12345678910111213141516171819class Calculate&#123; constructor(x,y)&#123; this.x = 0; this.y = 0; &#125; sum(array)&#123; array.forEach(function(e)&#123; this.x += e; ++this.y; &#125;,this) console.log(this); // 指向该构造函数 &#125;&#125;const obj = new Calculate();obj.sum([1,2,3,4]);console.log(obj.x) // 10console.log(obj.y) // 4 1、thisArg 参数 (this) 传给了forEach()2、每次调用时，它都被传给 callback 函数，作为它的this值 示例3：forEach() 不会在迭代之前创建数组的副本1234567const words = ["one","two","three","four"];words.forEach((word)=&gt;&#123; console.log(word); // "one","two","four" if(word === "two")&#123; words.shift(); // "two"输出完后删除了第一项，索引改变 &#125;&#125;) 遍历 two 后，整个数组的第一个项被移除了，导致所有剩余项索引 -1，而下一次执行回调遍历的那一项索引依旧 +1，所以three被跳过了。 Array.prototype.map()map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 语法：123let array = arr.map(function callback(currentValue, index, array) &#123; // Return element for new_array&#125;[, thisArg]) 参数： callback生成新数组元素的函数，使用三个参数： currentValuecallback 的第一个参数，数组中正在处理的当前元素。 indexcallback 的第二个参数，数组中正在处理的当前元素的索引。 arraycallback 的第三个参数，map 方法被调用的数组。 thisArg可选的。执行 callback 函数时 使用的this 值。 返回值（与 forEach 最大的不同点）一个新数组，每个元素都是回调函数的结果。 使用： 示例1：map 方法返回处理后的数组，不修改原数组123const numbers = [1, 4, 9];let roots = numbers.map(Math.sqrt);// roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9] 示例2：格式化数组中的对象1234567891011const kvArray = [&#123;key: 1, value: 10&#125;, &#123;key: 2, value: 20&#125;, &#123;key: 3, value: 30&#125;];let reformattedArray = kvArray.map(function(obj) &#123; let rObj = &#123;&#125;; rObj[obj.key] = obj.value; return rObj;&#125;);// reformattedArray = [&#123;key: 1, value: 10&#125;, &#123;key: 2, value: 20&#125;, &#123;key: 3, value: 30&#125;]; 示例3：在类数组集合上调用，利用 call 改变 this 指向1234const oLis = document.querySelectorAll("ul li");let arrOlis = Array.prototype.map.call(oLis，function(e)&#123; return e.value;&#125;) 示例4：反转字符串，原理同上（示例3）；链式调用（返回新数组）123456const str = "12345";let _str = Array.prototype.map.call(str,x=&gt;&#123; return x;&#125;).reverse().join("");// _str = "54321";// str = "12345"; 性能对比123456789101112131415161718192021let arr1 = [];for(let i=0; i&lt;50000; i++)&#123; arr1.push(i)&#125;const start = Date.now()// forEach ==&gt; 2ms ~ 3ms// let arr2 = [];// arr1.forEach((e)=&gt;arr2.push(e*2))// map ==&gt; 10ms ~ 13ms// let arr2 = arr1.map(e=&gt;return e*2)// for ==&gt; 20ms ~ 26ms// let arr2 = [];// for(let i = 0;i&lt;arr1.length;i++)&#123;// arr2[i] = arr1[1]// &#125;const end = Date.now()console.log(end-start) 通过以上的代码测试，速度方面 forEach &gt; map &gt; for 但是 由于前端处理数据的局限性，速度并不是我们实际使用考虑的因素，实际情况是： 代码量：map &gt; forEach &gt; for 代码量：map &gt; forEach &gt; for 代码量：map &gt; forEach &gt; for 综上，如果出于 代码量 和 链式调用 的需求，用 map 可能会更好一些。 （完）]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试题：数组、递归]]></title>
    <url>%2F2017%2F08%2F30%2F%E8%AF%95%E9%A2%98%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[试题：数组、递归题干：实现一个 flatten 函数，将一个嵌套多层的数组 array (嵌套可以是任何层数) 转换为只有一层的数组。 1234567// 数组中元素仅基本类型的元素或数组，不存在循环引用的情况。var arr = [1, [2], [3, [[4]]]];/* 在这里定义你的 flatten 函数 */var _arr = flatten(arr);console.log(_arr); // 输出 [1,2,3,4] 审题：先看一眼题目给出的这个 arr ，按照题意的说法，这就是给你一个数组，数组内包含 基本类型元素 和 嵌套了任意层数的数组 ，然后注意这个数组 不存在循环引用的情况 也就是说嵌套数组中也只有基本类型元素或数组，这就简单多啦，我们只需要把所有数组中的基本类型元素提取出来，然后放进一个新数组就可以咯~ 首先，写代码遵循一个 DRY 的基本准则： Don&#39;t Repeat Yourself；然后，这种有规律、层级多、需要重复调用的，第一反应就是 递归 嘛，那接下来就用递归思想写一个 flatten 函数。 这是我们要操作的数组： 1arr = [1, [2], [3, [[4]]]] 然后这是 flatten 函数大概要做的事情： 次数 — — — 第一次 数字 1 数组 [2] 数组 [3,[[4]]] 第二次 数字 2 数字 3 数组 [[4]] 第三次 数组 [4] 第四次 数字 4 做题emmmmm . . . 下面是我能想到的方法，实现方式有很多，大家可以自由发挥。 方法一：Array.prototype.reduce() + Array.isArray() + Array.prototype.concat() 文档链接：Array.prototype.reduce() 文档链接：Array.isArray() 文档链接：Array.prototype.concat() 1234567891011121314function flatten(arr) &#123; return arr.reduce(function (initArr, currentArr) &#123; return initArr.concat(Array.isArray(currentArr) ? flatten1(currentArr) : currentArr); &#125;, [])&#125;var arr = [1, [2], [3, [[4]]]]var arr1 = [-1, [0, 1], ["String", [[[undefined, null]], true, false]]]var _arr = flatten(arr)console.log(_arr) // [ 1, 2, 3, 4 ]var _arr1 = flatten(arr1)console.log(_arr1) // [ -1, 0, 1, 'String', undefined, null, true, false ] 方法二：Array.prototype.forEach() + 闭包 + Array.prototype.push() 文档：Array.prototype.forEach() 文档：Array.prototype.push() 闭包：来自《JavaScript 标准参考教程（alpha）》，by 阮一峰 12345678910111213141516171819202122232425function flatten(arr) &#123; // 定义一个空数组用来存放提取出来的基本类型元素 var _arr = []; // 用一个自执行函数处理多层嵌套数组 (function _flatten(arr) &#123; arr.forEach(function (e, i) &#123; if (e instanceof Array) &#123; // 当然也可以写成其他形式，比如：if(typeof e === 'object') _flatten(e); &#125; else &#123; _arr.push(e); &#125; &#125;); &#125;)(arr); return _arr;&#125;var arr = [1, [2], [3, [[4]]]]var arr1 = [-1, [0, 1], ["String", [[[undefined, null]], true, false]]]var _arr = flatten(arr)console.log(_arr) // [ 1, 2, 3, 4 ]var _arr1 = flatten(arr1)console.log(_arr1) // [ -1, 0, 1, 'String', undefined, null, true, false ] 总结好了，以上就是我大概的想法，希望大家思考更多其他的方法实现。 最后，要注意的是： 不要为了做题而做题！ 那么，做题能干嘛呢？ 做题能检查自己知识点的掌握情况； 做题能够快速学习不熟悉的 API ； 做题能够整理巩固已掌握的知识点； 不信？你看这篇文章，如果你把我列出的代码跟文档读过一遍，你可能学习/复习了以下知识点： 递归思想 Array.prototype.reduce() Array.isArray() Array.prototype.concat() Array.prototype.forEach() Array.prototype.push() instanceof 、typeof 闭包 （完）]]></content>
      <categories>
        <category>试题</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>数组</tag>
        <tag>试题</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数声明、函数表达式、匿名函数]]></title>
    <url>%2F2017%2F08%2F29%2F%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E3%80%81%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数声明、函数表达式、匿名函数 本文内容为函数基础，欢迎全段位玩家划水吐槽(^▽^) 一、函数声明、函数表达式的区别 函数声明：function functionName(){} 函数表达式：var fn = function(){} 匿名函数：function(){} 区别：函数声明与函数表达式的区别主要表现在声明前置与函数标识符两部分。 :—: 声明前置 标识符（函数名） 函数声明 函数声明前置 不可省略 函数表达式 变量声明前置 可以省略 匿名函数 无 无 示例： 函数声明不可省略标识符，否则抛出 error SyntaxError 错误，通过 foo 调用； 函数表达式省略了函数标识符，通过 fn 调用 12345678910111213141516// 判断声明前置console.log(foo) // function foo()&#123;console.log('foo: "函数声明"')&#125;console.log(fn) // undefined// 函数声明function foo()&#123;console.log('foo: "函数声明"')&#125;// 函数表达式 var fn = function()&#123;console.log('fn: "函数表达式"')&#125;// 函数表达式声明后打印console.log(fn) // function ()&#123;console.log('fn: "函数表达式"')&#125;// 调用foo() // foo: "函数声明"fn() // fn: "函数表达式" 二、变量的声明前置、函数的声明前置变量的声明前置： 在一个作用域块中，所有的变量声明都会被JS引擎放在作用域块范围的顶部进行； 函数的声明前置： 和变量声明前置一样，执行代码之前会先读取函数声明，只要函数在代码中进行了声明，无论它在作用域块的哪个位置上进行声明，JS引擎都会将它的声明放在作用域块范围的顶部进行； 优先级： 函数声明的优先级高于变量声明的优先级（函数声明 &gt; 变量声明） 示例：利用同名 函数/变量 判断 声明前置的优先级123456789101112131415// 判断声明优先级console.log(foo) // function foo()&#123;console.log("foo")&#125;console.log(fn) // function fn()&#123;console.log("fn")&#125;// 声明：函数 ==&gt; 变量function foo()&#123;console.log("foo")&#125;var foo = 1;// 声明：变量 ==&gt; 函数var fn =2;function fn()&#123;console.log("fn")&#125;// 赋值后打印console.log(foo) // 1console.log(fn) // 2 以上代码正确的执行顺序是：12345678910111213// 因为函数声明优先提升，所以后提升的变量声明把函数声明挤到了后面var foo;var fn;function foo()&#123;console.log("foo")&#125;function fn()&#123;console.log("fn")&#125;// 然后JS引擎从上到下解释运行，后面的函数声明会覆盖掉前面的变量声明console.log(foo) // function foo()&#123;console.log("foo")&#125;console.log(fn) // function fn()&#123;console.log("fn")&#125;foo = 1;fn = 2;console.log(foo) // 1console.log(fn) // 2 三、匿名函数匿名函数在 javascript 中广泛用于赋值、传参、构建闭包等操作。 函数表达式啊咧咧？函数表达式怎么跑这里来了？？？ 没错，函数表达式就是匿名函数的一种应用。 不信你看函数表达式右边，这就是一个把匿名函数赋值给一个变量的过程。12var foo = function()&#123;console.log(1)&#125;foo() // 1 构建闭包闭包是 javascript 最强大的特性之一。它的最大用处有两个，一个是可以读取其他函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 示例：这里只将闭包作为匿名函数的应用示例，并不展开讨论闭包。1234567891011var a = 1000;function foo()&#123; var a = 1; return function()&#123; //匿名函数 a = a + 1; console.log(a) &#125;&#125;var fn = foo()fn() // 2fn() // 3 立即执行函数表达式（IIFE）这是一个写在任何地方都不会抛出 Uncaught SyntaxError 错误的匿名函数 立即执行函数表达式（Immediately-Invoked Function Expression），简称IIFE。表示定义函数之后，立即调用该函数。 作用：隔离作用域，保护私有变量，防止污染全局变量 最常用的两种写法：1(function()&#123; /* code */ &#125;()); 1(function()&#123; /* code */ &#125;)(); 示例：定义之后立即调用1(function(a)&#123;console.log(a)&#125;)(10) // 10 参考：（译）详解javascript立即执行函数表达式（IIFE） ##抛出错误 如果匿名函数直接写成以下形式会抛出 Uncaught SyntaxError 错误，不过相信你也不会这样写，毕竟这样写的话你就没有办法调用它了QAQ1function（）&#123;/*code*/&#125; // Uncaught SyntaxError: （完）]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>闭包</tag>
        <tag>声明前置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试题：作用域链+闭包]]></title>
    <url>%2F2017%2F08%2F29%2F%E8%AF%95%E9%A2%98%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[试题：作用域链 + 闭包在开始阅读本文之前，你可能需要了解包括且不限于以下知识点，否则极有可能会浪费您宝贵的时间。 闭包 作用域 执行上下文 this 自执行函数 伪代码声明本文没有用中文汉字解释每一行代码执行做了哪些事情，但是有很详细的伪代码作为参考，虽然略为繁琐，但如果你将它整理成自己的思路，以后遇到类似的问题就能迅速思考得出答案。 约定： Context 执行上下文 AO 活动对象 Scope 作用域链 先来一道开胃菜，至少可以让我们大概知道每一行伪代码说明了什么。 开胃菜：1234567891011var x = 10bar()function foo() &#123; console.log(x)&#125;function bar()&#123; var x = 30 foo() // 输出什么&#125; 注意： 调用函数的时候，先从该函数体内查找所需的变量，如果没有，再从函数定义的那个作用域查找所需变量。以此类推，直到顶层作用域，如果依旧没有，输出 undefined 以下是我的伪代码规则：伪代码：1234567891011121314151617181920212223242526272829303132333435363738394041/* * 执行上下文 * globalContext = &#123; * 活动对象 * AO: &#123; * x: 10 * foo: function * bar: function * &#125;, * 作用域链 * Scope: null * &#125; * * 声明 foo 时 得到下面 * foo.[[scope]] = globalContext.AO * * 声明 bar 时 得到下面 * bar.[[scope]] = globalContext.AO * * 注意： 在当前的执行上下文内声明的函数，这个函数的[[scope]]就指向当前执行上下文的 AO * * 当调用 bar() 时， 进入 bar 的执行上下文 * * barContext = &#123; * AO: &#123; * x: 30 * &#125;, * Scope: bar.[[scope]] //globalContext.AO * &#125; * * 当调用 foo() 时，先从 bar 执行上下文中的 AO里找foo函数，找不到再从 bar 的 [[scope]]里找找到后即调用 * * 当调用 foo() 时，进入 foo 的执行上下文 * * fooContext = &#123; * AO: &#123;&#125;, * Scope: foo.[[scope]] // globalContext.AO * &#125; * * 所以最后在console中输出 10 * */ ok，开胃菜没有任何难度，接下来上正餐咯 (*^▽^*) 主菜一：123456789101112131415161718var num = 7;var obj = &#123; num: 8, fn: (function () &#123; this.num *= 2; num += 3; num = 6; return function () &#123; this.num *= 5; num += 6; console.log(num); &#125; &#125;)(num)&#125;var fn = obj.fn;fn();obj.fn();console.log(window.num, obj.num); 如需文字说明，请留言注明。以下是每一步操作的伪代码，希望诸君在思考过后再参考：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* * 1. 栈底 ==&gt; 全局上下文 * 执行上下文 * globalContext=&#123; * 活动对象 * AO: &#123; * num: 7, * obj: &#123;&#125;, * (function()&#123;&#125;)(): function, * fn: obj.fn, * fn(): function, * obj.fn(): function * &#125; * 作用域链 * scope: none * &#125; * 通过以上伪代码可以得出以下的作用域链 * (function()&#123;&#125;)().[[scope]] = globalContext.AO * fn().[[scope]] = globalContext.AO * obj.fn().[[scope]] = globalContext.AO * * 2. 自执行函数 * (function()&#123;&#125;)()Context=&#123; * AO: &#123; * (globalContext.AO.num: 14 ==&gt; 17 ==&gt; 6) * (return function(): function) * &#125; * scope: globalContext.AO * &#125; * * 3. fn() * fnContext = &#123; * AO: &#123; * num: 30 ==&gt; 36 * &#125; * scope: globalContext.AO * &#125; * * 4. obj.fn() * step1: * objContext = &#123; * AO: &#123; * num: 8, * fn: function * &#125; * scope: globalContext.AO * &#125; * fn.[[scope]] = objContext.AO * * step2: * obj.fn Context=&#123; * AO: &#123; * (objContext.AO.num: 40) * (globalContext.AO.num: 42) * &#125; * scope: objContext.AO * &#125; * * */ 主菜二：123456789101112131415161718var num = 20;var obj = &#123; num: 30, fn: (function (num) &#123; num += 15; var num = 45; return function () &#123; this.num *= 4; num += 20; console.log(num); &#125; &#125;)(num)&#125;var fn = obj.fn;fn();obj.fn();console.log(window.num, obj.num); 如需文字说明，请留言注明。以下是每一步操作的伪代码，希望诸君在思考过后再参考：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * 1. 栈底 ==&gt; globalContext * globalContext=&#123; * AO: &#123; * num: 20, * obj: &#123;&#125;, * (function()&#123;&#125;)(), * fn: obj.fn, * fn(): function, * obj.fn(): function * &#125; * scope: none * &#125; * (function()&#123;&#125;)().[[scope]] = globalContext.AO * fn().[[scope]] = globalContext.AO * obj.fn().[[scope]] = globalContext.AO * * 2. (function()&#123;&#125;()) * (function()&#123;&#125;())Context = &#123; * AO: &#123; * num: 45 * (return function(): function) * &#125; * scope: globalContext.AO * &#125; * * 3. fn() * fnContext = &#123; * AO: &#123; * (globalContext.AO.num: 80) * ((function()&#123;&#125;()).AO.num: 45 ==&gt; 65) * num: 65 * &#125; * scope: globalContext.AO * &#125; * * 4. obj.fn() * step1: * objContext = &#123; * AO: &#123; * num: 30, * fn: function * &#125; * scope: globalContext.AO * &#125; * fn.[[scope]] = objContext * * step2: * obj.fn()Context = &#123; * AO: &#123; * (objContext.AO.num: 120) * ((function()&#123;&#125;()).AO.num: 65 ==&gt; 85) * num: 85 * &#125; * scope: objContext.AO * &#125; * * */ 本文示例中的伪代码全为个人喜好，没有标准规范，诸君可为自身喜好量身定制，直到自己用的 [ 爽 ] 为止。 另外，诚如本文一开始所说的那样，虽然书写出伪代码能够得出一个精确的答案，但过程比较繁琐，所以应尽量把伪代码变成自己的思路，这样才在实际操作中迅速找到问题所在，解决问题。 （完）]]></content>
      <categories>
        <category>试题</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>闭包</tag>
        <tag>试题</tag>
        <tag>作用域</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leanCloud存储数据]]></title>
    <url>%2F2017%2F08%2F29%2FleanCloud%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据存储</category>
      </categories>
      <tags>
        <tag>leanCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 生命周期（Lifecycle）]]></title>
    <url>%2F2017%2F08%2F27%2FReact-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[React 生命周期（Lifecycle）参考：The Component Lifecycle React 的生命周期包括三个阶段：1231. mount（挂载）2. update（更新）3. unmount（移除） mountmount 就是第一次让组件出现在页面中的过程。这个过程的关键就是 render 方法。React 会将 render 的返回值（一般是虚拟 DOM，也可以是 DOM 或者 null）插入到页面中。 这个过程会暴露几个钩子（hook）方便你往里面加代码： 12341. constructor()2. componentWillMount()3. render()4. componentDidMount() updatemount 之后，如果数据有任何变动，就会来到 update 过程，这个过程有 5 个钩子： 1234567891011121314// - 我要读取 props 啦！componentWillReceiveProps(nextProps)// - 请问要不要更新组件？true / falseshouldComponentUpdate(nextProps, nextState) // - 我要更新组件啦！componentWillUpdate() // - 更新！render() // - 更新完毕啦！componentDidUpdate() unmount当一个组件将要从页面中移除时，会进入 unmount 过程，这个过程就一个钩子： 12// - 我要死啦！componentWillUnmount() 你可以在这个组件死之前做一些清理工作。 总结一般情况下只在这几个钩子里 setState：1234componentWillMount()componentDidMount()componentWillReceiveProps(nextProps, nextState) componentDidUpdate() 参考：React lifecycle cheatsheet]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 基础入门实例]]></title>
    <url>%2F2017%2F08%2F25%2FReact-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[react 基本语法一、ReactDOM.render()ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 1234ReactDOM.render( &lt;h1&gt;Hello React&lt;/h1&gt;, document.getElementById("example")) 二、JSX 语法HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写. JSX 的基本语法规则： 遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析； 遇到 代码块 （以 { 开头），就用 JavaScript 规则解析。 1234567891011121314var names = ['傻龙', '大鳖', '大宝', '煜神'];ReactDOM.render( &lt;div&gt; &#123; // map会返回一个新数组，不对原数组产生影响,foreach不会产生新数组， // map因为返回数组所以可以链式操作，foreach不能 names.map(function (name, index) &#123; return &lt;div key=&#123;index&#125;&gt;Hello &#123;name&#125;&lt;/div&gt; &#125;) &#125; &lt;/div&gt;, document.getElementById('example')) JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员，添加到模板， 123456789var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;,];ReactDOM.render( //如果这个变量是一个数组，JSX 会把它的所有成员，添加到模板 &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById(&apos;example&apos;)); 三、组件React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。 React.createClass() 方法就用于生成一个组件类 123456789101112131415var HelloMessage = React.createClass(&#123; render: function () &#123; return ( //class 跟 for 是js的保留字，所以使用规则如下： &lt;div className="thisIsClass" htmlFor='thisIsFor'&gt; &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;)ReactDOM.render( &lt;HelloMessage name="Albert"/&gt;, document.getElementById("example")) 上面代码中，变量 HelloMessage 就是一个组件类。模板插入 &lt;HelloMessage /&gt; 时，会自动生生成 HelloMessage 的一个实例。 所有组件类都必须有自己的 render 方法，用于输出组件。 注意，组件类的第一个字母必须大写，否则会报错，比如HelloMessage不能写成helloMessage。 另外，组件类只能包含一个顶层标签，否则也会报错。 组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 &lt;HelloMessage name=&quot;Albert&quot;&gt; ，就是 HelloMessage 组件加入一个 name 属性，值为 Albert。 组件的属性可以在组件类的 this.props 对象上获取，比如 name 属性就可以通过 this.props.name 读取。 因为 class 和 for 是 JavaScript 的保留字，所以添加组件属性时，有一个地方需要注意： class 属性需要写成 className ； for 属性需要写成 htmlFor ； 四、this.props.childrenthis.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点。 1234567891011121314151617181920212223var NotesList = React.createClass(&#123; render: function () &#123; return ( &lt;ol&gt; &#123; //this.props.children 表示组件的所有子节点 React.Children.map(this.props.children, function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ol&gt; ); &#125;&#125;);ReactDOM.render( &lt;NotesList&gt; &#123;/*以下就是组件的两个子节点*/&#125; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.getElementById('example')); 上面代码的 NoteList 组件有两个 span 子节点，它们都可以通过 this.props.children 读取 这里需要注意， this.props.children 的值有三种可能： 如果当前组件没有子节点，它就是 undefined ; 如果有一个子节点，数据类型是 object ； 如果有多个子节点，数据类型就是 array ； 但是 ，好在 React 提供一个工具方法 React.Children 来处理 this.props.children 。 我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。 更多的 React.Children 的方法，请参考官方文档。 五、PropTypes组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。 组件类的 PropTypes 属性，就是用来验证组件实例的属性是否符合要求。 12345678910111213141516171819202122232425// 如果把引号去掉就是数值类型，就会报错var data = "string!";var MyTitle = React.createClass(&#123; PropTypes: &#123; //通过 React.PropTypes 规定 title 接受值的类型 title: React.PropTypes.string.isRequired &#125;, //设置组件属性的默认值 getDefaultProps: function () &#123; return &#123; title: "hello world" &#125; &#125;, render: function () &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;MyTitle title=&#123;data&#125;/&gt;, document.getElementById('example')); 上面的 Mytitle 组件有一个 title 属性。PropTypes 告诉 React，这个 title 属性是必须的，而且它的值必须是字符串。 此外，getDefaultProps 方法可以用来设置组件属性的默认值。 六、获取真实的DOM节点组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。 但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性 12345678910111213141516171819202122var Component = React.createClass(&#123; handleClick: function () &#123; //this.refs.[refName].[handler] this.refs.refName.focus() &#125;, render: function () &#123; return ( &lt;div&gt; &#123;/* ref：为了从组件获取真实 DOM 节点 */&#125; &lt;input type="text" ref="refName" /&gt; &lt;input type="button" value="focus the text input" onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ) &#125;&#125;);ReactDOM.render( &lt;Component /&gt;, document.getElementById("example")) Component 组件中的输入框用于获取用户的输入，这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。 需要注意的是，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 Click 事件的回调函数，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性。 七、this.state组件免不了要与用户互动，React 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI 123456789101112131415161718192021var LikeButton = React.createClass(&#123; getInitialState: function () &#123; return &#123;liked: false&#125; &#125;, handleClick: function () &#123; this.setState(&#123;liked: !this.state.liked&#125;) &#125;, render: function () &#123; var text = this.state.liked ? "like" : "haven\'t liked"; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ) &#125;&#125;)ReactDOM.render( &lt;LikeButton/&gt;, document.getElementById('example')); 上面代码是一个 LikeButton 组件，它的 getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。 当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。 由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。 八、表单用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取。 1234567891011121314151617181920212223242526var Input = React.createClass(&#123; //初始化 this.state getInitialState: function () &#123; return &#123;value: "init"&#125; &#125;, //setState 改变 this.state 的值 //event.target.value 读取表单值 handleChange: function (event) &#123; this.setState(&#123;value: event.target.value&#125;) &#125;, render: function () &#123; var value = this.state.value; return ( &lt;div&gt; &#123;/*回调函数触发*/&#125; &lt;input type="text" value=&#123;value&#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;)ReactDOM.render( &lt;Input/&gt;, document.getElementById('example')); 上面代码中，文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。 textarea 元素、select元素、radio元素都属于这种情况，更多介绍请参考官方文档。 九、组件的生命周期组件的生命周期分成三个状态：123- Mounting：已插入真实 DOM- Updating：正在被重新渲染- Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。1234567- componentWillMount()- componentDidMount()- componentWillUpdate(object nextProps, object nextState)- componentDidUpdate(object prevProps, object prevState)- componentWillUnmount() 此外，React 还提供两种特殊状态的处理函数。 123- componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用- shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 这些方法的详细说明，可以参[考官方文档]。(http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods) 123456789101112131415161718192021222324252627282930313233var Hello = React.createClass(&#123; getInitialState: function () &#123; return &#123; opacity: 1 &#125;; &#125;, //插入真实 DOM 之后调用 componentDidMount: function () &#123; this.timer = setInterval(function () &#123; var opacity = this.state.opacity; opacity -= .05; if (opacity &lt; .1) &#123; opacity = 1; &#125; this.setState(&#123; opacity: opacity &#125;); //bind(this) 绑定自定义函数的 this &#125;.bind(this), 100) &#125;, render: function () &#123; return ( &lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt; Hello &#123;this.props.name&#125; &lt;/div&gt; ); &#125;,&#125;);ReactDOM.render( &lt;Hello name="World"/&gt;, document.getElementById("example")) 上面代码在Hello组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。 另外，组件的style属性的设置方式也值得注意，不能写成1style="opacity:&#123;this.state.opacity&#125;;" 而要写成1style=&#123;&#123;opacity: this.state.opacity&#125;&#125; 这是因为 React 组件样式 一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。 十、Ajax组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 componentDidMount 方法设置 Ajax 请求，等到请求成功，再用 this.setState 方法重新渲染 UI 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 定义一个 RepoList 组件var RepoList = React.createClass(&#123; // 初始化 this.state getInitialState: function () &#123; return &#123; loading: true, error: null, data: null &#125;; &#125;, // 组件添加到真实 DOM 后调用 componentDidMount() &#123; // 定义一个 promise this.props.promise.then( // promise 延时成功 value =&gt; &#123; // 改变 loading 状态，data 数据 this.setState(&#123;loading: false, data: value&#125;) &#125;, // promise 延时失败 改变 loading 状态，error 数据 error =&gt; this.setState(&#123;loading: false, error: error&#125;)); &#125;, // 渲染函数 render: function () &#123; // promise pending ... if (this.state.loading) &#123; return &lt;span&gt;Loading...&lt;/span&gt;; &#125; // promise reject! else if (this.state.error !== null) &#123; return &lt;span&gt;Error: &#123;this.state.error.message&#125;&lt;/span&gt;; &#125; else &#123; // 成功请求到数据，添加到变量和标签中 var repos = this.state.data.items; // 遍历 ajax 请求存储好的数据 var repoList = repos.map(function (repo, index) &#123; // 循环创建jsx html 标签，返回保存到repoList return ( &lt;li key=&#123;index&#125;&gt;&lt;a href=&#123;repo.html_url&#125;&gt;&#123;repo.name&#125;&lt;/a&gt; (&#123;repo.stargazers_count&#125; stars) &lt;br/&gt; &#123;repo.description&#125;&lt;/li&gt; ); &#125;); // 返回 创建 jsx html 标签并将 repolist 添加进去 return ( &lt;main&gt; &lt;h1&gt;Most Popular JavaScript Projects in Github&lt;/h1&gt; &lt;ol&gt;&#123;repoList&#125;&lt;/ol&gt; &lt;/main&gt; ); &#125; &#125;&#125;);// 插入 DOMReactDOM.render( // AJAX 请求数据 &lt;RepoList promise=&#123;$.getJSON('https://api.github.com/search/repositories?q=javascript&amp;sort=stars')&#125;/&gt;, document.getElementById('example')); 如果Promise对象正在抓取数据（pending状态），组件显示”正在加载”；如果Promise对象报错（rejected状态），组件显示报错信息；如果Promise对象抓取数据成功（fulfilled状态），组件显示获取的数据。 参考：React 入门实例教程]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Albert's Favorites]]></title>
    <url>%2F2017%2F08%2F25%2FAlbert-s-Favorites%2F</url>
    <content type="text"><![CDATA[CSS Flex 布局教程：语法篇-阮一峰 Flex 布局教程：实例篇-阮一峰 张鑫旭的个人博客 大漠的个人博客w3cplus JS JavaScript 标准参考教程（alpha）-阮一峰 ECMAScript 6 入门-阮一峰 JavaScript秘密花园 ES 5 新增特性汇总 JavaScript Promise迷你书（中文版） 【翻译】Promises/A+规范 React facebook：官方文档 FCC：中文翻译 极客学院：中文翻译 知乎：setState：这个API设计到底怎么样 阮一峰：React 技术栈系列教程 知乎：从零学习React技术栈 React China 掘金：React 开源项目合集整理 博文你真的会使用XMLHttpRequest吗？ webpack：从入门到真实项目配置]]></content>
      <categories>
        <category>收藏夹</category>
      </categories>
      <tags>
        <tag>收藏夹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用CSS3实现一个立方体]]></title>
    <url>%2F2017%2F08%2F25%2F%E7%94%A8CSS3%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AB%8B%E6%96%B9%E4%BD%93%2F</url>
    <content type="text"></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详说 Cookie, LocalStorage 与 SessionStorage]]></title>
    <url>%2F2017%2F08%2F24%2F%E8%AF%A6%E8%AF%B4-Cookie-LocalStorage-%E4%B8%8E-SessionStorage%2F</url>
    <content type="text"><![CDATA[Cookie, LocalStorage 与 SessionStorage具体 Web Storage API 的使用可以参考 MDN的文档 基本概念CookieCookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。 localStoragelocalStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。 特性 Chrome Firefox (Gecko) Internet Explorer Opera Safari (WebKit) localStorage 4 3.5 8 10.50 4 sessionStorage 5 2 8 10.50 4 sessionStoragesessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。 三者的异同 特性 Cookie localStorage sessionStorage 数据的生命期 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 一般为5MB &lt;= 同localStorage 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 &lt;= 同localStorage 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 &lt;= 同localStorage 应用场景有了对上面这些差别的直观理解，我们就可以讨论三者的应用场景了。 因为考虑到每个 HTTP 请求都会带着 Cookie 的信息，所以 Cookie 当然是能精简就精简啦，比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。曾经还使用 Cookie 来保存用户在电商网站的购物车信息，如今有了 localStorage，似乎在这个方面也可以给 Cookie 放个假了~ 而另一方面 localStorage 接替了 Cookie 管理购物车的工作，同时也能胜任其他一些工作。比如HTML5游戏通常会产生一些本地数据，localStorage 也是非常适用的。如果遇到一些内容特别多的表单，为了优化用户体验，我们可能要把表单页面拆分成多个子页面，然后按步骤引导用户填写。这时候 sessionStorage 的作用就发挥出来了。 安全性的考虑需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为。所以千万不要用它们存储你系统中的敏感数据。 参考资料 what is the difference between localStorage, sessionStorage, session and cookie? HTML5 localStorage security 维基百科 - Cookie Web Storage API 浏览器本地数据（sessionStorage、localStorage、cookie）与server端数据 HTMl5的sessionStorage和localStorage HTML5 LocalStorage 本地存储 转自：详说 Cookie, LocalStorage 与 SessionStorage]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[低版本IE支持HTML5]]></title>
    <url>%2F2017%2F08%2F24%2F%E4%BD%8E%E7%89%88%E6%9C%ACIE%E6%94%AF%E6%8C%81HTML5%2F</url>
    <content type="text"><![CDATA[如何让低版本的 IE 支持 HTML5新标签1. 利用条件注释针对 IE 来调用这个 JS 文件。Opera，FireFox 等其他非 IE 浏览器就会忽视这段代码，也不会存在 http 请求。引用 html5shiv.js 文件，代码内容可以自己下载下来看。 BootCDN-html5shiv 123&lt;!--[if lt IE 9]&gt; &lt;script src="bower_components/html5shiv/dist/html5shiv.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 将以上代码放到 head 标签区间，由于现在国内网络环境（你懂的QAQ），直接引入外部 JS会让网页打开非常慢，所以建议大家先下载到服务器上，再进行本地文件的引用。 更多细节参考：The HTML5 Shiv 2. 用JS创建元素，然后添加CSS属性：1234567// 页面头部(function () &#123; var a = ['article', 'aside', 'details', 'figcaption', 'figure', 'footer', 'header', 'hgroup', 'nav', 'section']; for (var i = 0, j = a.length; i &lt; j; i++) &#123; document.createElement(a[i]); &#125;&#125;)(); 同理，可以用类数组转为数组： 12345678910111213// 页面头部function createHtml5Mark() &#123; // arguments 序列化成数组 var args = Array.prototype.slice.call(arguments, 0); argLen = args.length, doc = document; // 循环数据创建元素 for (var i = 0; i &lt; argLen; i++) &#123; doc.createElement(args[i]); &#125;&#125;createHtml5Mark('article', 'aside', 'details', 'figcaption', 'figure', 'footer', 'header', 'hgroup', 'nav', 'section'); 最后，需要在CSS添加属性： 1section,article,nav,header,footer&#123;display:block;&#125; （完）]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>IE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5入坑简单概览]]></title>
    <url>%2F2017%2F08%2F24%2FHTML5%E5%85%A5%E5%9D%91%E7%AE%80%E5%8D%95%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[HTML5 概览 本文概览：HTML5 新特性；标签的变化；属性的变化；新增的标签 HTML5是什么？ HTML5是超文本标记语言的第五次重大修改，2014年10月29日标准规范制定完成。 设计目的 HTML5 的设计目的是为了在移动设备上支持多媒体。新的语法特征被引进以支持这一点，如 video 、audio 和 canvas 标记。 HTML5 还引进了新的功能，可以真正改变用户与文档的交互方式，包括： 新的解析规则增强了灵活性 新属性 淘汰过时的或冗余的属性 一个HTML5文档到另一个文档间的拖放功能 离线编辑 信息传递的增强 详细的解析规则 多用途互联网邮件扩展（MIME）和协议处理程序注册 在SQL数据库中存储数据的通用标准（Web SQL） 有哪些新特性？MDN-HTML5 1. 语义特性HTML5 赋予网页更好的意义和结构。更加丰富的标签将随着对 RDFa，微数据与微格式等方面的支持，构建对程序、对用户都更有价值的数据驱动的Web。 2. 本地存储特性基于 HTML5 开发的网页APP拥有更短的启动时间，更快的联网速度，这些全得益于 HTML5 APP Cache ，以及本地存储功能。Indexed DB（HTML5本地存储最重要的技术之一）和 API 说明文档。 3. 设备兼容特性从 Geolocation 功能的API文档公开以来，HTML5 为网页应用开发者们提供了更多功能上的优化选择，带来了更多体验功能的优势。HTML5 提供了前所未有的数据与应用接入开放接口。使外部应用可以直接与浏览器内部的数据直接相连，例如视频影音可直接与microphones及摄像头相联。 4. 连接特性更有效的连接工作效率，使得基于页面的实时聊天，更快速的网页游戏体验，更优化的在线交流得到了实现。HTML5 拥有更有效的服务器推送技术，Server-Sent Events 和 WebSocket 就是其中的两个特性，这两个特性能够帮助我们实现服务器将数据“推送”到客户端的功能。 5. 网页多媒体特性 支持网页端的 audio 、video 等多媒体功能。 三维、图形及特效特性（Class: 3D, Graphics &amp; Effects） 基于 SVG、Canvas、WebGL 及CSS3 的 3D 功能，用户会惊叹于在浏览器中，所呈现的惊人视觉效果。 6. 性能与集成特性没有用户会永远等待你的Loading —— HTML5会通过 XMLHttpRequest2 等技术，解决以前的跨域等问题，帮助您的Web应用和网站在多样化的环境中更快速的工作。 7. CSS3特性在不牺牲性能和语义结构的前提下，CSS3 中提供了更多的风格和更强的效果。此外，较之以前的Web排版，Web的开放字体格式（WOFF）也提供了更高的灵活性和控制性。 关于标签1. 标签变化 DOCTYPE 1&lt;!DOCTYPE html&gt; 文档编码 1&lt;meta charset=&quot;UTF-8&quot; /&gt; 标签结尾 在 HTML5 中对于一些标签不再是必要的：（但是建议每个标签都要结束）li , dt , dd , p , rt , rp , optgroup , option , colgroup , thead , tbody , tfoot , tr , td , th 自结束的标签最后的 / 也不再必要img , input , br , hr 等 2. 属性变化2.1 具有 boolean 值的属性对于具有 boolean 值的属性，例如 disable 和 readonly 等，只写属性不写属性值时，其默认值为 true1234&lt;!-- 以下三条 checked 全部为选中状态 --&gt;&lt;input type=&quot;checkbox&quot; checked &gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; &gt;&lt;input type=&quot;checkbox&quot; checked=&quot;&quot; &gt; 2.2 省略属性值的引号属性值可以用单引号或者双引号，在属性值不包括 &lt;、&gt;、=、&#39;、&quot;时可以忽略引号12&lt;!-- 这里的text就省略了引号 --&gt;&lt;input type=text &gt; 2.3 input 新增 type注意：日期与时间相关的 type 目前均存在bugMDN：HTML元素参考-input1234567891011121314151617181920&lt;!-- 提交表单会自动验证是否为邮箱、电话、URL --&gt;&lt;input type=&quot;email&quot;&gt;&lt;input type=&quot;tel&quot;&gt;&lt;input type=&quot;url&quot;&gt;&lt;!-- 非数字无法输入 --&gt;&lt;input type=&quot;number&quot;&gt;&lt;!-- 一个指示范围的横向滚动条 --&gt;&lt;input type=&quot;range&quot;&gt;&lt;!-- 搜索框 --&gt;&lt;input type=&quot;search&quot;&gt;&lt;!-- 日期与时间（不建议使用） --&gt;&lt;input type=&quot;date&quot;&gt;&lt;input type=&quot;month&quot;&gt;&lt;input type=&quot;week&quot;&gt;&lt;input type=&quot;time&quot;&gt;&lt;input type=&quot;datetime-local&quot;&gt; 2.4 移除的元素 能被CSS替代的元素basefont , big , center , font , s , u , tt ,strike 不再使用frame框架frame , frameset , noframes 其它rb =&gt; rubyacronym =&gt; abbrdir =&gt; ulisindex =&gt; inputlisting =&gt; prexmp =&gt; codenextid =&gt; CUIDSplaintext =&gt; text/plain 2.5 新增属性 全局属性contentEditable , designMode , hidden , spellcheck , tabindex 表单相关autofocus , placeholder , form , required , novalidateformaction , formenctype , formmethod , formtarget , formnovalidate 链接相关a和area新增medialink新增sizes属性base新增target属性area新增hreflang和rel 其它ol新增reversedmeta新增charsetmenu新增type和labelstyle新增scopedscript新增asynchtml新增manifestiframe新增sandbox， seamless， srcdoc 2.6 废弃属性废弃的元素和属性 3. 新增标签 元素 描述 canvas 标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API audio 定义音频内容 video 定义视频（video 或者 movie） source 定义多媒体资源 &lt;video&gt; 和&lt;audio&gt; embed 定义嵌入的内容，比如插件 track 为诸如 &lt;video&gt; 和 &lt;audio&gt; 元素之类的媒介规定外部文本轨道 datalist 定义选项列表。与 input 元素配合使用该元素，来定义 input 可能的值 keygen 规定用于表单的密钥对生成器字段 output 定义不同类型的输出，比如脚本的输出 article 定义页面正文内容 aside 定义页面内容之外的内容 bdi 设置一段文本，使其脱离其父元素的文本方向设置 command 定义命令按钮，比如单选按钮、复选框或按钮 details 用于描述文档或文档某个部分的细节 dialog 定义对话框，比如提示框 summary 标签包含 details 元素的标题 figure 规定独立的流内容（图像、图表、照片、代码等等） figcaption 定义 &lt;figure&gt; 元素的标题 footer 定义 section 或 document 的页脚 header 定义了文档的头部区域 mark 定义带有记号的文本 meter 定义度量衡。仅用于已知最大和最小值的度量 nav 导航 progress 定义任何类型的任务的进度 ruby 定义 ruby 注释（中文注音或字符） rt 定义字符（中文注音或字符）的解释或发音 rp 在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容 section 定义文档中的节（section、区段） time 定义日期或时间 wbr 规定在文本中的何处适合添加换行符 参考 w3school：HTML 参考手册 MDN：HTML5 MDN：HTML5 标签列表 HTML5 学习笔记简明版 知乎：HTML5 到底是什么？ （完）]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim常用基础命令整理]]></title>
    <url>%2F2017%2F08%2F22%2Fvim%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[@vim | center #vim常用基础命令整理 1.进入Vim 编辑器1vim 文件名 &lt;回车&gt; 2.退出 Vim 编辑器 放弃所有改动 1&lt;ESC&gt; :q! &lt;回车&gt; //q=Quit ; !=强制执行 ； 保存改动 1&lt;ESC&gt; :wq &lt;回车&gt; //w=Write ; q=Quit ; 3.删除光标所在位置的字符1x 4.在光标前插入文本1i 输入欲插入文本 &lt;ESC&gt; 5.在一行后插入文本1A 输入欲添加文本 &lt;ESC&gt; 6.从当前光标删除至下一个单词1dw //d=Delete ; w=Word ; 7.从当前光标删除至当前行末尾1d$ 8.删除整行1dd 9.重复一个动作1operator [number] motion 123operator - 操作符，代表要做的事情，比如 d 代表删除[number] - 可以附加的数字，代表动作重复的次数motion - 动作，代表在所操作的文本上的移动 1234例如 ：2w //从光标开始偏移2个单词d2w //从光标开始删除2个单词w 代表单词(word)，$ 代表行末等等。 10.移动光标到行首10 //数字0键 11.撤销相关123u //小写的u，撤消以前的操作U //大写的U，撤消在一行中所做的所有改动CTRL-R //撤消以前的撤消命令 12.要重新置入已经删除的文本内容1p //删除的内容留在寄存器中，把p想成paste 12该操作可以将已删除的文本内容置于光标之后。如删除的是一个整行，操作将置于当前光标所在行的下一行。 13.要替换光标所在位置的字符12r 新字符 // 替换单个字符R 新字符 &lt;ESC&gt; // 替换多个字符 14.更改命令c1c [number] motion // 参数同9. 15.定位及文件状态1234CTRL-G //显示当前光标所在行的位置以及文件状态信息数字 G //（这里G大写）直接跳转到文件中的某一指定行G //当前光标直接跳转到文件最后一行gg //当前光标直接跳转到文件第一行 16.搜索类命令1/ 要搜索的字符 &lt;回车&gt; //在当前文件中查找该字符串 12n //正向查找同上一次的字符N //向相反方向查找同上一次的字符 1? 要搜索的字符 &lt;回车&gt; //同N，反向查找字符 12:set ic //忽略大小写ignorecase:set noic //禁用忽略大小写 12:set hls is //设置 高亮显示所有的匹配短语hlsearch 和 查找短语时显示部分匹配incsearch 这两个选项，:nohlsearch //移除匹配项的高亮显示 12CTRL-O //字母o，回到之前的位置，重复可回退多步CTRL-I //跳转到较新的位置 17.配对括号的查找1% //在第一个括号处按下%，光标将跳转到闭合处，再次按下将回跳 18.替换命令1:s/字符1/字符2/g //将光标所在行中所有的 字符1 替换为 字符2 1:#,#s/old/new/g // #,# 代表的是替换操作的若干行中首尾两行的行号 1:%s/old/new/g //替换整个文件中的每个匹配字符old替换为字符new 1:%s/old/new/gc //找到整个文件中的每个匹配字符，并且对每个匹配字符提示是否进行替换 19.在VIM内执行外部命令1:!command //执行一个外部命令command 123例如:!ls //显示当前目录内容:!rm FILENAME //删除名为FILENAME的文件 20.保存命令12:w TEST //以 TEST 为文件名保存整个文件v motion :w FILENAME //选择性保存文件的部分内容，按v并移动光标以选择 21.提取与合并12:r FILENAME //将FILENAME内容提取并插入到光标后:r !ls //读取 ls 命令的输出结果，并将其插入在光标后 22.打开新的一行 12o //小写字母o，在光标下方打开新的一行,并进入插入模式O //大写字母O，在光标上方打开新的一行,并进入插入模式 23.插入文本12a 要插入的文本 //在光标后插入文本A 要插入的文本 //在光标所在行的行末插入文本 24.复制粘贴1v 光标移动选择内容 y 移动光标到要粘贴的位置 p //v选择，y复制，p粘贴 25.获取帮助信息123- 按下 &lt;HELP&gt; 键 (如果键盘上有的话)- 按下 &lt;F1&gt; 键 (如果键盘上有的话)- 输入 :help &lt;回车&gt; 12CTRL-W //使光标在窗口之间跳转:q &lt;回车&gt; //关闭帮助窗口 26.创建启动脚本及vimrc配置123:edit ~/.vimrc //Unix所使用的命令:edit $VIM/_vimrc //MS-Windows所使用的命令:write //保存文件 12:r $VIMRUNTIME/vimrc_example.vim //读取vimrc 示例文件的内容:help vimrc-intro //获取vimrc配置帮助 27.命令补全1:e CTRL-D &lt;TAB&gt; //Vim 会显示以 e 开始的命令的列表，TAB选择补全]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础入坑（二）]]></title>
    <url>%2F2017%2F08%2F22%2Fwebpack%E5%9F%BA%E7%A1%80%E5%85%A5%E5%9D%91%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[webpack基础入坑（二 接上回 上回主要操作了指南的 Installation 与 GettingStarted 这两部分，这时候我们大概能猜出 webpack 的某些功能了： 使用各种 loader 加载不同的资源 把所有资源打包起来 bundle.js我们可以阅读一下最后生成的 bundle.js（可以写几个简单的JS文件打包，参数部分看起来会更方便一些）bundle.js 是一个并不复杂的自执行函数（每一行都有代码注释）容主要由两部分组成： webpackBootstrap 函数入口，主体部分打包的功能就在这部分，有兴趣的话可以看一下每一行的功能，大致就是把每个模块call一下，然后把模块保存到 installedModules 里，然后需要用到的时候可以直接调用。 参数部分传入一个数组，数组的每一项都是一个模块，每个模块都有一个独立的模块ID，模块需要其他依赖时直接通过模块ID来调用。 就此打住，这篇文章主题并不在讲 bundle.js。 JS 压缩webpack打包之后我们发现 dist/bundle.js 有800KB，因为我们引入了 lodash 和 jQuery 这两个库，但是并没有压缩代码，那么如何压缩呢？方法很多，其中最简单的一种就是使用 webpack 自带的压缩插件 UglifyJsPlugin： 我们修改一下 npm scripts 的配置，添加一个字段启动webpack的压缩功能：1"build-p": "webpack -p" 重新运行命令打包文件，得到的 bundle.js 就是一个压缩过的文件。 更多使用方法参考这里：UglifyJS 1npm run build-p 运行帮助命令查看 -p 参数的具体功能1234./node_modules/.bin/webpack --help# 找到如下介绍-p shortcut for --optimize-minimize --define process.env.NODE_ENV="production" 123webpack -p# 相当于以下命令webpack --optimize-minimize --define process.env.NODE_ENV="'production'" 它会执行如下步骤： 使用 UglifyJsPlugin 进行 JS 文件压缩 运行 LoaderOptionsPlugin 设置 NodeJS 环境变量，触发某些 package 包，以不同的方式进行编译。 开发环境每次改完代码都要运行一次打包命令是不是很烦人？没关系，webpack 肯定也考虑到了，于是乎我们就可以通过 webpack 自带的监听功能自动监听文件变动然后执行编译。 Development 这一章节就是专门介绍如何快速开发的。 1. 调整编辑器首先，我们先拉到文章底部，按照它的要求调整我们的编辑器： 2. Source Maps调整好编辑器后我们再返回页面顶部，找到Source Maps功能：将编译后的代码映射回原始源代码，如果某个源文件中存在错误，source map会追踪到错误和警告在源代码中的原始位置，方便代码调试。123456789 var path = require('path'); module.exports = &#123; entry: './src/index.js',+ devtool: 'inline-source-map', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125; &#125;; 故意改错源文件中的代码，然后运行 npm run build 打包，然后在浏览器控制台你会发现 bundle.js 的报错会指向源文件。 3. Watch Mode再修改一下 npm scripts 的配置，添加一个字段以启动监听模式：1"watch": "webpack --watch" 运行 npm run watch12npm run watch# 运行成功直接编译然后光标继续闪动表示监听中... 如果你想要退出，请按 Ctrl+c 好了现在我们试一下这个监听功能，我们随便修改一个文件内容，按 Ctrl+s 保存。 切换回命令行，你会发现 webpack 自动执行了编译操作。 4. webpack-dev-server此功能能够让你的浏览器自动刷新，是不是棒棒哒~（虽然很多编辑器也都有这个功能=。=） 按照老规矩，第一步添加修改 npm scripts 的配置，添加一个字段以启动开发服务器：1"start": "webpack-dev-server --open" 修改 webpack.config.js ，在 module.exports 对象中添加一个字段 devServer ，告知 webpack-dev-server 将指定目录下的文件作为可访问文件。123devServer: &#123; contentBase: './'&#125;, 运行 npm run start 启动服务器，然后浏览器就会自动打开 http://localhost:8080/ ，你会看到 index.html 页面。1npm run start 接下来如果我们改一下 src/index.js，你就会发现 bundle.js 自动打包 http://localhost:8080/ 自动刷新 注意：期间 dist/bundle.js 不会自动变化，在部署代码之前，依然要运行 npm run build 才行。 5. webpack-dev-middleware功能与 webpack-dev-server 类似，新手入坑不建议使用 webpack-dev-middleware （完）]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础入坑（一）]]></title>
    <url>%2F2017%2F08%2F22%2Fwebpack%E5%9F%BA%E7%A1%80%E5%85%A5%E5%9D%91%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[webpck 基础入坑（一）安装这里有webpack发布的所有版本：https://github.com/webpack/webpack/releases 当然你也可以直接通过 npm 命令安装：1npm install --save-dev webpack 如果你要体验最新版本的webpack请使用以下命令安装：1npm install webpack@beta 文档Google 搜索 webpack 第一条结果：https://webpack.github.io/ 页面中指明了三个链接： documentation - 文档所有功能的罗列，文档一般不是按照从易到难的顺序给出，但是肯定包含的几乎所有功能的介绍。 introducation - 介绍简单说明了 webpack 的作用和基本概念。 tutorial - 教程比较容易上手，教你一步一步自学 webpack 需要中文的小伙伴请点这里：https://doc.webpack-china.org/ 实践（抄写）点开 tutorial - 教程 ，然后一行一行地复制里面的命令：123456# 新建并进入 webpack-demo 目录mkdir webpack-demo &amp;&amp; cd webpack-demo# npm 初始化一个 package.jsonnpm init -y# 安装 webpack 作为开发依赖npm install --save-dev webpack ps: 安装过慢请自行切换国内淘宝源 按教程上说的做123456# 新建一个index.hrmltouch index.html# 新建一个src文件夹mkdir src# 在src文件夹内新建一个index.jscd src &amp;&amp; touch index.js 现在你的目录结构是这样的：12345webpack-demo|- package.json|- index.html|- /src |- index.js ok，咱们继续抄12345678910function component() &#123; var element = document.createElement('div'); // Lodash, currently included via a script, is required for this line to work element.innerHTML = _.join(['Hello', 'webpack'], ' '); return element;&#125;document.body.appendChild(component()); 注意上面代码中的 _.join ，这个 _ 实际上是 lodash 暴露的全局变量。 编辑 webpack-demo 目录下的 index.html123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/lodash@4.16.6&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;./src/index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 为了使用 lodash，HTML 使用 script 引入了 lodash v4.16.6。 教程里说这样引用逼格太低，我们可以用更高端的方法引入安装 lodash 为必要依赖123# 请先确保命令行当前所在目录是 webpack-demonpm install --save lodash# 上面命令可以简写成 npm i -S lodash 好了，lodash 的源代码已经下载到 ./node_modules/lodash/ 目录中。 然后在 src/index.js 的第一行添加12import _ from 'lodash';// 然后是function component () &#123; 意思是从 lodash 里得到默认导出，并将默认导出命名为 _，这个 _ 可以换成任何一个其他的变量名。 然后按照教程说的把 index.html 也改了12345678910 &lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt;- &lt;script src="https://unpkg.com/lodash@4.16.6"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;- &lt;script src="./src/index.js"&gt;&lt;/script&gt;+ &lt;script src="./dist/bundle.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 然后命令行输入：1./node_modules/.bin/webpack app/index.js dist/bundle.js 12# 如果你是全局安装的webpack直接运行以下代码webpack app/index.js dist/bundle.js 在浏览器中打开 index.html，如果你看到’Hello webpack’ 说明运行成功。 这是目前的文件结构：1234567|- src |- index.js|- dist |- bundle.js|- index.html|- node_modules/|- package.json ./node_modules/.bin/webpack app/index.js dist/bundle.js 将 src/index.js 转化成 dist/bundle.js index.html 引用的是 dist/bundle.js lodash 安装在 node_modules 里，在index.js中用import引用 webpack 也安装在 node_modules里，./node_modules/.bin/webpack 是一个可执行文件 webpack、lodash 的版本号都被写在 package.json 里 修改引入 jQuery如果我们要在页面中引入 jQuery，先安装：12# 确定你在 webpack-demo 目录npm i -S jquery 以上命令相当于：1npm install --save jquery 然后 jquery 模块就被下载到了 node_modules 中。 然后我们继续在 src./index.js 中引入 jquery123456789101112131415 import _ from 'lodash'+import j from 'jquery' function component () &#123;- var element = document.createElement('div');+ var element = j('&lt;div&gt;&lt;/div&gt;');- element.innerHTML = _.join(['Hello','webpack'], ' ');+ element.html(_.join(['Hello','webpack'], ' '))- return element;+ return element.get(0); &#125; document.body.appendChild(component()); 然后再次运行1./node_modules/.bin/webpack app/index.js dist/bundle.js 打开 index.html。如果你看到 “Hello webpack”，那就说明 jquery 也成功引入，只不过我们把它命名为 j，显然命名为 $ 更符合习惯，你可以自己改一下试试！ 改进上面每次都要运行 ./node_modules/.bin/webpack app/index.js dist/bundle.js 实在是烦人，教程里给出了方法：123# 确保你在项目根目录 webpack-demo# 新建一个 webpack.config.js 文件touch webpack.config.js 然后编辑它：123456789var path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;; output 出口设置，必须是绝对路径，因此在第一行引入 path 模块，方便路径的设置； entry 入口设置，可以是相对路径； filename 输出的文件名； 然后命令行运行：1./node_modules/.bin/webpack --config webpack.config.js 不过这句话依然很长，每次输入很麻烦，教程又教了一个办法：使用 npm-scripts 修改 package.json12345 "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",+ "build": "webpack" &#125;, "keywords": [], 然后命令行运行：1npm run build 说明运行 npm run build 就等于运行 node_modules 里的 webpack 可执行文件，这个可执行文件会找到项目根目录下的 webpack.config.js 并按照其中的设置执行对应的操作 最后再看一下文件目录：123456789webpack-demo|- /src |- index.js|- /dist |- bundle.js|- index.html|- webpack.config.js|- /node_modules|- package.json （完）]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章彻底入门 SCSS]]></title>
    <url>%2F2017%2F08%2F21%2F%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%BD%BB%E5%BA%95%E5%85%A5%E9%97%A8%20SCSS%2F</url>
    <content type="text"><![CDATA[SCSS 起飞指南 写在前面：本文看起来比较长，其实是罗列了比较多的示例代码，如果你能坚持看完，对照学习，相信两个小时后你就能自己起飞愉快地去写scss了。 （一）Sass 与SCSS的区别1.1 什么是Sass Sass 是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。 1.2 Sass 与SCSS有什么区别 Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass ，两者之间不同之处有以下两点： 文件扩展名不同：Sass 是以 .sass 后缀为扩展名SCSS 是以 .scss 后缀为扩展名 语法书写方式不同：Sass 是以严格的缩进式语法规则来书写，不带大括号 {} 和分号 ;SCSS 的语法书写和我们的 CSS 语法书写方式非常类似 建议使用后缀名为 scss 的文件，以避免 sass 后缀名的严格格式要求报错。 （二）安装和使用2.1 安装 Sass 基于Ruby语言，但两者语法之间没有关系。使用Sass 无需先学习ruby，但是必须先安装Ruby，然后再安装Sass 。 macbook自带ruby环境，直接打开终端运行 gem 命令安装sass 即可； windows需要先自行安装ruby，然后在 CMD 或其他命令行工具中运行安装命令； ruby官网 安装时请勾选Add Ruby executables to your PATH这个选项，添加环境变量，不然以后使用编译软件的时候会提示找不到ruby环境 正确安装完ruby依赖后，安装sass： 1gem install sass 安装sass完成后查看版本测试安装有没有成功： 123sass -v# 安装成功会打印版本号Sass 3.5.1 (Bleeding Edge) 如上已经安装成功。但因为国内网络（不可描述）的问题导致gem源间歇性中断，因此我们需要更换gem源。 使用淘宝的gem源 https://ruby.taobao.org/： 123456789101112# 1.删除原gem源gem sources --remove https://rubygems.org/# 2.添加国内淘宝源gem sources -a https://ruby.taobao.org/# 3.打印是否替换成功gem sources -l# 4.更换成功后打印如下*** CURRENT SOURCES ***https://ruby.taobao.org/ 2.2 使用 windows 用户注意：编译 scss 文件中如果存在中文，可能出现类似于这样的报错：1`Syntax error: Invalid GBK character "\xE5"` 请一定不要惊慌，找到类似于下面的目录：1C:\Ruby24-x64\lib\ruby\gems\2.4.0\gems\sass-3.5.1\lib\sass 然后在该目录中找到 engine.rb ，编辑添加一行代码：1Encoding.default_external = Encoding.find('utf-8') 编译sass sass 编译有很多种方式，如命令行编译模式、sublime插件SASS-Build、编译软件koala、前端自动化软件codekit、Grunt打造前端自动化工作流grunt-sass、Gulp打造前端自动化工作流gulp-ruby-sass等。 命令行编译; 1234567891011# 1. 直接打印转化后的代码sass test.scss# 2. 单文件转换命令sass input.scss output.css# 3.1 单文件监听命令,实时转换sass --watch input.scss:output.css# 3.2 如果你有很多的sass文件，也可以监听整个目录：sass --watch app/sass:public/stylesheets SASS提供四个编译风格的选项： 1234* nested：嵌套缩进的css代码，它是默认值。* expanded：没有缩进的、扩展的css代码。* compact：简洁格式的css代码。* compressed：压缩后的css代码。 操作命令：12# 添加指令 --style [编译风格]sass test.sass test.css --style compressed 四种编译排版演示:123456789//未编译样式.box &#123; width: 300px; height: 400px; &amp;-title &#123; height: 30px; line-height: 30px; &#125;&#125; nested 嵌套缩进的css代码 1234567/*编译过后样式*/.box &#123; width: 300px; height: 400px; &#125; .box-title &#123; height: 30px; line-height: 30px; &#125; expanded 没有缩进的、扩展的css代码 123456789/*编译过后样式*/.box &#123; width: 300px; height: 400px;&#125;.box-title &#123; height: 30px; line-height: 30px;&#125; compact 简洁格式的css代码 123/*编译过后样式*/.box &#123; width: 300px; height: 400px; &#125;.box-title &#123; height: 30px; line-height: 30px; &#125; compressed 压缩后的css代码 12/*编译过后样式*/.box&#123;width:300px;height:400px&#125;.box-title&#123;height:30px;line-height:30px&#125; （三）基本用法 建议先下载示例代码，然后跟着走一遍，结束之后你会大致掌握Sass的基本用法 本部分主要分为六块，目录中未提及的变量、注释等其他基础用法已包含在其中。 Sass的官方网站，提供了一个在线转换器。你可以在那里，试运行下面的各种例子。 注： 以下所有代码块的第一行注释/*SCSS*/ 和 /*CSS*/ 是人为添加的！ 以下所有编译风格默认 nested 如果命令行出现类似如下提示说明该方法即将弃用，有时会向下面那样提示你用其他方法代替：123DEPRECATION WARNING on line 77 of input/calculate.scss:The operation `#123123 plus #040506` is deprecated and will be an error in future versions.Consider using Sass's color functions instead. 3.1 嵌套规则1. 选择器嵌套 父子层级关系明显； 代码具有良好的可读性； 示例：123456789101112/*SCSS*/#a &#123; .a-1 &#123; background: yellow; .child &#123; font-size: 12px; .child-1 &#123; color: red &#125; &#125; &#125;&#125; 1234567/*CSS*/#a .a-1 &#123; background: yellow; &#125; #a .a-1 .child &#123; font-size: 12px; &#125; #a .a-1 .child .child-1 &#123; color: red; &#125; 2. 引用父选择符： &amp;&amp; 在编译时将被替换为父选择符，输出到 CSS 中 示例：1234567891011/*scss*/.hello &#123; .dropdown &#123; display: none; &#125; &amp;:hover &#123; .dropdown &#123; display: block; &#125; &#125;&#125; 12345/*css*/.hello .dropdown &#123; display: none; &#125;.hello:hover .dropdown &#123; display: block; &#125; 3. 属性嵌套某些属性具有可选参数的，类似于 border 、font 、background 这样的，可以让你少复制自己的代码，当然直接使用缩写更方便一些，但使用属性嵌套的方法可读性更佳不是吗？ 示例：123456789101112/*scss*/.funky &#123; font: &#123; family: fantasy; size: 30em; weight: bold; &#125; border: &#123; radius: 20px; color: red; &#125;&#125; 1234567/*css*/.funky &#123; font-family: fantasy; font-size: 30em; font-weight: bold; border-radius: 20px; border-color: red; &#125; 4. 注释规则/*标准的CSS注释*/ 编译后依旧存在//单行注释 编译后被删除/*!重要注释*/在/*后面加一个感叹号 ! ，表示这是重要注释。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。 示例： 1234/*scss*//*标准的CSS注释*///单行注释/*!重要注释*/ 123/*css*//*标准的CSS注释*//*!重要注释*/ 3.2 计算规则1. 定义变量 $varSCSS中所有的变量由一个 $ 符号定义12345/*scss*/$width: 10px;#main &#123; width: $width;&#125; 123/*css*/#main &#123; width: 10px; &#125; 2. 插值: #{}将 #{里面的值}当做字符串插入1234567/*scss*/$name: foo;$attr: border;p.#&#123;$name&#125; &#123; #&#123;$attr&#125;-color: blue; content: "hello world #&#123;$name&#125;"&#125; 1234/*css*/p.foo &#123; border-color: blue; content: "hello world foo"; &#125; 在文本字符串中，#{} 形式的表达式可以被用来在字符串中添加动态值，空值会被视作空字符串：12345678/*scss*/p:before &#123; content: "I ate #&#123;5 + 10&#125; pies!";&#125;$value: null;p:before &#123; content: "I ate #&#123;$value&#125; pies!";&#125; 123456/*css*/p:before &#123; content: "I ate 15 pies!"; &#125;p:before &#123; content: "I ate pies!"; &#125; 3. +、-、*、/ 的运算 在SCSS中+ 、- 、* 的运算方法与日常使用相同，需要单位的还请都带上你的单位； / 除法运算比较特殊，直接使用最后编译出来的结果可能并不是你日常所想的那样，其特殊性大致分为三种情况，下面的代码演示中已一一说明； 圆括号 () 可以改变运算顺序； 1234567891011/*scss*//*加减法运算*/p &#123; width: 1px + 8px; height: 10px - 2px;&#125;/*乘法运算*/div &#123; width: 3px * 5; height: 2px + 6px * 3;&#125; 12345678910/*css*//*加减法运算*/p &#123; width: 9px; height: 8px; &#125;/*乘法运算*/div &#123; width: 15px; height: 20px; &#125; 圆括号 () 变运算顺序：1234/*scss*/p &#123; width: (1em + 2em) * 3;&#125; 123/*css*/p &#123; width: 9em; &#125; 除法运算比较特殊：在以下三种情况中，/ 会被解释为除法运算。 覆盖了绝大多数真正使用除法运算的情况。 这些情况是： 如果数值或它的任意部分是存储在一个变量中或是函数的返回值。 如果数值被圆括号包围。 如果数值是另一个数学表达式的一部分 12345678910/*scss*//*除法运算*/p &#123; font: 10px/8px; // 纯 CSS，不是除法运算，兼容IE8的写法 $width: 1000px; width: $width/2; // 使用了变量，是除法运算 line-height: round(3.5)/2; // 使用了函数，是除法运算 height: (500px/2); // 使用了圆括号，是除法运算 margin-left: 5px + 8px/2px; // 使用了加（+）号，是除法运算&#125; 1234567/*css*/p &#123; font: 10px/8px; width: 500px; line-height: 2; height: 250px; margin-left: 9px; &#125; 如果你希望在纯 CSS 中使用 变量 和 /， 你可以用 #{} 包住 变量 。 例如：123456/*scss*/p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125; 123/*css*/p &#123; font: 12px/30px; &#125; 3.3 @import@media@extend 指令1. 引入 @import@import &quot;basic&quot;：查找当前目录下的 basic.scss 或者 basic.sass 引入到当前文件中1234567891011121314/*scss*/@import "basic";//basic.sass内容如下//#a &#123;// .a-1 &#123;// background: yellow;// .child &#123;// font-size: 12px;// .child-1 &#123;// color: red// &#125;// &#125;// &#125;//&#125; 1234567/*css*/#a .a-1 &#123; background: yellow; &#125; #a .a-1 .child &#123; font-size: 12px; &#125; #a .a-1 .child .child-1 &#123; color: red; &#125; 直接 @import test.css 相当于原生CSS的 @import 引用12/*scss*/@import "test.css"; 12/*css*/@import url(test.css); 2. 嵌套 @import有助于创建一个新的命名空间123456789101112131415/*scss*/.example &#123; @import "basic.scss";&#125;//basic.sass内容如下//#a &#123;// .a-1 &#123;// background: yellow;// .child &#123;// font-size: 12px;// .child-1 &#123;// color: red// &#125;// &#125;/ 12345678/*css*/.example &#123;&#125; .example #a .a-1 &#123; background: yellow; &#125; .example #a .a-1 .child &#123; font-size: 12px; &#125; .example #a .a-1 .child .child-1 &#123; color: red; &#125; 3. 媒体查询 @media用法与原生CSS一样123456789101112/*scss*/.father &#123; .sidebar &#123; width: 300px; @media screen and (orientation: landscape) &#123; width: 500px; .hello &#123; font-size: 20px &#125; &#125; &#125;&#125; 12345678/*css*/.father .sidebar &#123; width: 300px; &#125; @media screen and (orientation: landscape) &#123; .father .sidebar &#123; width: 500px; &#125; .father .sidebar .hello &#123; font-size: 20px; &#125; &#125; 4. 继承 @extend使用 @extend 可以让一个选择器继承另一个选择器 4.1 继承单个选择器12345678910111213/*scss*/.error &#123; border: 1px #f00; &amp;.intrusion &#123; background-image: url("/image/hacked.png"); &#125; &amp;:hover &#123; color: #00b88d; &#125;&#125;.extendError &#123; @extend .error;&#125; 1234567/*css*/.error, .extendError, .seriousError, .criticalError &#123; border: 1px #f00; &#125; .error.intrusion, .intrusion.extendError, .intrusion.seriousError, .intrusion.criticalError &#123; background-image: url("/image/hacked.png"); &#125; .error:hover, .extendError:hover, .seriousError:hover, .criticalError:hover &#123; color: #00b88d; &#125; 4.2 继承复合选择器12345678910111213/*scss*/.div1.div2 &#123; text-decoration: underline;&#125;.div3:hover &#123; text-decoration: overline;&#125;.extend1 &#123; @extend .div1.div2;&#125;.extend2 &#123; @extend .div3:hover&#125; 123456/*css*/.div1.div2, .extend1 &#123; text-decoration: underline; &#125;.div3:hover, .extend2 &#123; text-decoration: overline; &#125; 4.3 继承多个选择器1234567891011121314151617/*scss*/.error &#123; border: 1px #f00; background-color: #fdd;&#125;.attention &#123; font-size: 3em; background-color: #ff0;&#125;.seriousError &#123; // ===&gt; @extend .error; @extend .attention; border-width: 3px;&#125; 1234567891011/*css*/.error, .seriousError &#123; border: 1px #f00; background-color: #fdd; &#125;.attention, .seriousError &#123; font-size: 3em; background-color: #ff0; &#125;.seriousError &#123; border-width: 3px; &#125; 4.4 连续继承12345678910111213141516171819/*scss*/.error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125;.criticalError &#123; @extend .seriousError; position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%;&#125; 1234567891011121314/*css*/.error, .seriousError, .criticalError &#123; border: 1px #f00; background-color: #fdd; &#125;.seriousError, .criticalError &#123; border-width: 3px; &#125;.criticalError &#123; position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%; &#125; 3.4 mixin 指令@mixin 可以预先定义样式的代码块；@include 可以引入 @mixin 预定义的样式；该指令类似于 @extend 的继承效果，区别是@mixin指令预定义的样式编译后会自动去除，可以有效避免使用非语义化的类名； 1. @mixin 与 @include示例1：样式123456789101112131415/*scss*/@mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125;.page-title &#123; @include large-text; padding: 4px; margin-top: 10px;&#125; 12345678/*css*/.page-title &#123; font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px; &#125; 示例2：选择器 + 样式123456789/*scss*/@mixin silly-links &#123; a &#123; color: blue; background-color: red; &#125;&#125;@include silly-links; 1234/*css*/a &#123; color: blue; background-color: red; &#125; 示例3：复合使用1234567891011121314151617/*scss*/@mixin highlighted-background &#123; background-color: #fc0;&#125;@mixin header-text &#123; font-size: 20px;&#125;@mixin compound &#123; @include highlighted-background; @include header-text;&#125;.test &#123; @include compound&#125; 1234/*css*/.test &#123; background-color: #fc0; font-size: 20px; &#125; 2. 定义参数示例4：$arguments@mixin 可以定义参数，@include调用的时候传参；123456789101112/*scss*/@mixin sexy-border($color, $width) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue, 10px);&#125; 12345/*css*/p &#123; border-color: blue; border-width: 10px; border-style: dashed; &#125; 3. 指定参数的缺省值123456789/*scss*/@mixin left($value: 10px) &#123; float: left; margin-right: $value;&#125;p &#123; @include left;&#125; 1234/*css*/p &#123; float: left; margin-right: 10px; &#125; 4. $arg...示例5：$arg...可以用 $参数... 表示所有传入的参数1234567891011/*scss*/$b: box-shadow;@mixin box-shadow($shadows...) &#123; -moz-#&#123;$b&#125;: $shadows; -webkit-#&#123;$b&#125;: $shadows; #&#123;$b&#125;: $shadows;&#125;.shadows &#123; @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);&#125; 12345/*css*/.shadows &#123; -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; &#125; 3.5 条件语句、循环语句1. 条件语句@if...else... 条件判断，判断结果为 true 时赋值样式 示例1：123456789101112131415/*scss*/p &#123; @if 1 + 1 == 2 &#123; border: 1px solid; &#125; @if true &#123; background-image: url(''); &#125; @if 5 &lt; 3 &#123; border: 2px dotted; &#125; @if null &#123; border: 3px double; &#125;&#125; 1234/*css*/p &#123; border: 1px solid; background-image: url(""); &#125; 示例2：12345678910111213/*scss*/$type: monster;p &#123; @if $type == ocean &#123; color: blue; &#125; @else if $type == matador &#123; color: red; &#125; @else if $type == monster &#123; color: green; &#125; @else &#123; color: black; &#125;&#125; 123/*css*/p &#123; color: green; &#125; 2. 循环语句注意form...through与from ... to循环的范围 2.1 @for $var form...through...示例：from … through123456/*scss*/@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; 123456789/*css*/.item-1 &#123; width: 2em; &#125;.item-2 &#123; width: 4em; &#125;.item-3 &#123; width: 6em; &#125; 2.2 @for $var from...to...示例：from … to123456/*scss*/@for $i from 1 to 3 &#123; .item-to-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; 123456/*css*/.item-to-1 &#123; width: 2em; &#125;.item-to-2 &#123; width: 4em; &#125; 2.3 @each $var in ...@each 为 $var 循环所有 in 后面列出的值示例：@each … in …123456/*scss*/@each $animal in puma, sea-slug, egret, salamander &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/images/#&#123;$animal&#125;.png'); &#125;&#125; 123456789101112/*css*/.puma-icon &#123; background-image: url("/images/puma.png"); &#125;.sea-slug-icon &#123; background-image: url("/images/sea-slug.png"); &#125;.egret-icon &#123; background-image: url("/images/egret.png"); &#125;.salamander-icon &#123; background-image: url("/images/salamander.png"); &#125; 2.4 @while $var ...示例：while循环12345678/*scss*/$i: 6;@while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2;&#125; 123456789/*css*/.item-6 &#123; width: 12em; &#125;.item-4 &#123; width: 8em; &#125;.item-2 &#123; width: 4em; &#125; 2.5 条件 + 循环示例：12345678/*scss*///@for 后面的第一个$i 相当于参数，第二个$i 直接将变量的值拿过来用$i: 6;@for $i from 1 through $i &#123; .col-#&#123;$i&#125; &#123; width: $i/6*100% &#125;&#125; 相当于：1234567/*scss*/$i: 6;@for $j from 1 through $i &#123; .col-#&#123;$j&#125; &#123; width: $j/6*100% &#125;&#125; 123456789101112131415161718/*css*/.col-1 &#123; width: 16.6666666667%; &#125;.col-2 &#123; width: 33.3333333333%; &#125;.col-3 &#123; width: 50%; &#125;.col-4 &#123; width: 66.6666666667%; &#125;.col-5 &#123; width: 83.3333333333%; &#125;.col-6 &#123; width: 100%; &#125; 3.6 自定义函数12345678910111213141516171819202122/*scss*/$grid-width: 40px;$gutter-width: 10px;@function test($a) &#123; @return $a + 10;&#125;@function grid-width($n) &#123; $hello: 1px; @for $i from 1 through $n &#123; $hello: $hello + $i; &#125; @if $hello &gt; 10 &#123; $hello: 15px; &#125; @return $hello + test(2);&#125;#sidebar &#123; width: grid-width(5);&#125; 123/*css*/#sidebar &#123; width: 27px; &#125; （教程结束） 复习 如果你对着教程自己有在操作，那么你可以再抽时间过一遍阮一峰老师的SASS用法指南，配合食用味道更佳哦~ （完） 参考SASS用法指南-阮一峰SASS中文文档-bootcss]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Blog！]]></title>
    <url>%2F2017%2F08%2F19%2FHello%20Blog%EF%BC%81%2F</url>
    <content type="text"><![CDATA[一、为什么要写博客不知道大家写博客的理由都是什么，反正我的理由很简单，不外乎以下几点： 记录自己的学习笔记； 记录自己的生活动态； 分享一些有趣的东西； 一个全平台的收藏夹； 处女座来强行凑个数； 二、写博客的好处我的天！这个标题让我想起还在学校的时候，本宝宝是经管学院市场营销专业的QAQ，还记得网络营销的第一课就是经典的企业博客营销，所以你有事没事分享点有趣的东西骗骗粉也不错吖，指不定哪天就火了呢~尤其是在目前这个粉丝经济尤为突出的市场环境下，万一你一不小心火了，博客就是你的招牌，你说是不咯？ 当然本宝宝并不是冲着营销号方向走的=。=纯粹是为了记录自己的进步与二逼的想法QAQ 强化记忆！个人觉得这是写博客对自己最大的好处了。 学习上以前没有记笔记的习惯，但是现在要转行做码农辣，学习了一段时候后才发现，不记笔记是硬伤！不记笔记是硬伤！不记笔记是硬伤！ 重要的事情说三遍。不知道其他的圈子是什么样的 ，至少以我目前浅薄的目光来看前端圈，琳（luan）琅（qi）满（ba）目（zao）的API，除非有着超超超超一流的记忆能力，否则你很难记住一些奇奇怪怪的东西。 生活上可以记录一些有意思的生活动态，比如说游记、菜谱、随笔、灵感等。指不定某天冒出个想法改变了自己的未来呢，哈哈。 三、写好博客的秘诀贵在坚持，仅此而已。自己也是第一次开始尝试写个人博客，就先这样吧=。= （完）]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
